{
  "version": 3,
  "sources": ["../../../app/routes/$slug.tsx"],
  "sourcesContent": ["/* eslint-disable prettier/prettier */\nimport type {\n  ActionFunction,\n  LinksFunction,\n  LoaderArgs,\n  MetaFunction,\n} from '@remix-run/node';\nimport { json } from '@remix-run/node';\nimport { useLoaderData } from '@remix-run/react';\nimport groq from 'groq';\nimport { PreviewSuspense } from '@sanity/preview-kit';\nimport urlBuilder from '@sanity/image-url';\nimport stylesheet from '~/tailwind.css';\nimport Record, { PreviewRecord } from '~/components/Product';\nimport { getClient, writeClient } from '~/sanity/client';\nimport { productZ } from '~/types/product';\nimport { getSession } from '~/sessions';\nimport type { HomeDocument } from '~/types/home';\nimport { projectDetails } from '~/sanity/projectDetails';\n\nexport const links: LinksFunction = () => {\n  return [{ rel: 'stylesheet', href: stylesheet }];\n};\n\nexport const meta: MetaFunction = ({ data, parentsData }) => {\n  const home = parentsData.root.home as HomeDocument;\n\n  return {\n    title: [data.product.metatitle, home.siteTitle].filter(Boolean).join(' | '),\n    description: [data.product.metadescription],\n    'og:image': urlBuilder(projectDetails())\n      .image(data.product.metaimage.asset._ref)\n      .url(),\n  };\n};\n\n// Perform a `like` or `dislike` mutation on a `product` document\nexport const action: ActionFunction = async ({ request }) => {\n  if (request.method !== 'POST') {\n    return json({ message: 'Method not allowed' }, 405);\n  }\n\n  const body = await request.formData();\n  const id = String(body.get('id'));\n  const action = String(body.get('action'));\n\n  if (id) {\n    switch (action) {\n      case 'LIKE':\n        return await writeClient\n          .patch(id)\n          .setIfMissing({ likes: 0 })\n          .inc({ likes: 1 })\n          .commit()\n          .then(({ likes, dislikes }) => ({\n            likes: likes ?? 0,\n            dislikes: dislikes ?? 0,\n          }));\n      case 'DISLIKE':\n        return await writeClient\n          .patch(id)\n          .setIfMissing({ dislikes: 0 })\n          .inc({ dislikes: 1 })\n          .commit()\n          .then(({ likes, dislikes }) => ({\n            likes: likes ?? 0,\n            dislikes: dislikes ?? 0,\n          }));\n      default:\n        return json({ message: 'Invalid action' }, 400);\n    }\n  }\n\n  return json({ message: 'Bad request' }, 400);\n};\n\n// Load the `product` document with this slug\nexport const loader = async ({ params, request }: LoaderArgs) => {\n  const session = await getSession(request.headers.get('Cookie'));\n  const token = session.get('token');\n  const preview = Boolean(token);\n\n  const query = groq`*[_type == \"product\" && slug.current == $slug][0]{\n    _id,\n    title,\n    // GROQ can re-shape data in the request!\n    \"slug\": slug.current,\n    \"category\": category->title,\n    \"categoryslug\": category->slug.current,\n\n    // coalesce() returns the first value that is not null\n    // so we can ensure we have at least a zero\n    \"likes\": coalesce(likes, 0),\n    \"dislikes\": coalesce(dislikes, 0),\n    // for simplicity in this demo these are typed as \"any\"\n    // we can make them type-safe with a little more work\n    // https://www.simeongriggs.dev/type-safe-groq-queries-for-sanity-data-with-zod\n    image,\n    content,\n    metatitle,\n    metadescription,\n    metaimage,\n    overview,\n    score,\n    referral,\n    pricing,\n    ease,\n    support,\n    // this is how we extract values from arrays\n    features[]{\n      _key,\n      title,\n      description\n    },\n    pros[]{\n      _key,\n      title,\n      description\n\n    },\n    cons[]{\n      _key,\n      title,\n      description\n\n    },  tags[]{\n    _key,\n    \"title\": @->title,\n    \"slug\": @->slug.current\n  }\n  }`;\n\n  const product = await getClient(preview)\n    // Params from the loader uses the filename\n    // $slug.tsx has the params { slug: 'hello-world' }\n    .fetch(query, params)\n    // Parsed with Zod to validate data at runtime\n    // and generate a Typescript type\n    .then((res) => (res ? productZ.parse(res) : null));\n\n  if (!product) {\n    throw new Response('Not found', { status: 404 });\n  }\n\n  return json({\n    product,\n    preview,\n    query: preview ? query : null,\n    params: preview ? params : null,\n    // Note: This makes the token available to the client if they have an active session\n    // This is useful to show live preview to unauthenticated users\n    // If you would rather not, replace token with `null` and it will rely on your Studio auth\n    token: preview ? token : null,\n  });\n};\n\nexport default function RecordPage() {\n  const { product, preview, query, params, token } =\n    useLoaderData<typeof loader>();\n\n  if (preview && query && params && token) {\n    return (\n      <PreviewSuspense fallback={<Record {...product} />}>\n        <PreviewRecord query={query} params={params} token={token} />\n      </PreviewSuspense>\n    );\n  }\n\n  return <Record {...product} />;\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA,kBAAiB;AAEjB,uBAAuB;AAuJU;AA9I1B,IAAM,QAAuB,MAAM;AACxC,SAAO,CAAC,EAAE,KAAK,cAAc,MAAM,iBAAW,CAAC;AACjD;AAEO,IAAM,OAAqB,CAAC,EAAE,MAAM,YAAY,MAAM;AAC3D,QAAM,OAAO,YAAY,KAAK;AAE9B,SAAO;AAAA,IACL,OAAO,CAAC,KAAK,QAAQ,WAAW,KAAK,SAAS,EAAE,OAAO,OAAO,EAAE,KAAK,KAAK;AAAA,IAC1E,aAAa,CAAC,KAAK,QAAQ,eAAe;AAAA,IAC1C,gBAAY,iBAAAA,SAAW,eAAe,CAAC,EACpC,MAAM,KAAK,QAAQ,UAAU,MAAM,IAAI,EACvC,IAAI;AAAA,EACT;AACF;AA0He,SAAR,aAA8B;AACnC,QAAM,EAAE,SAAS,SAAS,OAAO,QAAQ,MAAM,IAC7C,cAA6B;AAE/B,MAAI,WAAW,SAAS,UAAU,OAAO;AACvC,WACE,mDAAC,mBAAgB,UAAU,mDAAC,UAAQ,GAAG,WAAZ;AAAA;AAAA;AAAA;AAAA,WAAqB,GAC9C,6DAAC,iBAAc,OAAc,QAAgB,SAA7C;AAAA;AAAA;AAAA;AAAA,WAA2D,KAD7D;AAAA;AAAA;AAAA;AAAA,WAEA;AAAA,EAEJ;AAEA,SAAO,mDAAC,UAAQ,GAAG,WAAZ;AAAA;AAAA;AAAA;AAAA,SAAqB;AAC9B;",
  "names": ["urlBuilder"]
}
