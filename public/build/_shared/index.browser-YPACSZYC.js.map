{
  "version": 3,
  "sources": ["../../../node_modules/fast-deep-equal/index.js", "../../../node_modules/@sanity/groq-store/node_modules/groq/src/groq.ts", "../../../node_modules/throttle-debounce/throttle.js", "../../../node_modules/throttle-debounce/debounce.js", "../../../node_modules/groq-js/src/values/Path.ts", "../../../node_modules/groq-js/src/values/StreamValue.ts", "../../../node_modules/groq-js/src/values/dateHelpers.ts", "../../../node_modules/groq-js/src/values/utils.ts", "../../../node_modules/groq-js/src/evaluator/equality.ts", "../../../node_modules/groq-js/src/evaluator/matching.ts", "../../../node_modules/groq-js/src/evaluator/ordering.ts", "../../../node_modules/groq-js/src/evaluator/operators.ts", "../../../node_modules/groq-js/src/evaluator/scope.ts", "../../../node_modules/groq-js/src/evaluator/evaluate.ts", "../../../node_modules/groq-js/src/evaluator/constantEvaluate.ts", "../../../node_modules/groq-js/src/evaluator/pt.ts", "../../../node_modules/groq-js/src/evaluator/scoring.ts", "../../../node_modules/groq-js/src/evaluator/functions.ts", "../../../node_modules/groq-js/src/markProcessor.ts", "../../../node_modules/groq-js/src/rawParser.js", "../../../node_modules/groq-js/src/traversal.ts", "../../../node_modules/groq-js/src/parser.ts", "../../../node_modules/@sanity/groq-store/src/listen.ts", "../../../node_modules/@sanity/groq-store/src/drafts.ts", "../../../node_modules/@sanity/groq-store/src/patch.ts", "../../../node_modules/@sanity/groq-store/src/syncingDataset.ts", "../../../node_modules/@sanity/groq-store/src/groqStore.ts", "../../../node_modules/@sanity/groq-store/src/browser/getDocuments.ts", "../../../node_modules/@sanity/groq-store/src/browser/support.ts", "../../../node_modules/@sanity/groq-store/src/browser/index.ts"],
  "sourcesContent": ["'use strict';\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n", "/**\n * Pass-through groq template tag. This is a no-op, but it helps editor integrations\n * understand that a string represents a GROQ query in order to provide syntax highlighting\n * and other features.\n *\n * @param strings - Template string parts\n * @param keys - Template string keys\n * @returns The same string as the input\n * @public\n */\nexport default function groq(strings: TemplateStringsArray, ...keys: any[]): string {\n  const lastIndex = strings.length - 1\n  return (\n    strings.slice(0, lastIndex).reduce((acc, str, i) => {\n      return acc + str + keys[i]\n    }, '') + strings[lastIndex]\n  )\n}\n", "/* eslint-disable no-undefined,no-param-reassign,no-shadow */\n\n/**\n * Throttle execution of a function. Especially useful for rate limiting\n * execution of handlers on events like resize and scroll.\n *\n * @param {number} delay -                  A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher)\n *                                            are most useful.\n * @param {Function} callback -               A function to be executed after delay milliseconds. The `this` context and all arguments are passed through,\n *                                            as-is, to `callback` when the throttled-function is executed.\n * @param {object} [options] -              An object to configure options.\n * @param {boolean} [options.noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds\n *                                            while the throttled-function is being called. If noTrailing is false or unspecified, callback will be executed\n *                                            one final time after the last throttled-function call. (After the throttled-function has not been called for\n *                                            `delay` milliseconds, the internal counter is reset).\n * @param {boolean} [options.noLeading] -   Optional, defaults to false. If noLeading is false, the first throttled-function call will execute callback\n *                                            immediately. If noLeading is true, the first the callback execution will be skipped. It should be noted that\n *                                            callback will never executed if both noLeading = true and noTrailing = true.\n * @param {boolean} [options.debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is\n *                                            false (at end), schedule `callback` to execute after `delay` ms.\n *\n * @returns {Function} A new, throttled, function.\n */\nexport default function (delay, callback, options) {\n\tconst {\n\t\tnoTrailing = false,\n\t\tnoLeading = false,\n\t\tdebounceMode = undefined\n\t} = options || {};\n\t/*\n\t * After wrapper has stopped being called, this timeout ensures that\n\t * `callback` is executed at the proper times in `throttle` and `end`\n\t * debounce modes.\n\t */\n\tlet timeoutID;\n\tlet cancelled = false;\n\n\t// Keep track of the last time `callback` was executed.\n\tlet lastExec = 0;\n\n\t// Function to clear existing timeout\n\tfunction clearExistingTimeout() {\n\t\tif (timeoutID) {\n\t\t\tclearTimeout(timeoutID);\n\t\t}\n\t}\n\n\t// Function to cancel next exec\n\tfunction cancel(options) {\n\t\tconst { upcomingOnly = false } = options || {};\n\t\tclearExistingTimeout();\n\t\tcancelled = !upcomingOnly;\n\t}\n\n\t/*\n\t * The `wrapper` function encapsulates all of the throttling / debouncing\n\t * functionality and when executed will limit the rate at which `callback`\n\t * is executed.\n\t */\n\tfunction wrapper(...arguments_) {\n\t\tlet self = this;\n\t\tlet elapsed = Date.now() - lastExec;\n\n\t\tif (cancelled) {\n\t\t\treturn;\n\t\t}\n\n\t\t// Execute `callback` and update the `lastExec` timestamp.\n\t\tfunction exec() {\n\t\t\tlastExec = Date.now();\n\t\t\tcallback.apply(self, arguments_);\n\t\t}\n\n\t\t/*\n\t\t * If `debounceMode` is true (at begin) this is used to clear the flag\n\t\t * to allow future `callback` executions.\n\t\t */\n\t\tfunction clear() {\n\t\t\ttimeoutID = undefined;\n\t\t}\n\n\t\tif (!noLeading && debounceMode && !timeoutID) {\n\t\t\t/*\n\t\t\t * Since `wrapper` is being called for the first time and\n\t\t\t * `debounceMode` is true (at begin), execute `callback`\n\t\t\t * and noLeading != true.\n\t\t\t */\n\t\t\texec();\n\t\t}\n\n\t\tclearExistingTimeout();\n\n\t\tif (debounceMode === undefined && elapsed > delay) {\n\t\t\tif (noLeading) {\n\t\t\t\t/*\n\t\t\t\t * In throttle mode with noLeading, if `delay` time has\n\t\t\t\t * been exceeded, update `lastExec` and schedule `callback`\n\t\t\t\t * to execute after `delay` ms.\n\t\t\t\t */\n\t\t\t\tlastExec = Date.now();\n\t\t\t\tif (!noTrailing) {\n\t\t\t\t\ttimeoutID = setTimeout(debounceMode ? clear : exec, delay);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\t/*\n\t\t\t\t * In throttle mode without noLeading, if `delay` time has been exceeded, execute\n\t\t\t\t * `callback`.\n\t\t\t\t */\n\t\t\t\texec();\n\t\t\t}\n\t\t} else if (noTrailing !== true) {\n\t\t\t/*\n\t\t\t * In trailing throttle mode, since `delay` time has not been\n\t\t\t * exceeded, schedule `callback` to execute `delay` ms after most\n\t\t\t * recent execution.\n\t\t\t *\n\t\t\t * If `debounceMode` is true (at begin), schedule `clear` to execute\n\t\t\t * after `delay` ms.\n\t\t\t *\n\t\t\t * If `debounceMode` is false (at end), schedule `callback` to\n\t\t\t * execute after `delay` ms.\n\t\t\t */\n\t\t\ttimeoutID = setTimeout(\n\t\t\t\tdebounceMode ? clear : exec,\n\t\t\t\tdebounceMode === undefined ? delay - elapsed : delay\n\t\t\t);\n\t\t}\n\t}\n\n\twrapper.cancel = cancel;\n\n\t// Return the wrapper function.\n\treturn wrapper;\n}\n", "/* eslint-disable no-undefined */\n\nimport throttle from './throttle.js';\n\n/**\n * Debounce execution of a function. Debouncing, unlike throttling,\n * guarantees that a function is only executed a single time, either at the\n * very beginning of a series of calls, or at the very end.\n *\n * @param {number} delay -               A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.\n * @param {Function} callback -          A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,\n *                                        to `callback` when the debounced-function is executed.\n * @param {object} [options] -           An object to configure options.\n * @param {boolean} [options.atBegin] -  Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds\n *                                        after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.\n *                                        (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).\n *\n * @returns {Function} A new, debounced function.\n */\nexport default function (delay, callback, options) {\n\tconst { atBegin = false } = options || {};\n\treturn throttle(delay, callback, { debounceMode: atBegin !== false });\n}\n", "function escapeRegExp(string: string) {\n  return string.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&')\n}\n\nfunction pathRegExp(pattern: string) {\n  const re = []\n  for (const part of pattern.split('.')) {\n    if (part === '*') {\n      re.push('[^.]+')\n    } else if (part === '**') {\n      re.push('.*')\n    } else {\n      re.push(escapeRegExp(part))\n    }\n  }\n\n  return new RegExp(`^${re.join('.')}$`)\n}\n\nexport class Path {\n  private pattern: string\n  private patternRe: RegExp\n\n  constructor(pattern: string) {\n    this.pattern = pattern\n    this.patternRe = pathRegExp(pattern)\n  }\n\n  matches(str: string): boolean {\n    return this.patternRe.test(str)\n  }\n\n  toJSON(): string {\n    return this.pattern\n  }\n}\n", "import type {Value} from './types'\n\nexport class StreamValue {\n  type: 'stream' = 'stream'\n  private generator: () => AsyncGenerator<Value, void, unknown>\n  private ticker: Promise<void> | null\n  private isDone: boolean\n  private data: Value[]\n\n  constructor(generator: () => AsyncGenerator<Value, void, unknown>) {\n    this.generator = generator\n    this.ticker = null\n    this.isDone = false\n    this.data = []\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  isArray(): boolean {\n    return true\n  }\n\n  async get(): Promise<any> {\n    const result = []\n    for await (const value of this) {\n      result.push(await value.get())\n    }\n    return result\n  }\n\n  async *[Symbol.asyncIterator](): AsyncGenerator<Value, void, unknown> {\n    let i = 0\n    while (true) {\n      for (; i < this.data.length; i++) {\n        yield this.data[i]\n      }\n\n      if (this.isDone) {\n        return\n      }\n\n      await this._nextTick()\n    }\n  }\n\n  _nextTick(): Promise<void> {\n    if (this.ticker) {\n      return this.ticker\n    }\n\n    let currentResolver: (value?: void | PromiseLike<void> | undefined) => void\n    const setupTicker = () => {\n      this.ticker = new Promise((resolve) => {\n        currentResolver = resolve\n      })\n    }\n\n    const tick = () => {\n      currentResolver()\n      setupTicker()\n    }\n\n    const fetch = async () => {\n      for await (const value of this.generator()) {\n        this.data.push(value)\n        tick()\n      }\n\n      this.isDone = true\n      tick()\n    }\n\n    setupTicker()\n    fetch()\n    return this.ticker!\n  }\n}\n", "const RFC3339_REGEX = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(Z|([-+]\\d{2}:\\d{2}))$/\n\nexport function parseRFC3339(str: string): Date | null {\n  if (RFC3339_REGEX.test(str)) {\n    return new Date(str)\n  }\n  return null\n}\n\nexport function formatRFC3339(d: Date): string {\n  const year = addLeadingZero(d.getUTCFullYear(), 4)\n  const month = addLeadingZero(d.getUTCMonth() + 1, 2)\n  const day = addLeadingZero(d.getUTCDate(), 2)\n  const hour = addLeadingZero(d.getUTCHours(), 2)\n  const minute = addLeadingZero(d.getUTCMinutes(), 2)\n  const second = addLeadingZero(d.getUTCSeconds(), 2)\n\n  let fractionalSecond = ''\n  const millis = d.getMilliseconds()\n  if (millis != 0) {\n    fractionalSecond = `.${addLeadingZero(millis, 3)}`\n  }\n\n  return `${year}-${month}-${day}T${hour}:${minute}:${second}${fractionalSecond}Z`\n}\n\ntype Stringer = {\n  toString(): string\n}\n\nfunction addLeadingZero(num: Stringer, targetLength: number) {\n  let str = num.toString()\n  while (str.length < targetLength) {\n    str = `0${str}`\n  }\n  return str\n}\n", "import {formatRFC3339, parseRFC3339} from './dateHelpers'\nimport {Path} from './Path'\nimport {StreamValue} from './StreamValue'\nimport {BooleanValue, GroqType, NullValue, Value} from './types'\n\nexport class StaticValue<P, T extends GroqType> {\n  data: P\n  type: T\n\n  constructor(data: P, type: T) {\n    this.data = data\n    this.type = type\n  }\n\n  isArray(): boolean {\n    return this.type === 'array'\n  }\n\n  // eslint-disable-next-line require-await\n  async get(): Promise<any> {\n    return this.data\n  }\n\n  [Symbol.asyncIterator](): Generator<Value, void, unknown> {\n    if (Array.isArray(this.data)) {\n      return (function* (data) {\n        for (const element of data) {\n          yield fromJS(element)\n        }\n      })(this.data)\n    }\n    throw new Error(`Cannot iterate over: ${this.type}`)\n  }\n}\n\nexport const NULL_VALUE: NullValue = new StaticValue(null, 'null')\nexport const TRUE_VALUE: BooleanValue = new StaticValue(true, 'boolean')\nexport const FALSE_VALUE: BooleanValue = new StaticValue(false, 'boolean')\n\nexport class DateTime {\n  date: Date\n\n  constructor(date: Date) {\n    this.date = date\n  }\n\n  static parseToValue(str: string): Value {\n    const date = parseRFC3339(str)\n    if (date) {\n      return new StaticValue(new DateTime(date), 'datetime')\n    }\n    return NULL_VALUE\n  }\n\n  equals(other: DateTime): boolean {\n    return this.date.getTime() == other.date.getTime()\n  }\n\n  add(secs: number): DateTime {\n    const copy = new Date(this.date.getTime())\n    copy.setTime(copy.getTime() + secs * 1000)\n    return new DateTime(copy)\n  }\n\n  difference(other: DateTime): number {\n    return (this.date.getTime() - other.date.getTime()) / 1000\n  }\n\n  compareTo(other: DateTime): number {\n    return this.date.getTime() - other.date.getTime()\n  }\n\n  toString(): string {\n    return formatRFC3339(this.date)\n  }\n\n  toJSON(): string {\n    return this.toString()\n  }\n}\n\nexport function fromNumber(num: number): Value {\n  if (Number.isFinite(num)) {\n    return new StaticValue(num, 'number')\n  }\n  return NULL_VALUE\n}\n\nexport function fromString(str: string): Value {\n  return new StaticValue(str, 'string')\n}\n\nexport function fromDateTime(dt: DateTime): Value {\n  return new StaticValue(dt, 'datetime')\n}\n\nexport function fromPath(path: Path): Value {\n  return new StaticValue(path, 'path')\n}\n\nfunction isIterator(obj?: Iterator<any>) {\n  return obj && typeof obj.next === 'function'\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function fromJS(val: any): Value {\n  if (isIterator(val)) {\n    return new StreamValue(async function* () {\n      for await (const value of val) {\n        yield fromJS(value)\n      }\n    })\n  } else if (val === null || val === undefined) {\n    return NULL_VALUE\n  }\n  return new StaticValue(val, getType(val)) as any\n}\n\n/**\n * Returns the type of the value.\n */\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function getType(data: any): GroqType {\n  if (data === null || typeof data === 'undefined') {\n    return 'null'\n  }\n  if (Array.isArray(data)) {\n    return 'array'\n  }\n  if (data instanceof Path) {\n    return 'path'\n  }\n  if (data instanceof DateTime) {\n    return 'datetime'\n  }\n  return typeof data as GroqType\n}\n", "import {Value} from '../values'\n\nexport function isEqual(a: Value, b: Value): boolean {\n  if (\n    (a.type === 'string' && b.type === 'string') ||\n    (a.type === 'boolean' && b.type === 'boolean') ||\n    (a.type === 'null' && b.type === 'null') ||\n    (a.type === 'number' && b.type === 'number')\n  ) {\n    return a.data === b.data\n  }\n\n  if (a.type === 'datetime' && b.type === 'datetime') {\n    return a.data.equals(b.data)\n  }\n\n  return false\n}\n", "import {Value} from '../values'\n\nconst CHARS = /([^!@#$%^&*(),\\\\/?\";:{}|[\\]+<>\\s-])+/g\nconst CHARS_WITH_WILDCARD = /([^!@#$%^&(),\\\\/?\";:{}|[\\]+<>\\s-])+/g\nconst EDGE_CHARS = /(\\b\\.+|\\.+\\b)/g\nconst MAX_TERM_LENGTH = 1024\n\nexport type Token = string\n\nexport type Pattern = (tokens: Token[]) => boolean\n\nexport function matchText(tokens: Token[], patterns: Pattern[]): boolean {\n  if (tokens.length === 0 || patterns.length === 0) {\n    return false\n  }\n\n  return patterns.every((pattern) => pattern(tokens))\n}\n\nexport function matchTokenize(text: string): Token[] {\n  return text.replace(EDGE_CHARS, '').match(CHARS) || []\n}\n\nexport function matchAnalyzePattern(text: string): Pattern[] {\n  const termsRe = matchPatternRegex(text)\n  return termsRe.map((re) => (tokens: Token[]) => tokens.some((token) => re.test(token)))\n}\n\nexport function matchPatternRegex(text: string): RegExp[] {\n  const terms = text.replace(EDGE_CHARS, '').match(CHARS_WITH_WILDCARD) || []\n  return terms.map(\n    (term) => new RegExp(`^${term.slice(0, MAX_TERM_LENGTH).replace(/\\*/g, '.*')}$`, 'i')\n  )\n}\n\nexport async function gatherText(value: Value, cb: (str: string) => void): Promise<boolean> {\n  if (value.type === 'string') {\n    cb(value.data)\n    return true\n  }\n\n  if (value.isArray()) {\n    let success = true\n    for await (const part of value) {\n      if (part.type === 'string') {\n        cb(part.data)\n      } else {\n        success = false\n      }\n    }\n    return success\n  }\n\n  return false\n}\n", "import {getType, GroqType} from '../values'\n\nconst TYPE_ORDER: {[key in GroqType]?: number} = {\n  datetime: 1,\n  number: 2,\n  string: 3,\n  boolean: 4,\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function partialCompare(a: any, b: any): null | number {\n  const aType = getType(a)\n  const bType = getType(b)\n\n  if (aType !== bType) {\n    return null\n  }\n\n  switch (aType) {\n    case 'number':\n    case 'boolean':\n      return a - b\n    case 'string':\n      if (a < b) return -1\n      if (a > b) return 1\n      return 0\n    case 'datetime':\n      return a.compareTo(b)\n    default:\n      return null\n  }\n}\n\n// eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\nexport function totalCompare(a: any, b: any): number {\n  const aType = getType(a)\n  const bType = getType(b)\n\n  const aTypeOrder = TYPE_ORDER[aType] || 100\n  const bTypeOrder = TYPE_ORDER[bType] || 100\n\n  if (aTypeOrder !== bTypeOrder) {\n    return aTypeOrder - bTypeOrder\n  }\n\n  let result = partialCompare(a, b)\n  if (result === null) {\n    result = 0\n  }\n  return result\n}\n", "import {OpCall} from '../nodeTypes'\nimport {\n  FALSE_VALUE,\n  fromDateTime,\n  fromJS,\n  fromNumber,\n  fromString,\n  NULL_VALUE,\n  StreamValue,\n  TRUE_VALUE,\n  Value,\n} from '../values'\nimport {isEqual} from './equality'\nimport {gatherText, matchAnalyzePattern, matchText, matchTokenize, Pattern, Token} from './matching'\nimport {partialCompare} from './ordering'\n\ntype GroqOperatorFn = (left: Value, right: Value) => Value | PromiseLike<Value>\n\nexport const operators: {[key in OpCall]: GroqOperatorFn} = {\n  '==': function eq(left, right) {\n    return isEqual(left, right) ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '!=': function neq(left, right) {\n    return isEqual(left, right) ? FALSE_VALUE : TRUE_VALUE\n  },\n\n  '>': function gt(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result > 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '>=': function gte(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result >= 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '<': function lt(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result < 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '<=': function lte(left, right) {\n    if (left.type === 'stream' || right.type === 'stream') return NULL_VALUE\n    const result = partialCompare(left.data, right.data)\n\n    if (result === null) {\n      return NULL_VALUE\n    }\n    return result <= 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  // eslint-disable-next-line func-name-matching\n  in: async function inop(left, right) {\n    if (right.type === 'path') {\n      if (left.type !== 'string') {\n        return NULL_VALUE\n      }\n\n      return right.data.matches(left.data) ? TRUE_VALUE : FALSE_VALUE\n    }\n\n    if (right.isArray()) {\n      for await (const b of right) {\n        if (isEqual(left, b)) {\n          return TRUE_VALUE\n        }\n      }\n\n      return FALSE_VALUE\n    }\n\n    return NULL_VALUE\n  },\n\n  match: async function match(left, right) {\n    let tokens: Token[] = []\n    let patterns: Pattern[] = []\n\n    await gatherText(left, (part) => {\n      tokens = tokens.concat(matchTokenize(part))\n    })\n\n    const didSucceed = await gatherText(right, (part) => {\n      patterns = patterns.concat(matchAnalyzePattern(part))\n    })\n    if (!didSucceed) {\n      return FALSE_VALUE\n    }\n\n    const matched = matchText(tokens, patterns)\n\n    return matched ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  '+': function plus(left, right) {\n    if (left.type === 'datetime' && right.type === 'number') {\n      return fromDateTime(left.data.add(right.data))\n    }\n\n    if (left.type === 'number' && right.type === 'number') {\n      return fromNumber(left.data + right.data)\n    }\n\n    if (left.type === 'string' && right.type === 'string') {\n      return fromString(left.data + right.data)\n    }\n\n    if (left.type === 'object' && right.type === 'object') {\n      return fromJS({...left.data, ...right.data})\n    }\n\n    if (left.type === 'array' && right.type === 'array') {\n      return fromJS(left.data.concat(right.data))\n    }\n\n    if (left.isArray() && right.isArray()) {\n      return new StreamValue(async function* () {\n        for await (const val of left) {\n          yield val\n        }\n\n        for await (const val of right) {\n          yield val\n        }\n      })\n    }\n\n    return NULL_VALUE\n  },\n\n  '-': function minus(left, right) {\n    if (left.type === 'datetime' && right.type === 'number') {\n      return fromDateTime(left.data.add(-right.data))\n    }\n\n    if (left.type === 'datetime' && right.type === 'datetime') {\n      return fromNumber(left.data.difference(right.data))\n    }\n\n    if (left.type === 'number' && right.type === 'number') {\n      return fromNumber(left.data - right.data)\n    }\n\n    return NULL_VALUE\n  },\n\n  '*': numericOperator((a, b) => a * b),\n  '/': numericOperator((a, b) => a / b),\n  '%': numericOperator((a, b) => a % b),\n  '**': numericOperator((a, b) => Math.pow(a, b)),\n}\n\nfunction numericOperator(impl: (a: number, b: number) => number): GroqOperatorFn {\n  return function (left, right) {\n    if (left.type === 'number' && right.type === 'number') {\n      const result = impl(left.data, right.data)\n      return fromNumber(result)\n    }\n\n    return NULL_VALUE\n  }\n}\n", "import {Value} from '../values'\nimport {Context} from './types'\n\nexport class Scope {\n  public params: Record<string, unknown>\n  public source: Value\n  public value: Value\n  public parent: Scope | null\n  public context: Context\n  public isHidden = false\n\n  // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n  constructor(\n    params: Record<string, unknown>,\n    source: Value,\n    value: Value,\n    context: Context,\n    parent: Scope | null\n  ) {\n    this.params = params\n    this.source = source\n    this.value = value\n    this.context = context\n    this.parent = parent\n  }\n\n  createNested(value: Value): Scope {\n    if (this.isHidden) {\n      return new Scope(this.params, this.source, value, this.context, this.parent)\n    }\n    return new Scope(this.params, this.source, value, this.context, this)\n  }\n\n  createHidden(value: Value): Scope {\n    const result = this.createNested(value)\n    result.isHidden = true\n    return result\n  }\n}\n", "import {ExprNode, FuncCallNode, PipeFuncCallNode} from '../nodeTypes'\nimport {\n  FALSE_VALUE,\n  fromJS,\n  fromNumber,\n  NULL_VALUE,\n  StreamValue,\n  TRUE_VALUE,\n  Value,\n} from '../values'\nimport {operators} from './operators'\nimport {partialCompare} from './ordering'\nimport {Scope} from './scope'\nimport {EvaluateOptions, Executor} from './types'\n\nexport function evaluate(\n  node: ExprNode,\n  scope: Scope,\n  execute: Executor = evaluate\n): Value | PromiseLike<Value> {\n  const func = EXECUTORS[node.type]\n  return func(node as any, scope, execute)\n}\n\ntype NarrowNode<T, N> = T extends {type: N} ? T : never\n\ntype ExecutorMap = {\n  [key in ExprNode['type']]: (\n    node: NarrowNode<ExprNode, key>,\n    scope: Scope,\n    exec: Executor\n  ) => Value | PromiseLike<Value>\n}\n\n/**\n * Applies the function to a value, but tries to avoid creating unnecessary promises.\n */\nfunction promiselessApply(\n  value: Value | PromiseLike<Value>,\n  cb: (val: Value) => Value\n): Value | PromiseLike<Value> {\n  if ('then' in value) {\n    return value.then(cb)\n  }\n\n  return cb(value)\n}\n\nconst EXECUTORS: ExecutorMap = {\n  This(_, scope) {\n    return scope.value\n  },\n\n  Selector() {\n    // These should be evaluated separely using a different evaluator.\n    // At the mooment we haven't implemented this.\n    throw new Error('Selectors can not be evaluated')\n  },\n\n  Everything(_, scope) {\n    return scope.source\n  },\n\n  Parameter({name}, scope) {\n    return fromJS(scope.params[name])\n  },\n\n  Context({key}, scope) {\n    if (key === 'before' || key === 'after') {\n      const value = scope.context[key]\n      return value || NULL_VALUE\n    }\n    throw new Error(`unknown context key: ${key}`)\n  },\n\n  Parent({n}, scope) {\n    let current = scope\n    for (let i = 0; i < n; i++) {\n      if (!current.parent) {\n        return NULL_VALUE\n      }\n\n      current = current.parent\n    }\n    return current.value\n  },\n\n  OpCall({op, left, right}, scope, execute) {\n    const func = operators[op]\n    if (!func) {\n      throw new Error(`Unknown operator: ${op}`)\n    }\n    const leftValue = execute(left, scope)\n    const rightValue = execute(right, scope)\n\n    // Avoid uneccesary promises\n    // This is required for constant evaluation to work correctly.\n    if ('then' in leftValue || 'then' in rightValue) {\n      return (async () => func(await leftValue, await rightValue))()\n    }\n\n    return func(leftValue, rightValue)\n  },\n\n  async Select({alternatives, fallback}, scope, execute) {\n    for (const alt of alternatives) {\n      const altCond = await execute(alt.condition, scope)\n      if (altCond.type === 'boolean' && altCond.data === true) {\n        return execute(alt.value, scope)\n      }\n    }\n\n    if (fallback) {\n      return execute(fallback, scope)\n    }\n\n    return NULL_VALUE\n  },\n\n  async InRange({base, left, right, isInclusive}, scope, execute) {\n    const value = await execute(base, scope)\n    const leftValue = await execute(left, scope)\n    const rightValue = await execute(right, scope)\n\n    const leftCmp = partialCompare(await value.get(), await leftValue.get())\n    if (leftCmp === null) {\n      return NULL_VALUE\n    }\n    const rightCmp = partialCompare(await value.get(), await rightValue.get())\n    if (rightCmp === null) {\n      return NULL_VALUE\n    }\n\n    if (isInclusive) {\n      return leftCmp >= 0 && rightCmp <= 0 ? TRUE_VALUE : FALSE_VALUE\n    }\n\n    return leftCmp >= 0 && rightCmp < 0 ? TRUE_VALUE : FALSE_VALUE\n  },\n\n  async Filter({base, expr}, scope, execute) {\n    const baseValue = await execute(base, scope)\n    if (!baseValue.isArray()) {\n      return NULL_VALUE\n    }\n    return new StreamValue(async function* () {\n      for await (const elem of baseValue) {\n        const newScope = scope.createNested(elem)\n        const exprValue = await execute(expr, newScope)\n        if (exprValue.type === 'boolean' && exprValue.data === true) {\n          yield elem\n        }\n      }\n    })\n  },\n\n  async Projection({base, expr}, scope, execute) {\n    const baseValue = await execute(base, scope)\n    if (baseValue.type !== 'object') {\n      return NULL_VALUE\n    }\n\n    const newScope = scope.createNested(baseValue)\n    return execute(expr, newScope)\n  },\n\n  FuncCall({func, args}: FuncCallNode, scope: Scope, execute) {\n    return func(args, scope, execute)\n  },\n\n  async PipeFuncCall({func, base, args}: PipeFuncCallNode, scope: Scope, execute) {\n    const baseValue = await execute(base, scope)\n    return func(baseValue, args, scope, execute)\n  },\n\n  async AccessAttribute({base, name}, scope, execute) {\n    let value = scope.value\n    if (base) {\n      value = await execute(base, scope)\n    }\n    if (value.type === 'object') {\n      if (value.data.hasOwnProperty(name)) {\n        return fromJS(value.data[name])\n      }\n    }\n\n    return NULL_VALUE\n  },\n\n  async AccessElement({base, index}, scope, execute) {\n    const baseValue = await execute(base, scope)\n    if (!baseValue.isArray()) {\n      return NULL_VALUE\n    }\n\n    const data = await baseValue.get()\n    const finalIndex = index < 0 ? index + data.length : index\n    return fromJS(data[finalIndex])\n  },\n\n  async Slice({base, left, right, isInclusive}, scope, execute) {\n    const baseValue = await execute(base, scope)\n\n    if (!baseValue.isArray()) {\n      return NULL_VALUE\n    }\n\n    // OPT: Here we can optimize when either indices are >= 0\n    const array = (await baseValue.get()) as any[]\n\n    let leftIdx = left\n    let rightIdx = right\n\n    // Handle negative index\n    if (leftIdx < 0) {\n      leftIdx = array.length + leftIdx\n    }\n    if (rightIdx < 0) {\n      rightIdx = array.length + rightIdx\n    }\n\n    // Convert from inclusive to exclusive index\n    if (isInclusive) {\n      rightIdx++\n    }\n\n    if (leftIdx < 0) {\n      leftIdx = 0\n    }\n    if (rightIdx < 0) {\n      rightIdx = 0\n    }\n\n    // Note: At this point the indices might point out-of-bound, but\n    // .slice handles this correctly.\n\n    return fromJS(array.slice(leftIdx, rightIdx))\n  },\n\n  async Deref({base}, scope, execute) {\n    const value = await execute(base, scope)\n\n    if (!scope.source.isArray()) {\n      return NULL_VALUE\n    }\n\n    if (value.type !== 'object') {\n      return NULL_VALUE\n    }\n\n    const id = value.data._ref\n    if (typeof id !== 'string') {\n      return NULL_VALUE\n    }\n\n    for await (const doc of scope.source) {\n      if (doc.type === 'object' && id === doc.data._id) {\n        return doc\n      }\n    }\n\n    return NULL_VALUE\n  },\n\n  Value({value}) {\n    return fromJS(value)\n  },\n\n  Group({base}, scope, execute) {\n    return execute(base, scope)\n  },\n\n  async Object({attributes}, scope, execute) {\n    const result: {[key: string]: any} = {}\n    for (const attr of attributes) {\n      const attrType = attr.type\n      switch (attr.type) {\n        case 'ObjectAttributeValue': {\n          const value = await execute(attr.value, scope)\n          result[attr.name] = await value.get()\n          break\n        }\n\n        case 'ObjectConditionalSplat': {\n          const cond = await execute(attr.condition, scope)\n          if (cond.type !== 'boolean' || cond.data === false) {\n            continue\n          }\n\n          const value = await execute(attr.value, scope)\n          if (value.type === 'object') {\n            Object.assign(result, value.data)\n          }\n          break\n        }\n\n        case 'ObjectSplat': {\n          const value = await execute(attr.value, scope)\n          if (value.type === 'object') {\n            Object.assign(result, value.data)\n          }\n          break\n        }\n\n        default:\n          throw new Error(`Unknown node type: ${attrType}`)\n      }\n    }\n    return fromJS(result)\n  },\n\n  Array({elements}, scope, execute) {\n    return new StreamValue(async function* () {\n      for (const element of elements) {\n        const value = await execute(element.value, scope)\n        if (element.isSplat) {\n          if (value.isArray()) {\n            for await (const v of value) {\n              yield v\n            }\n          }\n        } else {\n          yield value\n        }\n      }\n    })\n  },\n\n  Tuple() {\n    throw new Error('tuples can not be evaluated')\n  },\n\n  async Or({left, right}, scope, execute) {\n    const leftValue = await execute(left, scope)\n    const rightValue = await execute(right, scope)\n\n    if (leftValue.type === 'boolean') {\n      if (leftValue.data === true) {\n        return TRUE_VALUE\n      }\n    }\n\n    if (rightValue.type === 'boolean') {\n      if (rightValue.data === true) {\n        return TRUE_VALUE\n      }\n    }\n\n    if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n      return NULL_VALUE\n    }\n\n    return FALSE_VALUE\n  },\n\n  async And({left, right}, scope, execute) {\n    const leftValue = await execute(left, scope)\n    const rightValue = await execute(right, scope)\n\n    if (leftValue.type === 'boolean') {\n      if (leftValue.data === false) {\n        return FALSE_VALUE\n      }\n    }\n\n    if (rightValue.type === 'boolean') {\n      if (rightValue.data === false) {\n        return FALSE_VALUE\n      }\n    }\n\n    if (leftValue.type !== 'boolean' || rightValue.type !== 'boolean') {\n      return NULL_VALUE\n    }\n\n    return TRUE_VALUE\n  },\n\n  async Not({base}, scope, execute) {\n    const value = await execute(base, scope)\n    if (value.type !== 'boolean') {\n      return NULL_VALUE\n    }\n    return value.data ? FALSE_VALUE : TRUE_VALUE\n  },\n\n  Neg({base}, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => {\n      if (value.type !== 'number') {\n        return NULL_VALUE\n      }\n      return fromNumber(-value.data)\n    })\n  },\n\n  Pos({base}, scope, execute) {\n    return promiselessApply(execute(base, scope), (value) => {\n      if (value.type !== 'number') {\n        return NULL_VALUE\n      }\n      return fromNumber(value.data)\n    })\n  },\n\n  Asc() {\n    return NULL_VALUE\n  },\n\n  Desc() {\n    return NULL_VALUE\n  },\n\n  async ArrayCoerce({base}, scope, execute) {\n    const value = await execute(base, scope)\n    return value.isArray() ? value : NULL_VALUE\n  },\n\n  async Map({base, expr}, scope, execute) {\n    const value = await execute(base, scope)\n    if (!value.isArray()) {\n      return NULL_VALUE\n    }\n\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem)\n        yield await execute(expr, newScope)\n      }\n    })\n  },\n\n  async FlatMap({base, expr}, scope, execute) {\n    const value = await execute(base, scope)\n    if (!value.isArray()) {\n      return NULL_VALUE\n    }\n\n    return new StreamValue(async function* () {\n      for await (const elem of value) {\n        const newScope = scope.createHidden(elem)\n        const innerValue = await execute(expr, newScope)\n        if (innerValue.isArray()) {\n          for await (const inner of innerValue) {\n            yield inner\n          }\n        } else {\n          yield innerValue\n        }\n      }\n    })\n  },\n}\n\n/**\n * Evaluates a query.\n */\nexport function evaluateQuery(\n  tree: ExprNode,\n  options: EvaluateOptions = {}\n): Value | PromiseLike<Value> {\n  const root = fromJS(options.root)\n  const dataset = fromJS(options.dataset)\n  const params: {[key: string]: any} = {...options.params}\n\n  const scope = new Scope(\n    params,\n    dataset,\n    root,\n    {\n      timestamp: options.timestamp || new Date(),\n      identity: options.identity === undefined ? 'me' : options.identity,\n      sanity: options.sanity,\n      after: options.after ? fromJS(options.after) : null,\n      before: options.before ? fromJS(options.before) : null,\n    },\n    null\n  )\n  return evaluate(tree, scope)\n}\n", "import {ExprNode} from '../nodeTypes'\nimport {NULL_VALUE, Value} from '../values'\nimport {evaluate} from './evaluate'\nimport {Scope} from './scope'\n\nfunction canConstantEvaluate(node: ExprNode): boolean {\n  switch (node.type) {\n    case 'Group':\n    case 'Value':\n    case 'Parameter':\n      return true\n    case 'Pos':\n    case 'Neg':\n      return canConstantEvaluate(node.base)\n    case 'OpCall':\n      switch (node.op) {\n        case '+':\n        case '-':\n        case '*':\n        case '/':\n        case '%':\n        case '**':\n          return canConstantEvaluate(node.left) && canConstantEvaluate(node.right)\n        default:\n          return false\n      }\n    default:\n      return false\n  }\n}\n\nconst DUMMY_SCOPE = new Scope(\n  {},\n  NULL_VALUE,\n  NULL_VALUE,\n  {timestamp: new Date(0), identity: 'me', before: null, after: null},\n  null\n)\n\nexport function tryConstantEvaluate(node: ExprNode): Value | null {\n  if (!canConstantEvaluate(node)) {\n    return null\n  }\n\n  return constantEvaluate(node)\n}\n\nfunction constantEvaluate(node: ExprNode): Value {\n  const value = evaluate(node, DUMMY_SCOPE, constantEvaluate)\n  if ('then' in value) {\n    throw new Error('BUG: constant evaluate should never return a promise')\n  }\n  return value\n}\n", "import {Value} from '../values'\n\nexport async function portableTextContent(value: Value): Promise<string | null> {\n  if (value.type === 'object') {\n    return blockText(value.data)\n  } else if (value.isArray()) {\n    const texts = await arrayText(value)\n    if (texts.length > 0) {\n      return texts.join('\\n\\n')\n    }\n  }\n\n  return null\n}\n\nasync function arrayText(value: Value, result: string[] = []): Promise<string[]> {\n  for await (const block of value) {\n    if (block.type === 'object') {\n      const text = blockText(block.data)\n      if (text !== null) result.push(text)\n    } else if (block.isArray()) {\n      await arrayText(block, result)\n    }\n  }\n\n  return result\n}\n\nfunction blockText(obj: Record<string, unknown>): string | null {\n  if (typeof obj._type !== 'string') return null\n  const children = obj.children\n  if (!Array.isArray(children)) return null\n\n  let result = ''\n  for (const child of children) {\n    if (\n      child &&\n      typeof child === 'object' &&\n      typeof child._type === 'string' &&\n      child._type === 'span' &&\n      typeof child.text === 'string'\n    ) {\n      result += child.text\n    }\n  }\n  return result\n}\n", "import {ExprNode} from '../nodeTypes'\nimport {gatherText, matchPatternRegex, matchTokenize, Token} from './matching'\nimport {Scope} from './scope'\nimport {Executor} from './types'\n\n// BM25 similarity constants\nconst BM25k = 1.2\n\nexport async function evaluateScore(\n  node: ExprNode,\n  scope: Scope,\n  execute: Executor\n): Promise<number> {\n  if (node.type === 'OpCall' && node.op === 'match') {\n    return evaluateMatchScore(node.left, node.right, scope, execute)\n  }\n\n  if (node.type === 'FuncCall' && node.name === 'boost') {\n    const innerScore = await evaluateScore(node.args[0], scope, execute)\n    const boost = await execute(node.args[1], scope)\n    if (boost.type === 'number' && innerScore > 0) {\n      return innerScore + boost.data\n    }\n\n    return 0\n  }\n\n  switch (node.type) {\n    case 'Or': {\n      const leftScore = await evaluateScore(node.left, scope, execute)\n      const rightScore = await evaluateScore(node.right, scope, execute)\n      return leftScore + rightScore\n    }\n    case 'And': {\n      const leftScore = await evaluateScore(node.left, scope, execute)\n      const rightScore = await evaluateScore(node.right, scope, execute)\n      if (leftScore === 0 || rightScore === 0) return 0\n      return leftScore + rightScore\n    }\n    default: {\n      const res = await execute(node, scope)\n      return res.type === 'boolean' && res.data === true ? 1 : 0\n    }\n  }\n}\n\nasync function evaluateMatchScore(\n  left: ExprNode,\n  right: ExprNode,\n  scope: Scope,\n  execute: Executor\n): Promise<number> {\n  const text = await execute(left, scope)\n  const pattern = await execute(right, scope)\n\n  let tokens: Token[] = []\n  let terms: RegExp[] = []\n\n  await gatherText(text, (part) => {\n    tokens = tokens.concat(matchTokenize(part))\n  })\n\n  const didSucceed = await gatherText(pattern, (part) => {\n    terms = terms.concat(matchPatternRegex(part))\n  })\n\n  if (!didSucceed) {\n    return 0\n  }\n\n  if (tokens.length === 0 || terms.length === 0) {\n    return 0\n  }\n\n  let score = 0\n\n  for (const re of terms) {\n    const freq = tokens.reduce((c, token) => c + (re.test(token) ? 1 : 0), 0)\n    score += (freq * (BM25k + 1)) / (freq + BM25k)\n  }\n\n  return score\n}\n", "import type {ExprNode} from '../nodeTypes'\nimport {\n  DateTime,\n  FALSE_VALUE,\n  fromJS,\n  fromNumber,\n  fromPath,\n  fromString,\n  getType,\n  NULL_VALUE,\n  Path,\n  StreamValue,\n  TRUE_VALUE,\n  Value,\n} from '../values'\nimport {totalCompare} from './ordering'\nimport {portableTextContent} from './pt'\nimport {Scope} from './scope'\nimport {evaluateScore} from './scoring'\nimport {Executor} from './types'\n\nfunction hasReference(value: any, pathSet: Set<string>): boolean {\n  switch (getType(value)) {\n    case 'array':\n      for (const v of value) {\n        if (hasReference(v, pathSet)) {\n          return true\n        }\n      }\n      break\n    case 'object':\n      if (value._ref) {\n        return pathSet.has(value._ref)\n      }\n      for (const v of Object.values(value)) {\n        if (hasReference(v, pathSet)) {\n          return true\n        }\n      }\n      break\n    default:\n  }\n  return false\n}\n\nfunction countUTF8(str: string): number {\n  let count = 0\n  for (let i = 0; i < str.length; i++) {\n    const code = str.charCodeAt(i)\n    if (code >= 0xd800 && code <= 0xdbff) {\n      // High surrogate. Don't count this.\n      // By only counting the low surrogate we will correctly\n      // count the number of UTF-8 code points.\n      continue\n    }\n    count++\n  }\n  return count\n}\n\nexport type GroqFunctionArg = ExprNode\ntype WithOptions<T> = T & {\n  arity?: GroqFunctionArity\n  mode?: 'normal' | 'delta'\n}\n\nexport type GroqFunctionArity = number | ((count: number) => boolean)\n\nexport type GroqFunction = (\n  args: GroqFunctionArg[],\n  scope: Scope,\n  execute: Executor\n) => PromiseLike<Value>\n\nexport type FunctionSet = Record<string, WithOptions<GroqFunction> | undefined>\n\nexport type NamespaceSet = Record<string, FunctionSet | undefined>\n\n// underscored to not collide with environments like jest that give variables named `global` special treatment\nconst _global: FunctionSet = {}\n\n// eslint-disable-next-line require-await\n_global.anywhere = async function anywhere() {\n  throw new Error('not implemented')\n}\n\n_global.anywhere.arity = 1\n\n_global.coalesce = async function coalesce(args, scope, execute) {\n  for (const arg of args) {\n    const value = await execute(arg, scope)\n    if (value.type !== 'null') {\n      return value\n    }\n  }\n  return NULL_VALUE\n}\n\n_global.count = async function count(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n  if (!inner.isArray()) {\n    return NULL_VALUE\n  }\n\n  let num = 0\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  for await (const _ of inner) {\n    num++\n  }\n  return fromNumber(num)\n}\n_global.count.arity = 1\n\n_global.dateTime = async function dateTime(args, scope, execute) {\n  const val = await execute(args[0], scope)\n  if (val.type === 'datetime') {\n    return val\n  }\n  if (val.type !== 'string') {\n    return NULL_VALUE\n  }\n  return DateTime.parseToValue(val.data)\n}\n_global.dateTime.arity = 1\n\n_global.defined = async function defined(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n  return inner.type === 'null' ? FALSE_VALUE : TRUE_VALUE\n}\n_global.defined.arity = 1\n\n// eslint-disable-next-line require-await\n_global.identity = async function identity(args, scope) {\n  return fromString(scope.context.identity)\n}\n_global.identity.arity = 0\n\n_global.length = async function length(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n\n  if (inner.type === 'string') {\n    return fromNumber(countUTF8(inner.data))\n  }\n\n  if (inner.isArray()) {\n    let num = 0\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    for await (const _ of inner) {\n      num++\n    }\n    return fromNumber(num)\n  }\n\n  return NULL_VALUE\n}\n_global.length.arity = 1\n\n_global.path = async function path(args, scope, execute) {\n  const inner = await execute(args[0], scope)\n  if (inner.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return fromPath(new Path(inner.data))\n}\n_global.path.arity = 1\n\n_global.string = async function string(args, scope, execute) {\n  const value = await execute(args[0], scope)\n  switch (value.type) {\n    case 'number':\n    case 'string':\n    case 'boolean':\n    case 'datetime':\n      return fromString(`${value.data}`)\n    default:\n      return NULL_VALUE\n  }\n}\n_global.string.arity = 1\n\n_global.references = async function references(args, scope, execute) {\n  const pathSet = new Set<string>()\n  for (const arg of args) {\n    const path = await execute(arg, scope)\n    if (path.type === 'string') {\n      pathSet.add(path.data)\n    } else if (path.isArray()) {\n      for await (const elem of path) {\n        if (elem.type === 'string') {\n          pathSet.add(elem.data)\n        }\n      }\n    }\n  }\n\n  if (pathSet.size === 0) {\n    return FALSE_VALUE\n  }\n\n  const scopeValue = await scope.value.get()\n  return hasReference(scopeValue, pathSet) ? TRUE_VALUE : FALSE_VALUE\n}\n_global.references.arity = (c) => c >= 1\n\n_global.round = async function round(args, scope, execute) {\n  const value = await execute(args[0], scope)\n  if (value.type !== 'number') {\n    return NULL_VALUE\n  }\n\n  const num = value.data\n  let prec = 0\n\n  if (args.length === 2) {\n    const precValue = await execute(args[1], scope)\n    if (precValue.type !== 'number' || precValue.data < 0 || !Number.isInteger(precValue.data)) {\n      return NULL_VALUE\n    }\n    prec = precValue.data\n  }\n\n  if (prec === 0) {\n    if (num < 0) {\n      // JavaScript's round() function will always rounds towards positive infinity (-3.5 -> -3).\n      // The behavior we're interested in is to \"round half away from zero\".\n      return fromNumber(-Math.round(-num))\n    }\n    return fromNumber(Math.round(num))\n  }\n  return fromNumber(Number(num.toFixed(prec)))\n}\n_global.round.arity = (count) => count >= 1 && count <= 2\n\n// eslint-disable-next-line require-await\n_global.now = async function now(args, scope) {\n  return fromString(scope.context.timestamp.toISOString())\n}\n_global.now.arity = 0\n\n// eslint-disable-next-line require-await\n_global.boost = async function boost() {\n  // This should be handled by the scoring function.\n  throw new Error('unexpected boost call')\n}\n\n_global.boost.arity = 2\n\nconst string: FunctionSet = {}\n\nstring.lower = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n\n  if (value.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return fromString(value.data.toLowerCase())\n}\nstring.lower.arity = 1\n\nstring.upper = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n\n  if (value.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return fromString(value.data.toUpperCase())\n}\nstring.upper.arity = 1\n\nstring.split = async function (args, scope, execute) {\n  const str = await execute(args[0], scope)\n  if (str.type !== 'string') {\n    return NULL_VALUE\n  }\n  const sep = await execute(args[1], scope)\n  if (sep.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  if (str.data.length === 0) {\n    return fromJS([])\n  }\n  if (sep.data.length === 0) {\n    // This uses a Unicode codepoint splitting algorithm\n    return fromJS(Array.from(str.data))\n  }\n  return fromJS(str.data.split(sep.data))\n}\nstring.split.arity = 2\n\n_global.lower = string.lower\n_global.upper = string.upper\n\nstring.startsWith = async function (args, scope, execute) {\n  const str = await execute(args[0], scope)\n  if (str.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  const prefix = await execute(args[1], scope)\n  if (prefix.type !== 'string') {\n    return NULL_VALUE\n  }\n\n  return str.data.startsWith(prefix.data) ? TRUE_VALUE : FALSE_VALUE\n}\nstring.startsWith.arity = 2\n\nconst array: FunctionSet = {}\n\narray.join = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n  const sep = await execute(args[1], scope)\n  if (sep.type !== 'string') {\n    return NULL_VALUE\n  }\n  let buf = ''\n  let needSep = false\n  for await (const elem of arr) {\n    if (needSep) {\n      buf += sep.data\n    }\n    switch (elem.type) {\n      case 'number':\n      case 'string':\n      case 'boolean':\n      case 'datetime':\n        buf += `${elem.data}`\n        break\n      default:\n        return NULL_VALUE\n    }\n    needSep = true\n  }\n  return fromJS(buf)\n}\narray.join.arity = 2\n\narray.compact = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  return new StreamValue(async function* () {\n    for await (const elem of arr) {\n      if (elem.type !== 'null') {\n        yield elem\n      }\n    }\n  })\n}\narray.compact.arity = 1\n\narray.unique = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n  if (!value.isArray()) {\n    return NULL_VALUE\n  }\n\n  return new StreamValue(async function* () {\n    const added = new Set()\n    for await (const iter of value) {\n      switch (iter.type) {\n        case 'number':\n        case 'string':\n        case 'boolean':\n        case 'datetime':\n          if (!added.has(iter.data)) {\n            added.add(iter.data)\n            yield iter\n          }\n          break\n        default:\n          yield iter\n      }\n    }\n  })\n}\narray.unique.arity = 1\n\nconst pt: FunctionSet = {}\npt.text = async function (args, scope, execute) {\n  const value = await execute(args[0], scope)\n  const text = await portableTextContent(value)\n\n  if (text === null) {\n    return NULL_VALUE\n  }\n\n  return fromString(text)\n}\n\npt.text.arity = 1\n\nconst sanity: FunctionSet = {}\n// eslint-disable-next-line require-await\nsanity.projectId = async function (args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.projectId)\n  }\n\n  return NULL_VALUE\n}\n// eslint-disable-next-line require-await\nsanity.dataset = async function (args, scope) {\n  if (scope.context.sanity) {\n    return fromString(scope.context.sanity.dataset)\n  }\n\n  return NULL_VALUE\n}\n\nexport type GroqPipeFunction = (\n  base: Value,\n  args: ExprNode[],\n  scope: Scope,\n  execute: Executor\n) => PromiseLike<Value>\n\nexport const pipeFunctions: {[key: string]: WithOptions<GroqPipeFunction>} = {}\n\npipeFunctions.order = async function order(base, args, scope, execute) {\n  // eslint-disable-next-line max-len\n  // This is a workaround for https://github.com/rpetrich/babel-plugin-transform-async-to-promises/issues/59\n  await true\n\n  if (!base.isArray()) {\n    return NULL_VALUE\n  }\n\n  const mappers = []\n  const directions: string[] = []\n  let n = 0\n\n  for (let mapper of args) {\n    let direction = 'asc'\n\n    if (mapper.type === 'Desc') {\n      direction = 'desc'\n      mapper = mapper.base\n    } else if (mapper.type === 'Asc') {\n      mapper = mapper.base\n    }\n\n    mappers.push(mapper)\n    directions.push(direction)\n    n++\n  }\n\n  const aux = []\n  let idx = 0\n\n  for await (const value of base) {\n    const newScope = scope.createNested(value)\n    const tuple = [await value.get(), idx]\n    for (let i = 0; i < n; i++) {\n      const result = await execute(mappers[i], newScope)\n      tuple.push(await result.get())\n    }\n    aux.push(tuple)\n    idx++\n  }\n\n  aux.sort((aTuple, bTuple) => {\n    for (let i = 0; i < n; i++) {\n      let c = totalCompare(aTuple[i + 2], bTuple[i + 2])\n      if (directions[i] === 'desc') {\n        c = -c\n      }\n      if (c !== 0) {\n        return c\n      }\n    }\n    // Fallback to sorting on the original index for stable sorting.\n    return aTuple[1] - bTuple[1]\n  })\n\n  return fromJS(aux.map((v) => v[0]))\n}\npipeFunctions.order.arity = (count) => count >= 1\n\n// eslint-disable-next-line require-await\npipeFunctions.score = async function score(base, args, scope, execute) {\n  if (!base.isArray()) return NULL_VALUE\n\n  // Anything that isn't an object should be sorted first.\n  const unknown: Array<any> = []\n  const scored: Array<ObjectWithScore> = []\n\n  for await (const value of base) {\n    if (value.type !== 'object') {\n      unknown.push(await value.get())\n      continue\n    }\n\n    const newScope = scope.createNested(value)\n    let valueScore = typeof value.data._score === 'number' ? value.data._score : 0\n\n    for (const arg of args) {\n      valueScore += await evaluateScore(arg, newScope, execute)\n    }\n\n    const newObject = Object.assign({}, value.data, {_score: valueScore})\n    scored.push(newObject)\n  }\n\n  scored.sort((a, b) => b._score - a._score)\n  return fromJS(scored)\n}\n\npipeFunctions.score.arity = (count) => count >= 1\n\ntype ObjectWithScore = Record<string, unknown> & {_score: number}\n\nconst delta: FunctionSet = {}\n// eslint-disable-next-line require-await\ndelta.operation = async function (args, scope) {\n  const hasBefore = scope.context.before !== null\n  const hasAfter = scope.context.after !== null\n\n  if (hasBefore && hasAfter) {\n    return fromString('update')\n  }\n\n  if (hasAfter) {\n    return fromString('create')\n  }\n\n  if (hasBefore) {\n    return fromString('delete')\n  }\n\n  return NULL_VALUE\n}\n\ndelta.changedAny = () => {\n  throw new Error('not implemented')\n}\ndelta.changedAny.arity = 1\ndelta.changedAny.mode = 'delta'\n\ndelta.changedOnly = () => {\n  throw new Error('not implemented')\n}\ndelta.changedOnly.arity = 1\ndelta.changedOnly.mode = 'delta'\n\nconst diff: FunctionSet = {}\ndiff.changedAny = () => {\n  throw new Error('not implemented')\n}\ndiff.changedAny.arity = 3\n\ndiff.changedOnly = () => {\n  throw new Error('not implemented')\n}\ndiff.changedOnly.arity = 3\n\nconst math: FunctionSet = {}\nmath.min = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n: number | undefined\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    if (n === undefined || elem.data < n) {\n      n = elem.data\n    }\n  }\n  return fromJS(n)\n}\nmath.min.arity = 1\n\nmath.max = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n: number | undefined\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    if (n === undefined || elem.data > n) {\n      n = elem.data\n    }\n  }\n  return fromJS(n)\n}\nmath.max.arity = 1\n\nmath.sum = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n = 0\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    n += elem.data\n  }\n  return fromJS(n)\n}\nmath.sum.arity = 1\n\nmath.avg = async function (args, scope, execute) {\n  const arr = await execute(args[0], scope)\n  if (!arr.isArray()) {\n    return NULL_VALUE\n  }\n\n  let n = 0\n  let c = 0\n  for await (const elem of arr) {\n    if (elem.type === 'null') continue\n    if (elem.type !== 'number') {\n      return NULL_VALUE\n    }\n    n += elem.data\n    c++\n  }\n  if (c === 0) {\n    return NULL_VALUE\n  }\n  return fromJS(n / c)\n}\nmath.avg.arity = 1\n\nexport const namespaces: NamespaceSet = {\n  global: _global,\n  string,\n  array,\n  pt,\n  delta,\n  diff,\n  sanity,\n  math,\n}\n", "import {ParseOptions} from './types'\n\nexport type MarkName =\n  | 'add'\n  | 'and'\n  | 'arr_expr'\n  | 'array_end'\n  | 'array_splat'\n  | 'array'\n  | 'asc'\n  | 'attr_ident'\n  | 'comp'\n  | 'dblparent'\n  | 'deref_field'\n  | 'deref'\n  | 'desc'\n  | 'div'\n  | 'exc_range'\n  | 'filter'\n  | 'float'\n  | 'func_args_end'\n  | 'func_call'\n  | 'ident'\n  | 'inc_range'\n  | 'integer'\n  | 'mod'\n  | 'mul'\n  | 'neg'\n  | 'not'\n  | 'object_end'\n  | 'object_expr'\n  | 'object_pair'\n  | 'object_splat_this'\n  | 'object_splat'\n  | 'object'\n  | 'or'\n  | 'pair'\n  | 'param'\n  | 'paren'\n  | 'parent'\n  | 'pipecall'\n  | 'pos'\n  | 'pow'\n  | 'project'\n  | 'sci'\n  | 'star'\n  | 'str_begin'\n  | 'sub'\n  | 'this'\n\nexport interface Mark {\n  name: string\n  position: number\n}\n\nexport type MarkVisitor<T> = Record<string, MarkVisitorFunc<T>>\nexport type MarkVisitorFunc<T> = (p: MarkProcessor, mark: Mark) => T\n\nexport class MarkProcessor {\n  private string: string\n  private marks: Mark[]\n  private index: number\n  parseOptions: ParseOptions\n  allowBoost = false\n\n  constructor(string: string, marks: Mark[], parseOptions: ParseOptions) {\n    this.string = string\n    this.marks = marks\n    this.index = 0\n    this.parseOptions = parseOptions\n  }\n\n  hasMark(pos = 0): boolean {\n    return this.index + pos < this.marks.length\n  }\n\n  getMark(pos = 0): Mark {\n    return this.marks[this.index + pos]\n  }\n\n  shift(): void {\n    this.index += 1\n  }\n\n  process<T>(visitor: MarkVisitor<T>): T {\n    const mark = this.marks[this.index]\n    this.shift()\n    const func = visitor[mark.name]\n    if (!func) {\n      throw new Error(`Unknown handler: ${mark.name}`)\n    }\n    return func.call(visitor, this, mark)\n  }\n\n  processString(): string {\n    this.shift()\n    return this.processStringEnd()\n  }\n\n  processStringEnd(): string {\n    const prev = this.marks[this.index - 1]\n    const curr = this.marks[this.index]\n    this.shift()\n    return this.string.slice(prev.position, curr.position)\n  }\n\n  slice(len: number): string {\n    const pos = this.marks[this.index].position\n    return this.string.slice(pos, pos + len)\n  }\n}\n", "'use strict'\n\nconst WS = /^([\\t\\n\\v\\f\\r \\u0085\\u00A0]|(\\/\\/[^\\n]*\\n))+/\nconst NUM = /^\\d+/\nconst IDENT = /^[a-zA-Z_][a-zA-Z_0-9]*/\n\n// Precedence levels for binary operators:\nconst PREC_PAIR = 1\nconst PREC_OR = 2\nconst PREC_AND = 3\nconst PREC_COMP = 4\nconst PREC_ORDER = 4\nconst PREC_ADD = 6\nconst PREC_SUB = 6\nconst PREC_MUL = 7\nconst PREC_DIV = 7\nconst PREC_MOD = 7\nconst PREC_POW = 8\n\n// Precedence levels for prefix operators:\nconst PREC_POS = 10\nconst PREC_NOT = 10\nconst PREC_NEG = 8\n\nfunction parse(str) {\n  let pos = 0\n  pos = skipWS(str, pos)\n  let result = parseExpr(str, pos, 0)\n  if (result.type === 'error') return result\n  pos = skipWS(str, result.position)\n  if (pos !== str.length) {\n    if (result.failPosition) {\n      pos = result.failPosition - 1\n    }\n    return {type: 'error', position: pos}\n  }\n  delete result.position\n  delete result.failPosition\n  return result\n}\n\nfunction parseExpr(str, pos, level) {\n  // In this function we parse precedence \"manually\" by having two variables:\n  //\n  // `level` is the minimum precedence level we want to parse at. If this is\n  // e.g. 7 then this function will not parse `3 + 4` (since addition is at 6),\n  // but instead just return `1` and leave ` + 5` remaining. We use this so that\n  // while handling the RHS of the multiplication in `1 + 2 * 3 + 4` we only parse `3`.\n  //\n  // `lhsLevel` is the precedence level of the currently parsed expression on\n  // the left-hand side. This is mainly used to handle non-associcativeness.\n\n  // This means that you'll see code like:\n  // - `if (level > PREC_XXX) break`: Operator is at this precedence level.\n  // - `if (lhsLevel < PREC_XXX) break`: Operator is left-associative.\n  // - `if (lhsLevel <= PREC_XXX) break`: Operator is right/non-associative.\n  // - `parseExpr(str, pos, PREC_XXX + 1)`: Operator is left/non-assoicate.\n  // - `parseExpr(str, pos, PREC_XXX)`: Operator is right-assoicate.\n\n  let startPos = pos\n  let token = str[pos]\n  let marks\n\n  switch (token) {\n    case '+': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_POS)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'pos', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '-': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NEG)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'neg', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '(': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), 0)\n      if (rhs.type === 'error') return rhs\n      pos = skipWS(str, rhs.position)\n      switch (str[pos]) {\n        case ',': {\n          // Tuples\n          marks = [{name: 'tuple', position: startPos}].concat(rhs.marks)\n          pos = skipWS(str, pos + 1)\n          while (true) {\n            rhs = parseExpr(str, pos, 0)\n            if (rhs.type === 'error') return rhs\n            pos = skipWS(str, rhs.position)\n            if (str[pos] !== ',') break\n            pos = skipWS(str, pos + 1)\n          }\n          if (str[pos] !== ')') return {type: 'error', position: pos}\n          pos++\n          marks.push({name: 'tuple_end', position: pos})\n          break\n        }\n        case ')': {\n          pos++\n          marks = [{name: 'group', position: startPos}].concat(rhs.marks)\n          break\n        }\n        default:\n          return {type: 'error', position: pos}\n      }\n      break\n    }\n    case '!': {\n      let rhs = parseExpr(str, skipWS(str, pos + 1), PREC_NOT)\n      if (rhs.type === 'error') return rhs\n      marks = [{name: 'not', position: startPos}].concat(rhs.marks)\n      pos = rhs.position\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos)\n      if (result.type === 'error') return result\n      marks = result.marks\n      pos = result.position\n      break\n    }\n    case '[':\n      marks = [{name: 'array', position: pos}]\n      pos = skipWS(str, pos + 1)\n\n      if (str[pos] !== ']') {\n        while (true) {\n          if (str.slice(pos, pos + 3) === '...') {\n            marks.push({name: 'array_splat', position: pos})\n            pos = skipWS(str, pos + 3)\n          }\n\n          let res = parseExpr(str, pos, 0)\n          if (res.type === 'error') return res\n          marks = marks.concat(res.marks)\n          pos = res.position\n          pos = skipWS(str, pos)\n          if (str[pos] !== ',') break\n          pos = skipWS(str, pos + 1)\n          if (str[pos] === ']') break\n        }\n      }\n\n      if (str[pos] === ']') {\n        pos++\n        marks.push({name: 'array_end', position: pos})\n      } else {\n        return {type: 'error', position: pos}\n      }\n\n      break\n    case \"'\":\n    case '\"': {\n      let result = parseString(str, pos)\n      if (result.type === 'error') return result\n      marks = result.marks\n      pos = result.position\n      break\n    }\n    case '^': {\n      pos++\n      marks = []\n      while (str[pos] === '.' && str[pos + 1] === '^') {\n        marks.push({name: 'dblparent', position: startPos})\n        pos += 2\n      }\n      marks.push({name: 'parent', position: startPos})\n      break\n    }\n    case '@':\n      marks = [{name: 'this', position: startPos}]\n      pos++\n      break\n    case '*':\n      marks = [{name: 'everything', position: startPos}]\n      pos++\n      break\n    case '$': {\n      let identLen = parseRegex(str, pos + 1, IDENT)\n      if (identLen) {\n        pos += 1 + identLen\n        marks = [\n          {name: 'param', position: startPos},\n          {name: 'ident', position: startPos + 1},\n          {name: 'ident_end', position: pos},\n        ]\n      }\n      break\n    }\n    default: {\n      let numLen = parseRegex(str, pos, NUM)\n      if (numLen) {\n        pos += numLen\n        let name = 'integer'\n\n        if (str[pos] === '.') {\n          let fracLen = parseRegex(str, pos + 1, NUM)\n          if (fracLen) {\n            name = 'float'\n            pos += 1 + fracLen\n          }\n        }\n\n        if (str[pos] === 'e' || str[pos] === 'E') {\n          name = 'sci'\n          pos++\n          if (str[pos] === '+' || str[pos] === '-') {\n            pos++\n          }\n          let expLen = parseRegex(str, pos, NUM)\n          if (!expLen) return {type: 'error', position: pos}\n          pos += expLen\n        }\n\n        marks = [\n          {name, position: startPos},\n          {name: name + '_end', position: pos},\n        ]\n\n        break\n      }\n\n      let identLen = parseRegex(str, pos, IDENT)\n      if (identLen) {\n        pos += identLen\n        switch (str[pos]) {\n          case ':':\n          case '(': {\n            let result = parseFuncCall(str, startPos, pos)\n            if (result.type === 'error') return result\n            marks = result.marks\n            pos = result.position\n            break\n          }\n          default: {\n            marks = [\n              {name: 'this_attr', position: startPos},\n              {name: 'ident', position: startPos},\n              {name: 'ident_end', position: pos},\n            ]\n          }\n        }\n\n        break\n      }\n    }\n  }\n\n  if (!marks) {\n    return {type: 'error', position: pos}\n  }\n\n  let lhsLevel = 12\n  let trav\n\n  loop: while (true) {\n    let innerPos = skipWS(str, pos)\n    if (innerPos === str.length) {\n      pos = innerPos\n      break\n    }\n\n    trav = parseTraversal(str, innerPos)\n    if (trav.type === 'success') {\n      marks.unshift({name: 'traverse', position: startPos})\n      while (trav.type === 'success') {\n        marks = marks.concat(trav.marks)\n        pos = trav.position\n        trav = parseTraversal(str, skipWS(str, pos))\n      }\n      marks.push({name: 'traversal_end', position: pos})\n      continue\n    }\n\n    let token = str[innerPos]\n    switch (token) {\n      case '=': {\n        let nextToken = str[innerPos + 1]\n        switch (nextToken) {\n          case '>': {\n            // =>\n            if (level > PREC_PAIR || lhsLevel <= PREC_PAIR) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_PAIR)\n            if (rhs.type === 'error') return rhs\n            marks = marks.concat(rhs.marks)\n            marks.unshift({name: 'pair', position: startPos})\n            pos = rhs.position\n            lhsLevel = PREC_PAIR\n            break\n          }\n          case '=': {\n            // ==\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 2), 5)\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos})\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n            marks = marks.concat(rhs.marks)\n            pos = rhs.position\n            lhsLevel = PREC_COMP\n            break\n          }\n          default:\n            break loop\n        }\n        break\n      }\n      case '+': {\n        if (level > PREC_ADD || lhsLevel < PREC_ADD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_ADD + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'add', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_ADD\n        break\n      }\n      case '-': {\n        if (level > PREC_SUB || lhsLevel < PREC_SUB) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_SUB + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'sub', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_SUB\n        break\n      }\n      case '*': {\n        if (str[innerPos + 1] === '*') {\n          // **\n          if (level > PREC_POW || lhsLevel <= PREC_POW) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_POW)\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks)\n          marks.unshift({name: 'pow', position: startPos})\n          pos = rhs.position\n          lhsLevel = PREC_POW\n          break\n        }\n\n        // *\n        if (level > PREC_MUL || lhsLevel < PREC_MUL) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MUL + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'mul', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_MUL\n        break\n      }\n      case '/': {\n        if (level > PREC_DIV || lhsLevel < PREC_DIV) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_DIV + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'div', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_DIV\n        break\n      }\n      case '%': {\n        if (level > PREC_MOD || lhsLevel < PREC_MOD) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 1), PREC_MOD + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'mod', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_MOD\n        break\n      }\n      case '<':\n      case '>': {\n        if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n        let nextPos = innerPos + 1\n        if (str[nextPos] === '=') {\n          nextPos++\n        }\n        let rhs = parseExpr(str, skipWS(str, nextPos), PREC_COMP + 1)\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos})\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: nextPos})\n        marks = marks.concat(rhs.marks)\n        pos = rhs.position\n        lhsLevel = PREC_COMP\n        break\n      }\n      case '|': {\n        if (str[innerPos + 1] === '|') {\n          // ||\n          if (level > PREC_OR || lhsLevel < PREC_OR) break loop\n          let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_OR + 1)\n          if (rhs.type === 'error') return rhs\n          marks = marks.concat(rhs.marks)\n          marks.unshift({name: 'or', position: startPos})\n          pos = rhs.position\n          lhsLevel = PREC_OR\n        } else {\n          if (level > 11 || lhsLevel < 11) break loop\n          // pipe call\n          let identPos = skipWS(str, innerPos + 1)\n          let identLen = parseRegex(str, identPos, IDENT)\n          if (!identLen) return {type: 'error', position: identPos}\n          pos = identPos + identLen\n          if (str[pos] === '(' || str[pos] === ':') {\n            let result = parseFuncCall(str, identPos, pos)\n            if (result.type === 'error') return result\n            marks = marks.concat(result.marks)\n            marks.unshift({name: 'pipecall', position: startPos})\n            pos = result.position\n            lhsLevel = 11\n          }\n        }\n        break\n      }\n      case '&': {\n        // &&\n        if (str[innerPos + 1] != '&') break loop\n        if (level > PREC_AND || lhsLevel < PREC_AND) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_AND + 1)\n        if (rhs.type === 'error') return rhs\n        marks = marks.concat(rhs.marks)\n        marks.unshift({name: 'and', position: startPos})\n        pos = rhs.position\n        lhsLevel = PREC_AND\n        break\n      }\n      case '!': {\n        // !=\n        if (str[innerPos + 1] !== '=') break loop\n        if (level > PREC_COMP || lhsLevel < PREC_COMP) break loop\n        let rhs = parseExpr(str, skipWS(str, innerPos + 2), PREC_COMP + 1)\n        if (rhs.type === 'error') return rhs\n        marks.unshift({name: 'comp', position: startPos})\n        marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n        marks = marks.concat(rhs.marks)\n        pos = rhs.position\n        lhsLevel = PREC_COMP\n        break\n      }\n      case 'd': {\n        // asc\n        if (str.slice(innerPos, innerPos + 4) !== 'desc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'desc', position: startPos})\n        pos = innerPos + 4\n        lhsLevel = PREC_ORDER\n        break\n      }\n      case 'a': {\n        // asc\n        if (str.slice(innerPos, innerPos + 3) !== 'asc') break loop\n        if (level > PREC_ORDER || lhsLevel < PREC_ORDER) break loop\n        marks.unshift({name: 'asc', position: startPos})\n        pos = innerPos + 3\n        lhsLevel = PREC_ORDER\n        break\n      }\n      default: {\n        let ident = parseRegexStr(str, innerPos, IDENT)\n        switch (ident) {\n          case 'in': {\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n\n            pos = skipWS(str, innerPos + 2)\n\n            let isGroup = false\n\n            if (str[pos] === '(') {\n              isGroup = true\n              pos = skipWS(str, pos + 1)\n            }\n\n            let rangePos = pos\n            let result = parseExpr(str, pos, PREC_COMP + 1)\n            if (result.type === 'error') return result\n\n            pos = skipWS(str, result.position)\n\n            if (str[pos] === '.' && str[pos + 1] === '.') {\n              // LHS in RANGE\n              let type = 'inc_range'\n              if (str[pos + 2] === '.') {\n                type = 'exc_range'\n                pos = skipWS(str, pos + 3)\n              } else {\n                pos = skipWS(str, pos + 2)\n              }\n\n              let rhs = parseExpr(str, pos, PREC_COMP + 1)\n              if (rhs.type === 'error') return rhs\n              marks.unshift({name: 'in_range', position: startPos})\n              marks = marks.concat({name: type, position: rangePos}, result.marks, rhs.marks)\n              pos = rhs.position\n            } else {\n              // LHS in RHS\n              marks.unshift({name: 'comp', position: startPos})\n              marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 2})\n              marks = marks.concat(result.marks)\n            }\n\n            if (isGroup) {\n              pos = skipWS(str, pos)\n              if (str[pos] !== ')') return {type: 'error', position: pos}\n              pos++\n            }\n\n            lhsLevel = PREC_COMP\n            break\n          }\n          case 'match': {\n            // match operator\n            if (level > PREC_COMP || lhsLevel <= PREC_COMP) break loop\n            let rhs = parseExpr(str, skipWS(str, innerPos + 5), PREC_COMP + 1)\n            if (rhs.type === 'error') return rhs\n            marks.unshift({name: 'comp', position: startPos})\n            marks.push({name: 'op', position: innerPos}, {name: 'op_end', position: innerPos + 5})\n            marks = marks.concat(rhs.marks)\n            pos = rhs.position\n            lhsLevel = 4\n            break\n          }\n          default: {\n            break loop\n          }\n        }\n      }\n    }\n  }\n\n  let failPosition = trav?.type === 'error' && trav.position\n\n  return {type: 'success', marks, position: pos, failPosition}\n}\n\nfunction parseTraversal(str, pos) {\n  let startPos = pos\n  switch (str[pos]) {\n    case '.': {\n      pos = skipWS(str, pos + 1)\n      let identStart = pos\n      let identLen = parseRegex(str, pos, IDENT)\n      if (!identLen) return {type: 'error', position: pos}\n      pos += identLen\n\n      return {\n        type: 'success',\n        marks: [\n          {name: 'attr_access', position: startPos},\n          {name: 'ident', position: identStart},\n          {name: 'ident_end', position: pos},\n        ],\n        position: pos,\n      }\n    }\n    case '-':\n      if (str[pos + 1] !== '>') return {type: 'error', position: pos}\n      // ->\n\n      let marks = [{name: 'deref', position: startPos}]\n      pos += 2\n\n      let identPos = skipWS(str, pos)\n      let identLen = parseRegex(str, identPos, IDENT)\n      if (identLen) {\n        pos = identPos + identLen\n        marks.push(\n          {name: 'deref_attr', position: identPos},\n          {name: 'ident', position: identPos},\n          {name: 'ident_end', position: pos}\n        )\n      }\n\n      return {\n        type: 'success',\n        marks,\n        position: pos,\n      }\n    case '[': {\n      pos = skipWS(str, pos + 1)\n\n      if (str[pos] === ']') {\n        return {\n          type: 'success',\n          marks: [{name: 'array_postfix', position: startPos}],\n          position: pos + 1,\n        }\n      }\n\n      let rangePos = pos\n      let result = parseExpr(str, pos, 0)\n      if (result.type === 'error') return result\n\n      pos = skipWS(str, result.position)\n\n      if (str[pos] === '.' && str[pos + 1] === '.') {\n        let type = 'inc_range'\n        if (str[pos + 2] === '.') {\n          type = 'exc_range'\n          pos += 3\n        } else {\n          pos += 2\n        }\n\n        pos = skipWS(str, pos)\n        let rhs = parseExpr(str, pos, 0)\n        if (rhs.type === 'error') return rhs\n        pos = skipWS(str, rhs.position)\n        if (str[pos] !== ']') return {type: 'error', position: pos}\n\n        return {\n          type: 'success',\n          marks: [\n            {name: 'slice', position: startPos},\n            {name: type, position: rangePos},\n          ].concat(result.marks, rhs.marks),\n          position: pos + 1,\n        }\n      }\n\n      if (str[pos] !== ']') return {type: 'error', position: pos}\n\n      return {\n        type: 'success',\n        marks: [{name: 'square_bracket', position: startPos}].concat(result.marks),\n        position: pos + 1,\n      }\n    }\n    case '|': {\n      pos = skipWS(str, pos + 1)\n      if (str[pos] === '{') {\n        let result = parseObject(str, pos)\n        if (result.type === 'error') return result\n        result.marks.unshift({name: 'projection', position: startPos})\n        return result\n      }\n      break\n    }\n    case '{': {\n      let result = parseObject(str, pos)\n      if (result.type === 'error') return result\n      result.marks.unshift({name: 'projection', position: startPos})\n      return result\n    }\n  }\n\n  return {type: 'error', position: pos}\n}\n\nfunction parseFuncCall(str, startPos, pos) {\n  let marks = []\n\n  marks.push({name: 'func_call', position: startPos})\n\n  if (str[pos] === ':' && str[pos + 1] === ':') {\n    marks.push({name: 'namespace', position: startPos})\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos})\n    pos = skipWS(str, pos + 2)\n    let nameLen = parseRegex(str, pos, IDENT)\n    if (!nameLen) return {type: 'error', position: pos}\n    marks.push({name: 'ident', position: pos}, {name: 'ident_end', position: pos + nameLen})\n    pos = skipWS(str, pos + nameLen)\n    if (str[pos] !== '(') return {type: 'error', position: pos}\n    pos++\n    // Consume any whitespace in front of the function argument.\n    pos = skipWS(str, pos)\n  } else {\n    marks.push({name: 'ident', position: startPos}, {name: 'ident_end', position: pos})\n    pos = skipWS(str, pos + 1)\n  }\n\n  let lastPos = pos\n\n  if (str[pos] !== ')') {\n    while (true) {\n      let result = parseExpr(str, pos, 0)\n      if (result.type === 'error') return result\n      marks = marks.concat(result.marks)\n      lastPos = result.position\n      pos = skipWS(str, result.position)\n      if (str[pos] !== ',') break\n      pos = skipWS(str, pos + 1)\n      // Also allow trailing commas\n      if (str[pos] === ')') break\n    }\n  }\n\n  if (str[pos] !== ')') {\n    return {type: 'error', position: pos}\n  }\n\n  // NOTE: a bit arbitrary the func_args_end points comes before the whitespace.\n  marks.push({name: 'func_args_end', position: lastPos})\n\n  return {\n    type: 'success',\n    marks,\n    position: pos + 1,\n  }\n}\n\nfunction parseObject(str, pos) {\n  let marks = [{name: 'object', position: pos}]\n  pos = skipWS(str, pos + 1)\n\n  loop: while (str[pos] !== '}') {\n    let pairPos = pos\n\n    if (str.slice(pos, pos + 3) === '...') {\n      pos = skipWS(str, pos + 3)\n      if (str[pos] !== '}' && str[pos] !== ',') {\n        let expr = parseExpr(str, pos, 0)\n        if (expr.type === 'error') return expr\n        marks.push({name: 'object_splat', position: pairPos})\n        marks = marks.concat(expr.marks)\n        pos = expr.position\n      } else {\n        marks.push({name: 'object_splat_this', position: pairPos})\n      }\n    } else {\n      let expr = parseExpr(str, pos, 0)\n      if (expr.type === 'error') return expr\n      let nextPos = skipWS(str, expr.position)\n      if (expr.marks[0].name === 'str' && str[nextPos] === ':') {\n        let value = parseExpr(str, skipWS(str, nextPos + 1), 0)\n        if (value.type === 'error') return value\n        marks.push({name: 'object_pair', position: pairPos})\n        marks = marks.concat(expr.marks, value.marks)\n        pos = value.position\n      } else {\n        marks = marks.concat({name: 'object_expr', position: pos}, expr.marks)\n        pos = expr.position\n      }\n    }\n    pos = skipWS(str, pos)\n    if (str[pos] !== ',') break\n    pos = skipWS(str, pos + 1)\n  }\n\n  if (str[pos] !== '}') {\n    return {type: 'error', position: pos}\n  }\n\n  pos++\n  marks.push({name: 'object_end', position: pos})\n  return {type: 'success', marks, position: pos}\n}\n\nfunction parseString(str, pos) {\n  let token = str[pos]\n  pos = pos + 1\n  const marks = [{name: 'str', position: pos}]\n  str: for (; ; pos++) {\n    if (pos > str.length) return {type: 'error', position: pos}\n\n    switch (str[pos]) {\n      case token: {\n        marks.push({name: 'str_end', position: pos})\n        pos++\n        break str\n      }\n      case '\\\\': {\n        marks.push({name: 'str_pause', position: pos})\n        if (str[pos + 1] === 'u') {\n          if (str[pos + 2] === '{') {\n            marks.push({name: 'unicode_hex', position: pos + 3})\n            pos = str.indexOf('}', pos + 3)\n            marks.push({name: 'unicode_hex_end', position: pos})\n          } else {\n            marks.push({name: 'unicode_hex', position: pos + 2})\n            marks.push({name: 'unicode_hex_end', position: pos + 6})\n            pos += 5\n          }\n        } else {\n          marks.push({name: 'single_escape', position: pos + 1})\n          pos += 1\n        }\n        marks.push({name: 'str_start', position: pos + 1})\n      }\n    }\n  }\n\n  return {type: 'success', marks, position: pos}\n}\n\nfunction skipWS(str, pos) {\n  return pos + parseRegex(str, pos, WS)\n}\n\n/**\n * Parses a regex at a position and returns the number of characters that was matched.\n */\nfunction parseRegex(str, pos, re) {\n  let m = re.exec(str.slice(pos))\n  return m ? m[0].length : 0\n}\n\n/**\n * Parses a regex at a position and returns matched string.\n */\nfunction parseRegexStr(str, pos, re) {\n  let m = re.exec(str.slice(pos))\n  return m ? m[0] : null\n}\n\nexport {parse}\n", "/* eslint-disable camelcase */\nimport {ExprNode} from './nodeTypes'\n\nexport type Traversal = (base: ExprNode) => ExprNode\n\n/**\n * Join combines two traversals, returning a mapper which is the result of first\n * applying `a` and then applying `b`.\n */\nfunction join(a: Traversal, b: Traversal): Traversal {\n  return (base: ExprNode) => b(a(base))\n}\n\n/**\n * Map returns a new mapper which will the inner mappe to each element of the array.\n */\nfunction map(inner: Traversal): Traversal {\n  return (base: ExprNode) => ({type: 'Map', base, expr: inner({type: 'This'})})\n}\n\nfunction flatMap(inner: Traversal): Traversal {\n  return (base: ExprNode) => ({type: 'FlatMap', base, expr: inner({type: 'This'})})\n}\n\nexport type TraversalResult = {\n  type: 'a-a' | 'a-b' | 'b-a' | 'b-b'\n  build: Traversal\n}\n\nexport function traverseArray(build: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'a-a',\n      build: build,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n      return {\n        type: 'a-a',\n        build: join(build, right.build),\n      }\n\n    case 'a-b':\n      return {\n        type: 'a-b',\n        build: join(build, right.build),\n      }\n\n    case 'b-b':\n      return {\n        type: 'a-a',\n        build: join(build, map(right.build)),\n      }\n\n    case 'b-a':\n      return {\n        type: 'a-a',\n        build: join(build, flatMap(right.build)),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traversePlain(mapper: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'b-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n    case 'b-a':\n      return {\n        type: 'b-a',\n        build: join(mapper, right.build),\n      }\n\n    case 'a-b':\n    case 'b-b':\n      return {\n        type: 'b-b',\n        build: join(mapper, right.build),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traverseElement(mapper: Traversal, right: TraversalResult | null): TraversalResult {\n  if (!right) {\n    return {\n      type: 'a-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n    case 'b-a':\n      return {\n        type: 'a-a',\n        build: join(mapper, right.build),\n      }\n\n    case 'a-b':\n    case 'b-b':\n      return {\n        type: 'a-b',\n        build: join(mapper, right.build),\n      }\n\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n\nexport function traverseProjection(\n  mapper: Traversal,\n  right: TraversalResult | null\n): TraversalResult {\n  if (!right) {\n    return {\n      type: 'b-b',\n      build: mapper,\n    }\n  }\n\n  switch (right.type) {\n    case 'a-a':\n      return {\n        type: 'a-a',\n        build: join(map(mapper), right.build),\n      }\n    case 'a-b':\n      return {\n        type: 'a-b',\n        build: join(map(mapper), right.build),\n      }\n    case 'b-a':\n      return {\n        type: 'b-a',\n        build: join(mapper, right.build),\n      }\n    case 'b-b':\n      return {\n        type: 'b-b',\n        build: join(mapper, right.build),\n      }\n    default:\n      throw new Error(`unknown type: ${right.type}`)\n  }\n}\n", "/* eslint-disable camelcase */\nimport {tryConstantEvaluate} from './evaluator'\nimport {GroqFunctionArity, namespaces, pipeFunctions} from './evaluator/functions'\nimport {Mark, MarkProcessor, MarkVisitor} from './markProcessor'\nimport {\n  ArrayElementNode,\n  ExprNode,\n  FuncCallNode,\n  ObjectAttributeNode,\n  ObjectSplatNode,\n  OpCall,\n  ParentNode,\n  SelectNode,\n} from './nodeTypes'\nimport {parse as rawParse} from './rawParser'\nimport {\n  TraversalResult,\n  traverseArray,\n  traverseElement,\n  traversePlain,\n  traverseProjection,\n} from './traversal'\nimport {ParseOptions} from './types'\n\ntype EscapeSequences = \"'\" | '\"' | '\\\\' | '/' | 'b' | 'f' | 'n' | 'r' | 't'\n\nconst ESCAPE_SEQUENCE: {[key in EscapeSequences]: string} = {\n  \"'\": \"'\",\n  '\"': '\"',\n  '\\\\': '\\\\',\n  '/': '/',\n  b: '\\b',\n  f: '\\f',\n  n: '\\n',\n  r: '\\r',\n  t: '\\t',\n}\n\nfunction expandHex(str: string): string {\n  const charCode = parseInt(str, 16)\n  return String.fromCharCode(charCode)\n}\n\nclass GroqQueryError extends Error {\n  public name = 'GroqQueryError'\n}\n\nconst EXPR_BUILDER: MarkVisitor<ExprNode> = {\n  group(p) {\n    const inner = p.process(EXPR_BUILDER)\n    return {\n      type: 'Group',\n      base: inner,\n    }\n  },\n\n  everything() {\n    return {type: 'Everything'}\n  },\n\n  this() {\n    return {type: 'This'}\n  },\n\n  parent() {\n    return {\n      type: 'Parent',\n      n: 1,\n    }\n  },\n\n  dblparent(p) {\n    const next = p.process(EXPR_BUILDER) as ParentNode\n    return {\n      type: 'Parent',\n      n: next.n + 1,\n    }\n  },\n\n  traverse(p) {\n    const base = p.process(EXPR_BUILDER)\n    const traversalList: Array<(right: TraversalResult | null) => TraversalResult> = []\n    while (p.getMark().name !== 'traversal_end') {\n      traversalList.push(p.process(TRAVERSE_BUILDER))\n    }\n    p.shift()\n    let traversal: TraversalResult | null = null\n    for (let i = traversalList.length - 1; i >= 0; i--) {\n      traversal = traversalList[i](traversal)\n    }\n    if (base.type === 'Everything' || base.type === 'Array' || base.type === 'PipeFuncCall') {\n      traversal = traverseArray((val) => val, traversal)\n    }\n    if (traversal === null) throw new Error('BUG: unexpected empty traversal')\n    return traversal.build(base)\n  },\n\n  this_attr(p) {\n    const name = p.processString()\n\n    if (name === 'null') {\n      return {type: 'Value', value: null}\n    }\n    if (name === 'true') {\n      return {type: 'Value', value: true}\n    }\n    if (name === 'false') {\n      return {type: 'Value', value: false}\n    }\n\n    return {\n      type: 'AccessAttribute',\n      name,\n    }\n  },\n\n  neg(p) {\n    const base = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'Neg',\n      base,\n    }\n  },\n\n  pos(p) {\n    const base = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'Pos',\n      base,\n    }\n  },\n\n  add(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '+',\n      left,\n      right,\n    }\n  },\n\n  sub(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '-',\n      left,\n      right,\n    }\n  },\n\n  mul(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '*',\n      left,\n      right,\n    }\n  },\n\n  div(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '/',\n      left,\n      right,\n    }\n  },\n\n  mod(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '%',\n      left,\n      right,\n    }\n  },\n\n  pow(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: '**',\n      left,\n      right,\n    }\n  },\n\n  comp(p) {\n    const left = p.process(EXPR_BUILDER)\n    const op = p.processString() as OpCall\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'OpCall',\n      op: op,\n      left: left,\n      right: right,\n    }\n  },\n\n  in_range(p) {\n    const base = p.process(EXPR_BUILDER)\n    const isInclusive = p.getMark().name === 'inc_range'\n    p.shift()\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'InRange',\n      base,\n      left,\n      right,\n      isInclusive,\n    }\n  },\n\n  str(p) {\n    let value = ''\n    // eslint-disable-next-line no-labels\n    loop: while (p.hasMark()) {\n      const mark = p.getMark()\n      switch (mark.name) {\n        case 'str_end':\n          value += p.processStringEnd()\n          // eslint-disable-next-line no-labels\n          break loop\n        case 'str_pause':\n          value += p.processStringEnd()\n          break\n        case 'str_start':\n          p.shift()\n          break\n        case 'single_escape': {\n          const char = p.slice(1)\n          p.shift()\n          value += ESCAPE_SEQUENCE[char as EscapeSequences]\n          break\n        }\n        case 'unicode_hex':\n          p.shift()\n          value += expandHex(p.processStringEnd())\n          break\n        default:\n          throw new Error(`unexpected mark: ${mark.name}`)\n      }\n    }\n    return {type: 'Value', value}\n  },\n\n  integer(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  float(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  sci(p) {\n    const strValue = p.processStringEnd()\n    return {\n      type: 'Value',\n      value: Number(strValue),\n    }\n  },\n\n  object(p) {\n    const attributes: ObjectAttributeNode[] = []\n    while (p.getMark().name !== 'object_end') {\n      attributes.push(p.process(OBJECT_BUILDER))\n    }\n    p.shift()\n\n    return {\n      type: 'Object',\n      attributes,\n    }\n  },\n\n  array(p) {\n    const elements: ArrayElementNode[] = []\n    while (p.getMark().name !== 'array_end') {\n      let isSplat = false\n      if (p.getMark().name === 'array_splat') {\n        isSplat = true\n        p.shift()\n      }\n      const value = p.process(EXPR_BUILDER)\n      elements.push({\n        type: 'ArrayElement',\n        value,\n        isSplat,\n      })\n    }\n    p.shift()\n    return {\n      type: 'Array',\n      elements: elements,\n    }\n  },\n\n  tuple(p) {\n    const members: ExprNode[] = []\n    while (p.getMark().name !== 'tuple_end') {\n      members.push(p.process(EXPR_BUILDER))\n    }\n    p.shift()\n    return {\n      type: 'Tuple',\n      members,\n    }\n  },\n\n  func_call(p) {\n    let namespace = 'global'\n    if (p.getMark().name === 'namespace') {\n      p.shift()\n      namespace = p.processString()\n    }\n\n    const name = p.processString()\n    if (namespace === 'global' && name === 'select') {\n      const result: SelectNode = {\n        type: 'Select',\n        alternatives: [],\n      }\n\n      while (p.getMark().name !== 'func_args_end') {\n        if (p.getMark().name === 'pair') {\n          if (result.fallback) throw new GroqQueryError(`unexpected argument to select()`)\n          p.shift()\n          const condition = p.process(EXPR_BUILDER)\n          const value = p.process(EXPR_BUILDER)\n          result.alternatives.push({\n            type: 'SelectAlternative',\n            condition,\n            value,\n          })\n        } else {\n          if (result.fallback) throw new GroqQueryError(`unexpected argument to select()`)\n          const value = p.process(EXPR_BUILDER)\n          result.fallback = value\n        }\n      }\n      p.shift()\n      return result\n    }\n\n    const args: ExprNode[] = []\n\n    while (p.getMark().name !== 'func_args_end') {\n      if (argumentShouldBeSelector(namespace, name, args.length)) {\n        // Since the diff/delta functions aren't validated yet we only want to validate the selector\n        // being used. We expect the null valued arg to throw an error at evaluation time.\n        p.process(SELECTOR_BUILDER)\n        args.push({type: 'Selector'})\n      } else {\n        args.push(p.process(EXPR_BUILDER))\n      }\n    }\n\n    p.shift()\n\n    if (namespace === 'global' && (name === 'before' || name === 'after')) {\n      if (p.parseOptions.mode === 'delta') {\n        return {\n          type: 'Context',\n          key: name,\n        }\n      }\n    }\n\n    if (namespace === 'global' && name === 'boost' && !p.allowBoost)\n      throw new GroqQueryError('unexpected boost')\n\n    const funcs = namespaces[namespace]\n    if (!funcs) {\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`)\n    }\n\n    const func = funcs[name]\n    if (!func) {\n      throw new GroqQueryError(`Undefined function: ${name}`)\n    }\n    if (func.arity !== undefined) {\n      validateArity(name, func.arity, args.length)\n    }\n\n    if (func.mode !== undefined && func.mode !== p.parseOptions.mode) {\n      throw new GroqQueryError(`Undefined function: ${name}`)\n    }\n\n    return {\n      type: 'FuncCall',\n      func,\n      name,\n      args,\n    }\n  },\n\n  pipecall(p) {\n    const base = p.process(EXPR_BUILDER)\n    p.shift() // Remove the func_call\n\n    let namespace = 'global'\n    if (p.getMark().name === 'namespace') {\n      p.shift()\n      namespace = p.processString()\n    }\n    if (namespace !== 'global') {\n      throw new GroqQueryError(`Undefined namespace: ${namespace}`)\n    }\n\n    const name = p.processString()\n    const args: ExprNode[] = []\n\n    const oldAllowBoost = p.allowBoost\n    if (name === 'score') {\n      // Only allow boost inside a score expression\n      p.allowBoost = true\n    }\n\n    for (;;) {\n      const markName = p.getMark().name\n      if (markName === 'func_args_end') {\n        break\n      }\n\n      if (name === 'order') {\n        if (markName === 'asc') {\n          p.shift()\n          args.push({type: 'Asc', base: p.process(EXPR_BUILDER)})\n          continue\n        } else if (markName === 'desc') {\n          p.shift()\n          args.push({type: 'Desc', base: p.process(EXPR_BUILDER)})\n          continue\n        }\n      }\n\n      args.push(p.process(EXPR_BUILDER))\n    }\n    p.shift()\n\n    p.allowBoost = oldAllowBoost\n\n    const func = pipeFunctions[name]\n    if (!func) {\n      throw new GroqQueryError(`Undefined pipe function: ${name}`)\n    }\n    if (func.arity) {\n      validateArity(name, func.arity, args.length)\n    }\n\n    return {\n      type: 'PipeFuncCall',\n      func,\n      base,\n      name,\n      args,\n    }\n  },\n\n  pair(p) {\n    throw new GroqQueryError(`unexpected =>`)\n  },\n\n  and(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'And',\n      left,\n      right,\n    }\n  },\n\n  or(p) {\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n    return {\n      type: 'Or',\n      left,\n      right,\n    }\n  },\n\n  not(p) {\n    const base = p.process(EXPR_BUILDER)\n    return {\n      type: 'Not',\n      base,\n    }\n  },\n\n  asc(p) {\n    throw new GroqQueryError('unexpected asc')\n  },\n\n  desc(p) {\n    throw new GroqQueryError('unexpected desc')\n  },\n\n  param(p) {\n    const name = p.processString()\n\n    if (p.parseOptions.params && p.parseOptions.params.hasOwnProperty(name)) {\n      return {\n        type: 'Value',\n        value: p.parseOptions.params[name],\n      }\n    }\n\n    return {\n      type: 'Parameter',\n      name,\n    }\n  },\n}\n\nconst OBJECT_BUILDER: MarkVisitor<ObjectAttributeNode> = {\n  object_expr(p) {\n    if (p.getMark().name === 'pair') {\n      p.shift()\n      const condition = p.process(EXPR_BUILDER)\n      const value = p.process(EXPR_BUILDER)\n\n      return {\n        type: 'ObjectConditionalSplat',\n        condition,\n        value,\n      }\n    }\n\n    const value = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'ObjectAttributeValue',\n      name: extractPropertyKey(value),\n      value,\n    }\n  },\n\n  object_pair(p) {\n    const name = p.process(EXPR_BUILDER)\n    if (name.type !== 'Value') throw new Error('name must be string')\n\n    const value = p.process(EXPR_BUILDER)\n    return {\n      type: 'ObjectAttributeValue',\n      name: name.value,\n      value: value,\n    }\n  },\n\n  object_splat(p): ObjectSplatNode {\n    const value = p.process(EXPR_BUILDER)\n\n    return {\n      type: 'ObjectSplat',\n      value,\n    }\n  },\n\n  object_splat_this(): ObjectSplatNode {\n    return {\n      type: 'ObjectSplat',\n      value: {type: 'This'},\n    }\n  },\n}\n\nconst TRAVERSE_BUILDER: MarkVisitor<(rhs: TraversalResult | null) => TraversalResult> = {\n  square_bracket(p) {\n    const expr = p.process(EXPR_BUILDER)\n\n    const value = tryConstantEvaluate(expr)\n    if (value && value.type === 'number') {\n      return (right) =>\n        traverseElement((base) => ({type: 'AccessElement', base, index: value.data}), right)\n    }\n\n    if (value && value.type === 'string') {\n      return (right) =>\n        traversePlain((base) => ({type: 'AccessAttribute', base, name: value.data}), right)\n    }\n\n    return (right) =>\n      traverseArray(\n        (base) => ({\n          type: 'Filter',\n          base,\n          expr,\n        }),\n        right\n      )\n  },\n\n  slice(p) {\n    const isInclusive = p.getMark().name === 'inc_range'\n    p.shift()\n\n    const left = p.process(EXPR_BUILDER)\n    const right = p.process(EXPR_BUILDER)\n\n    const leftValue = tryConstantEvaluate(left)\n    const rightValue = tryConstantEvaluate(right)\n\n    if (!leftValue || !rightValue || leftValue.type !== 'number' || rightValue.type !== 'number') {\n      throw new GroqQueryError('slicing must use constant numbers')\n    }\n\n    return (rhs) =>\n      traverseArray(\n        (base) => ({\n          type: 'Slice',\n          base,\n          left: leftValue.data,\n          right: rightValue.data,\n          isInclusive,\n        }),\n        rhs\n      )\n  },\n\n  projection(p) {\n    const obj = p.process(EXPR_BUILDER)\n    return (right) =>\n      traverseProjection((base) => ({type: 'Projection', base: base, expr: obj}), right)\n  },\n\n  attr_access(p) {\n    const name = p.processString()\n\n    return (right) => traversePlain((base) => ({type: 'AccessAttribute', base, name}), right)\n  },\n\n  deref(p) {\n    let attr: string | null = null\n\n    if (p.getMark().name === 'deref_attr') {\n      p.shift()\n      attr = p.processString()\n    }\n\n    const wrap = (base: ExprNode): ExprNode =>\n      attr ? {type: 'AccessAttribute', base, name: attr} : base\n\n    return (right) =>\n      traversePlain(\n        (base) =>\n          wrap({\n            type: 'Deref',\n            base,\n          }),\n        right\n      )\n  },\n\n  array_postfix(p) {\n    return (right) => traverseArray((base) => ({type: 'ArrayCoerce', base}), right)\n  },\n}\n\nconst SELECTOR_BUILDER: MarkVisitor<null> = {\n  group(p) {\n    p.process(SELECTOR_BUILDER)\n    return null\n  },\n\n  everything() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  this() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  parent() {\n    throw new Error('Invalid selector syntax')\n  },\n\n  dblparent(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  traverse(p) {\n    p.process(SELECTOR_BUILDER)\n    while (p.getMark().name !== 'traversal_end') {\n      p.process(TRAVERSE_BUILDER)\n    }\n\n    p.shift()\n    return null\n  },\n\n  this_attr(p) {\n    p.processString()\n    return null\n  },\n\n  neg(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pos(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  add(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  sub(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  mul(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  div(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  mod(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pow(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  comp(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  in_range(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  str(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  integer(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  float(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  sci(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  object(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  array(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  tuple(p) {\n    // This should only throw an error until we add support for tuples in selectors.\n    throw new Error('Invalid selector syntax')\n  },\n\n  func_call(p, mark) {\n    const func = EXPR_BUILDER.func_call(p, mark) as FuncCallNode\n    if (func.name === 'anywhere' && func.args.length === 1) return null\n\n    throw new Error('Invalid selector syntax')\n  },\n\n  pipecall(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  pair(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  and(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  or(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  not(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  asc(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  desc(p) {\n    throw new Error('Invalid selector syntax')\n  },\n\n  param(p) {\n    throw new Error('Invalid selector syntax')\n  },\n}\n\nfunction extractPropertyKey(node: ExprNode): string {\n  if (node.type === 'AccessAttribute' && !node.base) {\n    return node.name\n  }\n\n  if (\n    node.type === 'Deref' ||\n    node.type === 'Map' ||\n    node.type === 'Projection' ||\n    node.type === 'Slice' ||\n    node.type === 'Filter' ||\n    node.type === 'AccessElement' ||\n    node.type === 'ArrayCoerce'\n  ) {\n    return extractPropertyKey(node.base)\n  }\n\n  throw new GroqQueryError(`Cannot determine property key for type: ${node.type}`)\n}\n\nfunction validateArity(name: string, arity: GroqFunctionArity, count: number) {\n  if (typeof arity === 'number') {\n    if (count !== arity) {\n      throw new GroqQueryError(\n        `Incorrect number of arguments to function ${name}(). Expected ${arity}, got ${count}.`\n      )\n    }\n  } else if (arity) {\n    if (!arity(count)) {\n      throw new GroqQueryError(`Incorrect number of arguments to function ${name}().`)\n    }\n  }\n}\n\nfunction argumentShouldBeSelector(namespace: string, functionName: string, argCount: number) {\n  const functionsRequiringSelectors = ['changedAny', 'changedOnly']\n\n  return namespace == 'diff' && argCount == 2 && functionsRequiringSelectors.includes(functionName)\n}\n\nclass GroqSyntaxError extends Error {\n  public position: number\n  public name = 'GroqSyntaxError'\n\n  constructor(position: number) {\n    super(`Syntax error in GROQ query at position ${position}`)\n    this.position = position\n  }\n}\n\n/**\n * Parses a GROQ query and returns a tree structure.\n */\nexport function parse(input: string, options: ParseOptions = {}): ExprNode {\n  const result = rawParse(input)\n  if (result.type === 'error') {\n    throw new GroqSyntaxError(result.position)\n  }\n  const processor = new MarkProcessor(input, result.marks as Mark[], options)\n  return processor.process(EXPR_BUILDER)\n}\n", "import {Subscription, MutationEvent, Config, ApiError, EnvImplementations} from './types'\n\ntype EventSourceInstance = InstanceType<EnvImplementations['EventSource']>\n\nconst isNativeBrowserEventSource = (\n  eventSource: EventSourceInstance\n): eventSource is InstanceType<typeof globalThis.EventSource> =>\n  typeof window !== 'undefined' &&\n  eventSource.addEventListener === window.EventSource.prototype.addEventListener\n\nconst addEventSourceListener = (\n  eventSource: EventSourceInstance,\n  type: string,\n  listener: EventListener\n): void => {\n  if (isNativeBrowserEventSource(eventSource)) {\n    eventSource.addEventListener(type, listener, false)\n  }\n\n  // Polyfilled event source does not accept option parameter\n  eventSource.addEventListener(type, listener)\n}\n\nexport function listen(\n  EventSourceImpl: EnvImplementations['EventSource'],\n  config: Config,\n  handlers: {\n    open: () => void\n    error: (err: Error) => void\n    next: (event: MutationEvent) => void\n  }\n): Subscription {\n  const {projectId, dataset, token} = config\n  const headers = token ? {Authorization: `Bearer ${token}`} : undefined\n  const url = `https://${projectId}.api.sanity.io/v1/data/listen/${dataset}?query=*&effectFormat=mendoza`\n  const es = new EventSourceImpl(url, {withCredentials: true, headers})\n\n  addEventSourceListener(es, 'welcome', handlers.open)\n\n  addEventSourceListener(es, 'mutation', getMutationParser(handlers.next))\n\n  addEventSourceListener(es, 'channelError', (msg: any) => {\n    es.close()\n\n    let data\n    try {\n      data = JSON.parse(msg.data) as ApiError\n    } catch (err) {\n      handlers.error(new Error('Unknown error parsing listener message'))\n      return\n    }\n\n    handlers.error(\n      new Error(data.message || data.error || `Listener returned HTTP ${data.statusCode}`)\n    )\n  })\n\n  addEventSourceListener(es, 'error', (err: Event) => {\n    const origin = typeof window !== 'undefined' && window.location.origin\n    const hintSuffix = origin ? `, and that the CORS-origin (${origin}) is allowed` : ''\n    const errorMessage = isErrorLike(err) ? ` (${err.message})` : ''\n    handlers.error(\n      new Error(\n        `Error establishing listener - check that the project ID and dataset are correct${hintSuffix}${errorMessage}`\n      )\n    )\n  })\n\n  return {\n    unsubscribe: (): Promise<void> => Promise.resolve(es.close()),\n  }\n}\n\nfunction getMutationParser(cb: (event: MutationEvent) => void): (msg: any) => void {\n  return (msg: any) => {\n    let data\n    try {\n      data = JSON.parse(msg.data)\n    } catch (err) {\n      // intentional noop\n      return\n    }\n\n    cb(data)\n  }\n}\n\nfunction isErrorLike(err: unknown): err is {message: string} {\n  return typeof err === 'object' && err !== null && 'message' in err\n}\n", "import {SanityDocument} from '@sanity/types'\n\nexport function isDraft(doc: SanityDocument): boolean {\n  return doc._id.startsWith('drafts.')\n}\n\nexport function getPublishedId(document: SanityDocument): string {\n  return isDraft(document) ? document._id.slice(7) : document._id\n}\n", "import {SanityDocument} from '@sanity/types'\nimport {applyPatch} from 'mendoza'\n\nexport function applyPatchWithoutRev(\n  doc: SanityDocument | null,\n  patch: unknown[]\n): SanityDocument | null {\n  const patchDoc = {...doc} as Omit<SanityDocument, '_rev'>\n  delete patchDoc._rev\n  return applyPatch(patchDoc, patch)\n}\n", "import {SanityDocument} from '@sanity/types'\nimport {listen} from './listen'\nimport {getPublishedId} from './drafts'\nimport {applyPatchWithoutRev} from './patch'\nimport {Config, EnvImplementations, MutationEvent, Subscription} from './types'\n\nconst DEBOUNCE_MS = 25\n\nfunction noop() {\n  return Promise.resolve()\n}\n\nexport function getSyncingDataset(\n  config: Config,\n  onNotifyUpdate: (docs: SanityDocument[]) => void,\n  {getDocuments, EventSource}: EnvImplementations\n): Subscription & {loaded: Promise<void>} {\n  const {\n    projectId,\n    dataset,\n    listen: useListener,\n    overlayDrafts,\n    documentLimit,\n    token,\n    includeTypes,\n  } = config\n\n  if (!useListener) {\n    const loaded = getDocuments({projectId, dataset, documentLimit, token, includeTypes})\n      .then(onUpdate)\n      .then(noop)\n    return {unsubscribe: noop, loaded}\n  }\n\n  const indexedDocuments = new Map<string, SanityDocument>()\n\n  // undefined until the listener has been set up and the initial export is done\n  let documents: SanityDocument[] | undefined\n\n  // holds any mutations that happen while fetching documents so they can be applied after updates\n  const buffer: MutationEvent[] = []\n\n  // Return a promise we can resolve once we've established a listener and reconciled any mutations\n  let onDoneLoading: () => void\n  let onLoadError: (error: Error) => void\n  const loaded = new Promise<void>((resolve, reject) => {\n    onDoneLoading = resolve\n    onLoadError = reject\n  })\n\n  // We don't want to flush updates while we're in the same transaction, so a normal\n  // throttle/debounce wouldn't do it. We need to wait and see if the next mutation is\n  // within the same transaction as the previous, and if not we can flush. Of course,\n  // we can't wait forever, so an upper threshold of X ms should be counted as \"ok to flush\"\n  let stagedDocs: SanityDocument[] | undefined\n  let previousTrx: string | undefined\n  let flushTimeout: NodeJS.Timer | undefined\n\n  const listener = listen(EventSource, config, {\n    next: onMutationReceived,\n    open: onOpen,\n    error: (error: Error) => onLoadError(error),\n  })\n\n  return {unsubscribe: listener.unsubscribe, loaded}\n\n  async function onOpen() {\n    const initial = await getDocuments({projectId, dataset, documentLimit, token, includeTypes})\n    documents = applyBufferedMutations(initial, buffer)\n    documents.forEach((doc) => indexedDocuments.set(doc._id, doc))\n    onUpdate(documents)\n    onDoneLoading()\n  }\n\n  function onMutationReceived(msg: MutationEvent) {\n    if (documents) {\n      applyMutation(msg)\n      scheduleUpdate(documents, msg)\n    } else {\n      buffer.push(msg)\n    }\n  }\n\n  function scheduleUpdate(docs: SanityDocument[], msg: MutationEvent) {\n    clearTimeout(flushTimeout)\n\n    if (previousTrx !== msg.transactionId && stagedDocs) {\n      // This is a new transaction, meaning we can immediately flush any pending\n      // doc updates if there are any\n      onUpdate(stagedDocs)\n      previousTrx = undefined\n    } else {\n      previousTrx = msg.transactionId\n      stagedDocs = docs.slice()\n    }\n\n    flushTimeout = setTimeout(onUpdate, DEBOUNCE_MS, docs.slice())\n  }\n\n  function onUpdate(docs: SanityDocument[]) {\n    stagedDocs = undefined\n    flushTimeout = undefined\n    previousTrx = undefined\n    onNotifyUpdate(overlayDrafts ? overlay(docs) : docs)\n  }\n\n  function applyMutation(msg: MutationEvent) {\n    if (!msg.effects || msg.documentId.startsWith('_.')) {\n      return\n    }\n\n    const document = indexedDocuments.get(msg.documentId) || null\n    replaceDocument(msg.documentId, applyPatchWithoutRev(document, msg.effects.apply))\n  }\n\n  function replaceDocument(id: string, document: SanityDocument | null) {\n    const current = indexedDocuments.get(id)\n    const docs = documents || []\n    const position = current ? docs.indexOf(current) : -1\n\n    if (position === -1 && document) {\n      // Didn't exist previously, but was now created. Add it.\n      docs.push(document)\n      indexedDocuments.set(id, document)\n    } else if (document) {\n      // Existed previously and still does. Replace it.\n      docs.splice(position, 1, document)\n      indexedDocuments.set(id, document)\n    } else {\n      // Existed previously, but is now deleted. Remove it.\n      docs.splice(position, 1)\n      indexedDocuments.delete(id)\n    }\n  }\n}\n\nfunction applyBufferedMutations(\n  documents: SanityDocument[],\n  mutations: MutationEvent[]\n): SanityDocument[] {\n  // Group by document ID\n  const groups = new Map<string, MutationEvent[]>()\n  mutations.forEach((mutation) => {\n    const group = groups.get(mutation.documentId) || []\n    group.push(mutation)\n    groups.set(mutation.documentId, group)\n  })\n\n  // Discard all mutations that happened before our current document\n  groups.forEach((group, id) => {\n    const document = documents.find((doc) => doc._id === id)\n    if (!document) {\n      // @todo handle\n      // eslint-disable-next-line no-console\n      console.warn('Received mutation for missing document %s', id)\n      return\n    }\n\n    // Mutations are sorted by timestamp, apply any that arrived after\n    // we fetched the initial documents\n    let hasFoundRevision = false\n    let current: SanityDocument | null = document\n    group.forEach((mutation) => {\n      hasFoundRevision = hasFoundRevision || mutation.previousRev === document._rev\n      if (!hasFoundRevision) {\n        return\n      }\n\n      if (mutation.effects) {\n        current = applyPatchWithoutRev(current, mutation.effects.apply)\n      }\n    })\n\n    // Replace the indexed documents\n    documents.splice(documents.indexOf(document), 1, current)\n  })\n\n  return documents\n}\n\nfunction overlay(documents: SanityDocument[]): SanityDocument[] {\n  const overlayed = new Map<string, SanityDocument>()\n\n  documents.forEach((doc) => {\n    const existing = overlayed.get(getPublishedId(doc))\n    if (doc._id.startsWith('drafts.')) {\n      // Drafts always overlay\n      overlayed.set(getPublishedId(doc), pretendThatItsPublished(doc))\n    } else if (!existing) {\n      // Published documents only override if draft doesn't exist\n      overlayed.set(doc._id, doc)\n    }\n  })\n\n  return Array.from(overlayed.values())\n}\n\n// Strictly speaking it would be better to allow groq-js to resolve `draft.<id>`,\n// but for now this will have to do\nfunction pretendThatItsPublished(doc: SanityDocument): SanityDocument {\n  return {...doc, _id: getPublishedId(doc)}\n}\n", "import groq from 'groq'\nimport deepEqual from 'fast-deep-equal'\nimport {throttle} from 'throttle-debounce'\nimport {SanityDocument} from '@sanity/types'\nimport {parse, evaluate} from 'groq-js'\nimport {Config, EnvImplementations, GroqSubscription, GroqStore, Subscription} from './types'\nimport {getSyncingDataset} from './syncingDataset'\n\nexport function groqStore(config: Config, envImplementations: EnvImplementations): GroqStore {\n  let documents: SanityDocument[] = []\n  const executeThrottled = throttle(config.subscriptionThrottleMs || 50, executeAllSubscriptions)\n  const activeSubscriptions: GroqSubscription[] = []\n\n  let dataset: Subscription & {loaded: Promise<void>}\n\n  async function loadDataset() {\n    if (!dataset) {\n      dataset = getSyncingDataset(\n        config,\n        (docs) => {\n          documents = docs\n          executeThrottled()\n        },\n        envImplementations\n      )\n    }\n\n    await dataset.loaded\n  }\n\n  async function query<R = any>(groqQuery: string, params?: Record<string, unknown>): Promise<R> {\n    await loadDataset()\n    const tree = parse(groqQuery, {params})\n    const result = await evaluate(tree as any, {dataset: documents, params})\n    return result.get()\n  }\n\n  async function getDocument(documentId: string): Promise<SanityDocument | null> {\n    await loadDataset()\n    return query(groq`*[_id == $id][0]`, {id: documentId})\n  }\n\n  async function getDocuments(documentIds: string[]): Promise<(SanityDocument | null)[]> {\n    await loadDataset()\n    const subQueries = documentIds.map((id) => `*[_id == \"${id}\"][0]`).join(',\\n')\n    return query(`[${subQueries}]`)\n  }\n\n  function subscribe<R = any>(\n    groqQuery: string,\n    params: Record<string, unknown>,\n    callback: (error: Error | undefined, result?: R) => void\n  ): Subscription {\n    if (!config.listen) {\n      throw new Error('Cannot use `subscribe()` without `listen: true`')\n    }\n\n    // @todo Execute the query against an empty dataset for validation purposes\n\n    // Store the subscription so we can re-run the query on new data\n    const subscription = {query: groqQuery, params, callback}\n    activeSubscriptions.push(subscription)\n\n    let unsubscribed = false\n    const unsubscribe = () => {\n      if (unsubscribed) {\n        return Promise.resolve()\n      }\n\n      unsubscribed = true\n      activeSubscriptions.splice(activeSubscriptions.indexOf(subscription), 1)\n      return Promise.resolve()\n    }\n\n    executeQuerySubscription(subscription)\n    return {unsubscribe}\n  }\n\n  function executeQuerySubscription(subscription: GroqSubscription) {\n    return query(subscription.query, subscription.params)\n      .then((res) => {\n        if ('previousResult' in subscription && deepEqual(subscription.previousResult, res)) {\n          return\n        }\n\n        subscription.previousResult = res\n        subscription.callback(undefined, res)\n      })\n      .catch((err) => {\n        subscription.callback(err)\n      })\n  }\n\n  function executeAllSubscriptions() {\n    activeSubscriptions.forEach(executeQuerySubscription)\n  }\n\n  function close() {\n    executeThrottled.cancel()\n    return dataset ? dataset.unsubscribe() : Promise.resolve()\n  }\n\n  return {query, getDocument, getDocuments, subscribe, close}\n}\n", "import {SanityDocument} from '@sanity/types'\nimport {EnvImplementations} from '../types'\n\ntype StreamError = {error: {description?: string; type: string}}\ntype StreamResult = SanityDocument | StreamError\n\nexport const getDocuments: EnvImplementations['getDocuments'] = async function getDocuments({\n  projectId,\n  dataset,\n  token,\n  documentLimit,\n  includeTypes = [],\n}: {\n  projectId: string\n  dataset: string\n  token?: string\n  documentLimit?: number\n  includeTypes?: string[]\n}): Promise<SanityDocument[]> {\n  const baseUrl = `https://${projectId}.api.sanity.io/v1/data/export/${dataset}`\n  const params =\n    includeTypes.length > 0 ? new URLSearchParams({types: includeTypes?.join(',')}) : ''\n  const url = `${baseUrl}?${params}`\n  const headers = token ? {Authorization: `Bearer ${token}`} : undefined\n  const response = await fetch(url, {credentials: 'include', headers})\n\n  if (response.status !== 200) {\n    throw new Error(`Error streaming dataset: ${getError(await response.json())}`)\n  }\n\n  const stream = getDocumentStream(response.body)\n  const reader = stream.getReader()\n\n  const documents: SanityDocument[] = []\n  let result\n  let document\n  do {\n    result = await reader.read()\n    document = result.value\n\n    if (isStreamError(document)) {\n      throw new Error(`Error streaming dataset: ${document.error}`)\n    } else if (document && isRelevantDocument(document)) {\n      documents.push(document)\n    }\n\n    if (documentLimit && documents.length > documentLimit) {\n      reader.cancel('Reached document limit')\n      throw new Error(\n        `Error streaming dataset: Reached limit of ${documentLimit} documents. Try using the includeTypes option to reduce the amount of documents, or increase the limit.`\n      )\n    }\n  } while (!result.done)\n\n  return documents\n}\n\nfunction getDocumentStream(body: Response['body']): ReadableStream<StreamResult> {\n  if (!body) {\n    throw new Error('Failed to read body from response')\n  }\n\n  let reader: ReadableStreamDefaultReader<Uint8Array> | undefined\n  let cancelled = false\n\n  function cancel() {\n    cancelled = true\n    if (reader) {\n      reader.cancel()\n    }\n  }\n\n  return new ReadableStream<SanityDocument>({\n    start(controller): void | PromiseLike<void> {\n      reader = body.getReader()\n      const decoder = new TextDecoder()\n      let buffer = ''\n\n      reader\n        .read()\n        .then(processResult)\n        .catch((err) => controller.error(err))\n\n      async function processResult(result: ReadableStreamReadResult<Uint8Array>): Promise<void> {\n        if (result.done) {\n          if (cancelled) {\n            return\n          }\n\n          buffer = buffer.trim()\n          if (buffer.length === 0) {\n            controller.close()\n            return\n          }\n\n          controller.enqueue(JSON.parse(buffer))\n          controller.close()\n          return\n        }\n\n        buffer += decoder.decode(result.value, {stream: true})\n        const lines = buffer.split('\\n')\n\n        for (let i = 0; i < lines.length - 1; ++i) {\n          const line = lines[i].trim()\n          if (line.length === 0) {\n            continue\n          }\n\n          try {\n            controller.enqueue(JSON.parse(line))\n          } catch (err) {\n            controller.error(err)\n            cancel()\n            return\n          }\n        }\n\n        buffer = lines[lines.length - 1]\n\n        if (!reader) {\n          return\n        }\n\n        try {\n          processResult(await reader.read())\n        } catch (err) {\n          controller.error(err)\n        }\n      }\n    },\n\n    cancel,\n  })\n}\n\nfunction isStreamError(result: StreamResult | undefined): result is StreamError {\n  if (!result) {\n    return false\n  }\n\n  if (!('error' in result) || typeof result.error !== 'object' || result.error === null) {\n    return false\n  }\n\n  return (\n    'description' in result.error &&\n    typeof (result as StreamError).error.description === 'string' &&\n    !('_id' in result)\n  )\n}\n\nfunction getError(body: any): string {\n  if (typeof body === 'object' && 'error' in body && 'message' in body) {\n    return body.message || body.error\n  }\n\n  return '<unknown error>'\n}\n\nfunction isRelevantDocument(doc: SanityDocument): boolean {\n  return !doc._id.startsWith('_.')\n}\n", "export function assertEnvSupport(): void {\n  const required = ['EventSource', 'ReadableStream', 'fetch']\n  const unsupported = required.filter((api) => !(api in window))\n\n  if (unsupported.length > 0) {\n    throw new Error(`Browser not supported. Missing browser APIs: ${unsupported.join(', ')}`)\n  }\n}\n", "import {groqStore as groqStoreApi} from '../groqStore'\nimport {Config, GroqStore} from '../types'\nimport {getDocuments} from './getDocuments'\nimport {assertEnvSupport} from './support'\n\n/** @public */\nexport function groqStore(config: Config): GroqStore {\n  assertEnvSupport()\n\n  const EventSource = config.EventSource ?? window.EventSource\n\n  if (config.token) {\n    if (!config.EventSource) {\n      throw new Error(\n        'When the `token` option is used the `EventSource` option must also be provided.'\n      )\n    }\n    if (config.EventSource === window.EventSource)\n      throw new Error(\n        'When the `token` option is used the `EventSource` option must also be provided. ' +\n          'EventSource cannot be `window.EventSource`, as it does not support passing a token.'\n      )\n  }\n\n  return groqStoreApi(config, {\n    EventSource,\n    getDocuments,\n  })\n}\n\nexport {default as groq} from 'groq'\nexport type {Subscription, GroqStore, EnvImplementations} from '../types'\n"],
  "mappings": ";;;;;;;;;AAAA;AAAA;AAAA;AAMA,WAAO,UAAU,SAAS,MAAM,GAAG,GAAG;AACpC,UAAI,MAAM;AAAG,eAAO;AAEpB,UAAI,KAAK,KAAK,OAAO,KAAK,YAAY,OAAO,KAAK,UAAU;AAC1D,YAAI,EAAE,gBAAgB,EAAE;AAAa,iBAAO;AAE5C,YAAIA,SAAQ,GAAG;AACf,YAAI,MAAM,QAAQ,CAAC,GAAG;AACpB,UAAAA,UAAS,EAAE;AACX,cAAIA,WAAU,EAAE;AAAQ,mBAAO;AAC/B,eAAK,IAAIA,SAAQ,QAAQ;AACvB,gBAAI,CAAC,MAAM,EAAE,IAAI,EAAE,EAAE;AAAG,qBAAO;AACjC,iBAAO;AAAA,QACT;AAIA,YAAI,EAAE,gBAAgB;AAAQ,iBAAO,EAAE,WAAW,EAAE,UAAU,EAAE,UAAU,EAAE;AAC5E,YAAI,EAAE,YAAY,OAAO,UAAU;AAAS,iBAAO,EAAE,QAAQ,MAAM,EAAE,QAAQ;AAC7E,YAAI,EAAE,aAAa,OAAO,UAAU;AAAU,iBAAO,EAAE,SAAS,MAAM,EAAE,SAAS;AAEjF,eAAO,OAAO,KAAK,CAAC;AACpB,QAAAA,UAAS,KAAK;AACd,YAAIA,YAAW,OAAO,KAAK,CAAC,EAAE;AAAQ,iBAAO;AAE7C,aAAK,IAAIA,SAAQ,QAAQ;AACvB,cAAI,CAAC,OAAO,UAAU,eAAe,KAAK,GAAG,KAAK,EAAE;AAAG,mBAAO;AAEhE,aAAK,IAAIA,SAAQ,QAAQ,KAAI;AAC3B,cAAI,MAAM,KAAK;AAEf,cAAI,CAAC,MAAM,EAAE,MAAM,EAAE,IAAI;AAAG,mBAAO;AAAA,QACrC;AAEA,eAAO;AAAA,MACT;AAGA,aAAO,MAAI,KAAK,MAAI;AAAA,IACtB;AAAA;AAAA;;;ACnCwB,SAAAC,KAAKC,SAAuD;AAAA,WAAA,OAAA,UAAA,QAArBC,OAAqB,IAAA,MAAA,OAAA,IAAA,OAAA,IAAA,CAAA,GAAA,OAAA,GAAA,OAAA,MAAA,QAAA;AAArBA,SAAqB,OAAA,KAAA,UAAA;EAAA;AAC5E,QAAAC,YAAYF,QAAQG,SAAS;AAEjC,SAAAH,QAAQI,MAAM,GAAGF,SAAS,EAAEG,OAAO,CAACC,KAAKC,KAAKC,MAAM;AAC3C,WAAAF,MAAMC,MAAMN,KAAKO;EACvB,GAAA,EAAE,IAAIR,QAAQE;AAErB;;;;;;ACMe,SAAA,SAAUO,OAAOC,UAAUC,SAAS;AAK9CA,MAAAA,OAAAA,WAAW,CAAA,GAJf,kBAAA,KACCC,YAAAA,aADD,oBAAA,SACc,QADd,iBAAA,iBAAA,KAECC,WAAAA,YAFD,mBAAA,SAEa,QAFb,gBAAA,oBAAA,KAGCC,cAAAA,eAHD,sBAAA,SAGgBC,SAHhB;AAUA,MAAIC;AACJ,MAAIC,YAAY;AAGhB,MAAIC,WAAW;AAGf,WAASC,uBAAuB;AAC/B,QAAIH,WAAW;AACdI,mBAAaJ,SAAD;IACZ;EACD;AAGQK,WAAAA,OAAOV,UAAS;AACSA,QAAAA,QAAAA,YAAW,CAAA,GAA5C,qBAAA,MAAQW,cAAAA,eAAR,uBAAA,SAAuB,QAAvB;AACAH,yBAAoB;AACpBF,gBAAY,CAACK;EACb;AAOD,WAASC,UAAuB;AAAA,aAAA,OAAA,UAAA,QAAZC,aAAY,IAAA,MAAA,IAAA,GAAA,OAAA,GAAA,OAAA,MAAA,QAAA;AAAZA,iBAAY,QAAA,UAAA;IAAA;AAC3BC,QAAAA,OAAO;AACX,QAAIC,UAAUC,KAAKC,IAAL,IAAaV;AAE3B,QAAID,WAAW;AACd;IACA;AAGD,aAASY,OAAO;AACfX,iBAAWS,KAAKC,IAAL;AACXlB,eAASoB,MAAML,MAAMD,UAArB;IACA;AAMD,aAASO,QAAQ;AAChBf,kBAAYD;IACZ;AAED,QAAI,CAACF,aAAaC,gBAAgB,CAACE,WAAW;AAM7Ca,WAAI;IACJ;AAEDV,yBAAoB;AAEpB,QAAIL,iBAAiBC,UAAaW,UAAUjB,OAAO;AAClD,UAAII,WAAW;AAMdK,mBAAWS,KAAKC,IAAL;AACP,YAAA,CAAChB,YAAY;AAChBI,sBAAYgB,WAAWlB,eAAeiB,QAAQF,MAAMpB,KAA9B;QACtB;MACD,OAAM;AAKNoB,aAAI;MACJ;IACD,WAAUjB,eAAe,MAAM;AAY/BI,kBAAYgB,WACXlB,eAAeiB,QAAQF,MACvBf,iBAAiBC,SAAYN,QAAQiB,UAAUjB,KAF1B;IAItB;EACD;AAEDc,UAAQF,SAASA;AAGjB,SAAOE;AACP;;;AErID,SAASU,aAAaC,SAAgB;AAC7B,SAAAA,QAAOC,QAAQ,uBAAuB,MAAM;AACrD;AAEA,SAASC,WAAWC,SAAiB;AACnC,QAAMC,KAAK,CAAA;AACX,aAAWC,QAAQF,QAAQG,MAAM,GAAG,GAAG;AACrC,QAAID,SAAS,KAAK;AAChBD,SAAGG,KAAK,OAAO;IAAA,WACNF,SAAS,MAAM;AACxBD,SAAGG,KAAK,IAAI;IAAA,OACP;AACFH,SAAAG,KAAKR,aAAaM,IAAI,CAAC;IAC5B;EACF;AAEA,SAAO,IAAIG,OAAO,IAAA,OAAIJ,GAAGK,KAAK,GAAG,GAAI,GAAA,CAAA;AACvC;AAEO,IAAMC,OAAN,MAAW;EAIhBC,YAAYR,SAAiB;AAC3B,SAAKA,UAAUA;AACV,SAAAS,YAAYV,WAAWC,OAAO;EACrC;EAEAU,QAAQC,KAAsB;AACrB,WAAA,KAAKF,UAAUG,KAAKD,GAAG;EAChC;EAEAE,SAAiB;AACf,WAAO,KAAKb;EACd;AACF;ACjCO,IAAMc,cAAN,MAAkB;EAOvBN,YAAYO,WAAuD;AANlD,SAAAC,OAAA;AAOf,SAAKD,YAAYA;AACjB,SAAKE,SAAS;AACd,SAAKC,SAAS;AACd,SAAKC,OAAO,CAAA;EACd;EAGAC,UAAmB;AACV,WAAA;EACT;EAEA,MAAMC,MAAoB;AACxB,UAAMC,SAAS,CAAA;AACf,qBAAiBC,SAAS,MAAM;AAC9BD,aAAOlB,KAAK,MAAMmB,MAAMF,IAAA,CAAK;IAC/B;AACO,WAAAC;EACT;EAEA,QAAQE,OAAOC,iBAAuD;AACpE,QAAIC,IAAI;AACR,WAAO,MAAM;AACX,aAAOA,IAAI,KAAKP,KAAKQ,QAAQD,KAAK;AAC1B,cAAA,KAAKP,KAAKO;MAClB;AAEA,UAAI,KAAKR,QAAQ;AACf;MACF;AAEA,YAAM,KAAKU,UAAU;IACvB;EACF;EAEAA,YAA2B;AACzB,QAAI,KAAKX,QAAQ;AACf,aAAO,KAAKA;IACd;AAEI,QAAAY;AACJ,UAAMC,cAAc,MAAM;AACxB,WAAKb,SAAS,IAAIc,QAASC,aAAY;AACnBH,0BAAAG;MAAA,CACnB;IAAA;AAGH,UAAMC,OAAO,MAAM;AACDJ,sBAAA;AACJC,kBAAA;IAAA;AAGd,UAAMI,SAAQ,YAAY;AACP,uBAAAX,SAAS,KAAKR,UAAA,GAAa;AACrC,aAAAI,KAAKf,KAAKmB,KAAK;AACfU,aAAA;MACP;AAEA,WAAKf,SAAS;AACTe,WAAA;IAAA;AAGKH,gBAAA;AACNI,IAAAA,OAAA;AACN,WAAO,KAAKjB;EACd;AACF;AC3EA,IAAMkB,gBAAgB;AAEf,SAASC,aAAazB,KAA0B;AACjD,MAAAwB,cAAcvB,KAAKD,GAAG,GAAG;AACpB,WAAA,IAAI0B,KAAK1B,GAAG;EACrB;AACO,SAAA;AACT;AAEO,SAAS2B,cAAcC,GAAiB;AAC7C,QAAMC,OAAOC,eAAeF,EAAEG,eAAA,GAAkB,CAAC;AACjD,QAAMC,QAAQF,eAAeF,EAAEK,YAAY,IAAI,GAAG,CAAC;AACnD,QAAMC,MAAMJ,eAAeF,EAAEO,WAAA,GAAc,CAAC;AAC5C,QAAMC,OAAON,eAAeF,EAAES,YAAA,GAAe,CAAC;AAC9C,QAAMC,SAASR,eAAeF,EAAEW,cAAA,GAAiB,CAAC;AAClD,QAAMC,SAASV,eAAeF,EAAEa,cAAA,GAAiB,CAAC;AAElD,MAAIC,mBAAmB;AACjB,QAAAC,SAASf,EAAEgB,gBAAgB;AACjC,MAAID,UAAU,GAAG;AACID,uBAAA,IAAA,OAAIZ,eAAea,QAAQ,CAAC,CAAA;EACjD;AAEA,SAAA,GAAA,OAAUd,MAAQ,GAAA,EAAA,OAAAG,OAAA,GAAA,EAAA,OAASE,KAAO,GAAA,EAAA,OAAAE,MAAA,GAAA,EAAA,OAAQE,QAAAA,GAAAA,EAAAA,OAAUE,MAAS,EAAA,OAAAE,kBAAA,GAAA;AAC/D;AAMA,SAASZ,eAAee,KAAeC,cAAsB;AACvD,MAAA9C,MAAM6C,IAAIE,SAAS;AAChB,SAAA/C,IAAIgB,SAAS8B,cAAc;AAChC9C,UAAA,IAAA,OAAUA,GAAA;EACZ;AACO,SAAAA;AACT;AC/BO,IAAMgD,cAAN,MAAyC;EAI9CnD,YAAYW,MAASH,MAAS;AAC5B,SAAKG,OAAOA;AACZ,SAAKH,OAAOA;EACd;EAEAI,UAAmB;AACjB,WAAO,KAAKJ,SAAS;EACvB;EAGA,MAAMK,MAAoB;AACxB,WAAO,KAAKF;EACd;EAEA,CAACK,OAAOC,iBAAkD;AACxD,QAAImC,MAAMxC,QAAQ,KAAKD,IAAI,GAAG;AAC5B,aAAQ,WAAWA,MAAM;AACvB,mBAAW0C,WAAW1C,MAAM;AAC1B,gBAAM2C,OAAOD,OAAO;QACtB;MAAA,EACC,KAAK1C,IAAI;IACd;AACA,UAAM,IAAI4C,MAAA,wBAAA,OAA8B,KAAK/C,IAAM,CAAA;EACrD;AACF;AAEO,IAAMgD,aAAwB,IAAIL,YAAY,MAAM,MAAM;AAC1D,IAAMM,aAA2B,IAAIN,YAAY,MAAM,SAAS;AAChE,IAAMO,cAA4B,IAAIP,YAAY,OAAO,SAAS;AAElE,IAAMQ,WAAN,MAAe;EAGpB3D,YAAY4D,MAAY;AACtB,SAAKA,OAAOA;EACd;EAEA,OAAOC,aAAa1D,KAAoB;AAChC,UAAAyD,OAAOhC,aAAazB,GAAG;AAC7B,QAAIyD,MAAM;AACR,aAAO,IAAIT,YAAY,IAAIQ,SAASC,IAAI,GAAG,UAAU;IACvD;AACO,WAAAJ;EACT;EAEAM,OAAOC,OAA0B;AAC/B,WAAO,KAAKH,KAAKI,QAAA,KAAaD,MAAMH,KAAKI,QAAQ;EACnD;EAEAC,IAAIC,MAAwB;AAC1B,UAAMC,OAAO,IAAItC,KAAK,KAAK+B,KAAKI,QAAAA,CAAS;AACzCG,SAAKC,QAAQD,KAAKH,QAAQ,IAAIE,OAAO,GAAI;AAClC,WAAA,IAAIP,SAASQ,IAAI;EAC1B;EAEAE,WAAWN,OAAyB;AAClC,YAAQ,KAAKH,KAAKI,QAAA,IAAYD,MAAMH,KAAKI,QAAAA,KAAa;EACxD;EAEAM,UAAUP,OAAyB;AACjC,WAAO,KAAKH,KAAKI,QAAA,IAAYD,MAAMH,KAAKI,QAAQ;EAClD;EAEAd,WAAmB;AACV,WAAApB,cAAc,KAAK8B,IAAI;EAChC;EAEAvD,SAAiB;AACf,WAAO,KAAK6C,SAAS;EACvB;AACF;AAEO,SAASqB,WAAWvB,KAAoB;AACzC,MAAAwB,OAAOC,SAASzB,GAAG,GAAG;AACjB,WAAA,IAAIG,YAAYH,KAAK,QAAQ;EACtC;AACO,SAAAQ;AACT;AAEO,SAASkB,WAAWvE,KAAoB;AACtC,SAAA,IAAIgD,YAAYhD,KAAK,QAAQ;AACtC;AAEO,SAASwE,aAAaC,IAAqB;AACzC,SAAA,IAAIzB,YAAYyB,IAAI,UAAU;AACvC;AAEO,SAASC,SAASC,OAAmB;AACnC,SAAA,IAAI3B,YAAY2B,OAAM,MAAM;AACrC;AAEA,SAASC,WAAWC,KAAqB;AAChC,SAAAA,OAAO,OAAOA,IAAIC,SAAS;AACpC;AAGO,SAAS3B,OAAO4B,KAAiB;AAClC,MAAAH,WAAWG,GAAG,GAAG;AACZ,WAAA,IAAI5E,YAAY,mBAAmB;AACxC,uBAAiBS,SAASmE,KAAK;AAC7B,cAAM5B,OAAOvC,KAAK;MACpB;IAAA,CACD;EACQ,WAAAmE,QAAQ,QAAQA,QAAQ,QAAW;AACrC,WAAA1B;EACT;AACA,SAAO,IAAIL,YAAY+B,KAAKC,QAAQD,GAAG,CAAC;AAC1C;AAMO,SAASC,QAAQxE,MAAqB;AAC3C,MAAIA,SAAS,QAAQ,OAAOA,SAAS,aAAa;AACzC,WAAA;EACT;AACI,MAAAyC,MAAMxC,QAAQD,IAAI,GAAG;AAChB,WAAA;EACT;AACA,MAAIA,gBAAgBZ,MAAM;AACjB,WAAA;EACT;AACA,MAAIY,gBAAgBgD,UAAU;AACrB,WAAA;EACT;AACA,SAAO,OAAOhD;AAChB;ACtIgB,SAAAyE,QAAQC,GAAUC,GAAmB;AAEhD,MAAAD,EAAE7E,SAAS,YAAY8E,EAAE9E,SAAS,YAClC6E,EAAE7E,SAAS,aAAa8E,EAAE9E,SAAS,aACnC6E,EAAE7E,SAAS,UAAU8E,EAAE9E,SAAS,UAChC6E,EAAE7E,SAAS,YAAY8E,EAAE9E,SAAS,UACnC;AACO,WAAA6E,EAAE1E,SAAS2E,EAAE3E;EACtB;AAEA,MAAI0E,EAAE7E,SAAS,cAAc8E,EAAE9E,SAAS,YAAY;AAClD,WAAO6E,EAAE1E,KAAKmD,OAAOwB,EAAE3E,IAAI;EAC7B;AAEO,SAAA;AACT;ACfA,IAAM4E,QAAQ;AACd,IAAMC,sBAAsB;AAC5B,IAAMC,aAAa;AACnB,IAAMC,kBAAkB;AAMR,SAAAC,UAAUC,QAAiBC,UAA8B;AACvE,MAAID,OAAOzE,WAAW,KAAK0E,SAAS1E,WAAW,GAAG;AACzC,WAAA;EACT;AAEA,SAAO0E,SAASC,MAAOtG,aAAYA,QAAQoG,MAAM,CAAC;AACpD;AAEO,SAASG,cAAcC,MAAuB;AAC5C,SAAAA,KAAK1G,QAAQmG,YAAY,EAAE,EAAEQ,MAAMV,KAAK,KAAK,CAAA;AACtD;AAEO,SAASW,oBAAoBF,MAAyB;AACrD,QAAAG,UAAUC,kBAAkBJ,IAAI;AACtC,SAAOG,QAAQE,IAAK5G,QAAQmG,YAAoBA,OAAOU,KAAMC,WAAU9G,GAAGW,KAAKmG,KAAK,CAAC,CAAC;AACxF;AAEO,SAASH,kBAAkBJ,MAAwB;AAClD,QAAAQ,QAAQR,KAAK1G,QAAQmG,YAAY,EAAE,EAAEQ,MAAMT,mBAAmB,KAAK,CAAA;AACzE,SAAOgB,MAAMH,IACVI,UAAS,IAAI5G,OAAA,IAAA,OAAW4G,KAAKC,MAAM,GAAGhB,eAAe,EAAEpG,QAAQ,OAAO,IAAI,GAAA,GAAA,GAAM,GAAG,CAAA;AAExF;AAEsB,eAAAqH,WAAW5F,OAAc6F,IAA6C;AACtF,MAAA7F,MAAMP,SAAS,UAAU;AAC3BoG,OAAG7F,MAAMJ,IAAI;AACN,WAAA;EACT;AAEI,MAAAI,MAAMH,QAAAA,GAAW;AACnB,QAAIiG,UAAU;AACd,qBAAiBnH,QAAQqB,OAAO;AAC1B,UAAArB,KAAKc,SAAS,UAAU;AAC1BoG,WAAGlH,KAAKiB,IAAI;MAAA,OACP;AACKkG,kBAAA;MACZ;IACF;AACO,WAAAA;EACT;AAEO,SAAA;AACT;ACpDA,IAAMC,aAA2C;EAC/CC,UAAU;EACVC,QAAQ;EACR3H,QAAQ;EACR4H,SAAS;AACX;AAGgB,SAAAC,eAAe7B,GAAQC,GAAuB;AACtD,QAAA6B,QAAQhC,QAAQE,CAAC;AACjB,QAAA+B,QAAQjC,QAAQG,CAAC;AAEvB,MAAI6B,UAAUC,OAAO;AACZ,WAAA;EACT;AAEA,UAAQD,OAAO;IACb,KAAK;IACL,KAAK;AACH,aAAO9B,IAAIC;IACb,KAAK;AACH,UAAID,IAAIC;AAAU,eAAA;AAClB,UAAID,IAAIC;AAAU,eAAA;AACX,aAAA;IACT,KAAK;AACI,aAAAD,EAAEf,UAAUgB,CAAC;IACtB;AACS,aAAA;EAAA;AAEb;AAGgB,SAAA+B,aAAahC,GAAQC,GAAgB;AAC7C,QAAA6B,QAAQhC,QAAQE,CAAC;AACjB,QAAA+B,QAAQjC,QAAQG,CAAC;AAEjB,QAAAgC,aAAaR,WAAWK,UAAU;AAClC,QAAAI,aAAaT,WAAWM,UAAU;AAExC,MAAIE,eAAeC,YAAY;AAC7B,WAAOD,aAAaC;EACtB;AAEI,MAAAzG,SAASoG,eAAe7B,GAAGC,CAAC;AAChC,MAAIxE,WAAW,MAAM;AACVA,aAAA;EACX;AACO,SAAAA;AACT;AChCO,IAAM0G,YAA+C;EAC1D,MAAM,SAASC,GAAGC,MAAMC,OAAO;AAC7B,WAAOvC,QAAQsC,MAAMC,KAAK,IAAIlE,aAAaC;EAC7C;EAEA,MAAM,SAASkE,IAAIF,MAAMC,OAAO;AAC9B,WAAOvC,QAAQsC,MAAMC,KAAK,IAAIjE,cAAcD;EAC9C;EAEA,KAAK,SAASoE,GAAGH,MAAMC,OAAO;AAC5B,QAAID,KAAKlH,SAAS,YAAYmH,MAAMnH,SAAS;AAAiB,aAAAgD;AAC9D,UAAM1C,SAASoG,eAAeQ,KAAK/G,MAAMgH,MAAMhH,IAAI;AAEnD,QAAIG,WAAW,MAAM;AACZ,aAAA0C;IACT;AACO,WAAA1C,SAAS,IAAI2C,aAAaC;EACnC;EAEA,MAAM,SAASoE,IAAIJ,MAAMC,OAAO;AAC9B,QAAID,KAAKlH,SAAS,YAAYmH,MAAMnH,SAAS;AAAiB,aAAAgD;AAC9D,UAAM1C,SAASoG,eAAeQ,KAAK/G,MAAMgH,MAAMhH,IAAI;AAEnD,QAAIG,WAAW,MAAM;AACZ,aAAA0C;IACT;AACO,WAAA1C,UAAU,IAAI2C,aAAaC;EACpC;EAEA,KAAK,SAASqE,GAAGL,MAAMC,OAAO;AAC5B,QAAID,KAAKlH,SAAS,YAAYmH,MAAMnH,SAAS;AAAiB,aAAAgD;AAC9D,UAAM1C,SAASoG,eAAeQ,KAAK/G,MAAMgH,MAAMhH,IAAI;AAEnD,QAAIG,WAAW,MAAM;AACZ,aAAA0C;IACT;AACO,WAAA1C,SAAS,IAAI2C,aAAaC;EACnC;EAEA,MAAM,SAASsE,IAAIN,MAAMC,OAAO;AAC9B,QAAID,KAAKlH,SAAS,YAAYmH,MAAMnH,SAAS;AAAiB,aAAAgD;AAC9D,UAAM1C,SAASoG,eAAeQ,KAAK/G,MAAMgH,MAAMhH,IAAI;AAEnD,QAAIG,WAAW,MAAM;AACZ,aAAA0C;IACT;AACO,WAAA1C,UAAU,IAAI2C,aAAaC;EACpC;EAGAuE,IAAI,eAAeC,KAAKR,MAAMC,OAAO;AAC/B,QAAAA,MAAMnH,SAAS,QAAQ;AACrB,UAAAkH,KAAKlH,SAAS,UAAU;AACnB,eAAAgD;MACT;AAEA,aAAOmE,MAAMhH,KAAKT,QAAQwH,KAAK/G,IAAI,IAAI8C,aAAaC;IACtD;AAEI,QAAAiE,MAAM/G,QAAAA,GAAW;AACnB,uBAAiB0E,KAAKqC,OAAO;AACvB,YAAAvC,QAAQsC,MAAMpC,CAAC,GAAG;AACb,iBAAA7B;QACT;MACF;AAEO,aAAAC;IACT;AAEO,WAAAF;EACT;EAEAyC,OAAO,eAAeA,MAAMyB,MAAMC,OAAO;AACvC,QAAI/B,SAAkB,CAAA;AACtB,QAAIC,WAAsB,CAAA;AAEpB,UAAAc,WAAWe,MAAOhI,UAAS;AAC/BkG,eAASA,OAAOuC,OAAOpC,cAAcrG,IAAI,CAAC;IAAA,CAC3C;AAED,UAAM0I,aAAa,MAAMzB,WAAWgB,OAAQjI,UAAS;AACnDmG,iBAAWA,SAASsC,OAAOjC,oBAAoBxG,IAAI,CAAC;IAAA,CACrD;AACD,QAAI,CAAC0I,YAAY;AACR,aAAA1E;IACT;AAEM,UAAA2E,UAAU1C,UAAUC,QAAQC,QAAQ;AAE1C,WAAOwC,UAAU5E,aAAaC;EAChC;EAEA,KAAK,SAAS4E,KAAKZ,MAAMC,OAAO;AAC9B,QAAID,KAAKlH,SAAS,cAAcmH,MAAMnH,SAAS,UAAU;AACvD,aAAOmE,aAAa+C,KAAK/G,KAAKsD,IAAI0D,MAAMhH,IAAI,CAAC;IAC/C;AAEA,QAAI+G,KAAKlH,SAAS,YAAYmH,MAAMnH,SAAS,UAAU;AACrD,aAAO+D,WAAWmD,KAAK/G,OAAOgH,MAAMhH,IAAI;IAC1C;AAEA,QAAI+G,KAAKlH,SAAS,YAAYmH,MAAMnH,SAAS,UAAU;AACrD,aAAOkE,WAAWgD,KAAK/G,OAAOgH,MAAMhH,IAAI;IAC1C;AAEA,QAAI+G,KAAKlH,SAAS,YAAYmH,MAAMnH,SAAS,UAAU;AAC9C,aAAA8C,OAAO;QAAC,GAAGoE,KAAK/G;QAAM,GAAGgH,MAAMhH;OAAK;IAC7C;AAEA,QAAI+G,KAAKlH,SAAS,WAAWmH,MAAMnH,SAAS,SAAS;AACnD,aAAO8C,OAAOoE,KAAK/G,KAAKwH,OAAOR,MAAMhH,IAAI,CAAC;IAC5C;AAEA,QAAI+G,KAAK9G,QAAA,KAAa+G,MAAM/G,QAAAA,GAAW;AAC9B,aAAA,IAAIN,YAAY,mBAAmB;AACxC,yBAAiB4E,OAAOwC,MAAM;AACtB,gBAAAxC;QACR;AAEA,yBAAiBA,OAAOyC,OAAO;AACvB,gBAAAzC;QACR;MAAA,CACD;IACH;AAEO,WAAA1B;EACT;EAEA,KAAK,SAAS+E,MAAMb,MAAMC,OAAO;AAC/B,QAAID,KAAKlH,SAAS,cAAcmH,MAAMnH,SAAS,UAAU;AACvD,aAAOmE,aAAa+C,KAAK/G,KAAKsD,IAAI,CAAC0D,MAAMhH,IAAI,CAAC;IAChD;AAEA,QAAI+G,KAAKlH,SAAS,cAAcmH,MAAMnH,SAAS,YAAY;AACzD,aAAO+D,WAAWmD,KAAK/G,KAAK0D,WAAWsD,MAAMhH,IAAI,CAAC;IACpD;AAEA,QAAI+G,KAAKlH,SAAS,YAAYmH,MAAMnH,SAAS,UAAU;AACrD,aAAO+D,WAAWmD,KAAK/G,OAAOgH,MAAMhH,IAAI;IAC1C;AAEO,WAAA6C;EACT;EAEA,KAAKgF,gBAAgB,CAACnD,GAAGC,MAAMD,IAAIC,CAAC;EACpC,KAAKkD,gBAAgB,CAACnD,GAAGC,MAAMD,IAAIC,CAAC;EACpC,KAAKkD,gBAAgB,CAACnD,GAAGC,MAAMD,IAAIC,CAAC;EACpC,MAAMkD,gBAAgB,CAACnD,GAAGC,MAAMmD,KAAKC,IAAIrD,GAAGC,CAAC,CAAC;AAChD;AAEA,SAASkD,gBAAgBG,MAAwD;AACxE,SAAA,SAAUjB,MAAMC,OAAO;AAC5B,QAAID,KAAKlH,SAAS,YAAYmH,MAAMnH,SAAS,UAAU;AACrD,YAAMM,SAAS6H,KAAKjB,KAAK/G,MAAMgH,MAAMhH,IAAI;AACzC,aAAO4D,WAAWzD,MAAM;IAC1B;AAEO,WAAA0C;EAAA;AAEX;AC9KO,IAAMoF,QAAN,MAAY;EASjB5I,YACE6I,QACAC,QACA/H,OACAgI,SACAC,QACA;AATF,SAAOC,WAAW;AAUhB,SAAKJ,SAASA;AACd,SAAKC,SAASA;AACd,SAAK/H,QAAQA;AACb,SAAKgI,UAAUA;AACf,SAAKC,SAASA;EAChB;EAEAE,aAAanI,OAAqB;AAChC,QAAI,KAAKkI,UAAU;AACV,aAAA,IAAIL,MAAM,KAAKC,QAAQ,KAAKC,QAAQ/H,OAAO,KAAKgI,SAAS,KAAKC,MAAM;IAC7E;AACO,WAAA,IAAIJ,MAAM,KAAKC,QAAQ,KAAKC,QAAQ/H,OAAO,KAAKgI,SAAS,IAAI;EACtE;EAEAI,aAAapI,OAAqB;AAC1B,UAAAD,SAAS,KAAKoI,aAAanI,KAAK;AACtCD,WAAOmI,WAAW;AACX,WAAAnI;EACT;AACF;ACvBO,SAASsI,SACdC,MACAC,OAE4B;AAAA,MAD5BC,UAAA,UAAA,SAAA,KAAA,UAAA,OAAA,SAAA,UAAA,KAAoBH;AAEd,QAAAI,OAAOC,UAAUJ,KAAK7I;AACrB,SAAAgJ,KAAKH,MAAaC,OAAOC,OAAO;AACzC;AAeA,SAASG,iBACP3I,OACA6F,IAC4B;AAC5B,MAAI,UAAU7F,OAAO;AACZ,WAAAA,MAAM4I,KAAK/C,EAAE;EACtB;AAEA,SAAOA,GAAG7F,KAAK;AACjB;AAEA,IAAM0I,YAAyB;EAC7BG,KAAKC,GAAGP,OAAO;AACb,WAAOA,MAAMvI;EACf;EAEA+I,WAAW;AAGH,UAAA,IAAIvG,MAAM,gCAAgC;EAClD;EAEAwG,WAAWF,GAAGP,OAAO;AACnB,WAAOA,MAAMR;EACf;EAEAkB,UAAU,MAAQV,OAAO;AAAA,QAAf;MAACW;IAAI,IAAA;AACb,WAAO3G,OAAOgG,MAAMT,OAAOoB,KAAK;EAClC;EAEAC,QAAQ,OAAOZ,OAAO;AAAA,QAAd;MAACa;IAAG,IAAA;AACN,QAAAA,QAAQ,YAAYA,QAAQ,SAAS;AACjC,YAAApJ,QAAQuI,MAAMP,QAAQoB;AAC5B,aAAOpJ,SAASyC;IAClB;AACM,UAAA,IAAID,MAAM,wBAAA,OAAwB4G,GAAK,CAAA;EAC/C;EAEAC,OAAO,OAAKd,OAAO;AAAA,QAAZ;MAACe;IAAC,IAAA;AACP,QAAIC,UAAUhB;AACd,aAASpI,IAAI,GAAGA,IAAImJ,GAAGnJ,KAAK;AACtB,UAAA,CAACoJ,QAAQtB,QAAQ;AACZ,eAAAxF;MACT;AAEA8G,gBAAUA,QAAQtB;IACpB;AACA,WAAOsB,QAAQvJ;EACjB;EAEAwJ,OAAAA,OAA0BjB,OAAOC,SAAS;AAAA,QAAnC;MAACiB;MAAI9C;MAAMC;IAAK,IAAA;AACf,UAAA6B,OAAOhC,UAAUgD;AACvB,QAAI,CAAChB,MAAM;AACH,YAAA,IAAIjG,MAAM,qBAAA,OAAqBiH,EAAI,CAAA;IAC3C;AACM,UAAAC,YAAYlB,QAAQ7B,MAAM4B,KAAK;AAC/B,UAAAoB,aAAanB,QAAQ5B,OAAO2B,KAAK;AAInC,QAAA,UAAUmB,aAAa,UAAUC,YAAY;AAC/C,cAAQ,YAAYlB,KAAK,MAAMiB,WAAW,MAAMC,UAAU,GAAG;IAC/D;AAEO,WAAAlB,KAAKiB,WAAWC,UAAU;EACnC;EAEA,MAAMC,OAAO,OAA0BrB,OAAOC,SAAS;AAAA,QAA1C;MAACqB;MAAcC;IAAQ,IAAA;AAClC,eAAWC,OAAOF,cAAc;AAC9B,YAAMG,UAAU,MAAMxB,QAAQuB,IAAIE,WAAW1B,KAAK;AAClD,UAAIyB,QAAQvK,SAAS,aAAauK,QAAQpK,SAAS,MAAM;AAChD,eAAA4I,QAAQuB,IAAI/J,OAAOuI,KAAK;MACjC;IACF;AAEA,QAAIuB,UAAU;AACL,aAAAtB,QAAQsB,UAAUvB,KAAK;IAChC;AAEO,WAAA9F;EACT;EAEA,MAAMyH,QAAAA,OAA0C3B,OAAOC,SAAS;AAAA,QAAlD;MAAC2B;MAAMxD;MAAMC;MAAOwD;IAAc,IAAA;AAC9C,UAAMpK,QAAQ,MAAMwI,QAAQ2B,MAAM5B,KAAK;AACvC,UAAMmB,YAAY,MAAMlB,QAAQ7B,MAAM4B,KAAK;AAC3C,UAAMoB,aAAa,MAAMnB,QAAQ5B,OAAO2B,KAAK;AAEvC,UAAA8B,UAAUlE,eAAe,MAAMnG,MAAMF,IAAAA,GAAO,MAAM4J,UAAU5J,IAAA,CAAK;AACvE,QAAIuK,YAAY,MAAM;AACb,aAAA5H;IACT;AACM,UAAA6H,WAAWnE,eAAe,MAAMnG,MAAMF,IAAAA,GAAO,MAAM6J,WAAW7J,IAAA,CAAK;AACzE,QAAIwK,aAAa,MAAM;AACd,aAAA7H;IACT;AAEA,QAAI2H,aAAa;AACf,aAAOC,WAAW,KAAKC,YAAY,IAAI5H,aAAaC;IACtD;AAEA,WAAO0H,WAAW,KAAKC,WAAW,IAAI5H,aAAaC;EACrD;EAEA,MAAM4H,OAAO,OAAchC,OAAOC,SAAS;AAAA,QAA9B;MAAC2B;MAAMK;IAAI,IAAA;AACtB,UAAMC,YAAY,MAAMjC,QAAQ2B,MAAM5B,KAAK;AACvC,QAAA,CAACkC,UAAU5K,QAAA,GAAW;AACjB,aAAA4C;IACT;AACO,WAAA,IAAIlD,YAAY,mBAAmB;AACxC,uBAAiBmL,QAAQD,WAAW;AAC5B,cAAAE,WAAWpC,MAAMJ,aAAauC,IAAI;AACxC,cAAME,YAAY,MAAMpC,QAAQgC,MAAMG,QAAQ;AAC9C,YAAIC,UAAUnL,SAAS,aAAamL,UAAUhL,SAAS,MAAM;AACrD,gBAAA8K;QACR;MACF;IAAA,CACD;EACH;EAEA,MAAMG,WAAW,OAActC,OAAOC,SAAS;AAAA,QAA9B;MAAC2B;MAAMK;IAAI,IAAA;AAC1B,UAAMC,YAAY,MAAMjC,QAAQ2B,MAAM5B,KAAK;AACvC,QAAAkC,UAAUhL,SAAS,UAAU;AACxB,aAAAgD;IACT;AAEM,UAAAkI,WAAWpC,MAAMJ,aAAasC,SAAS;AACtC,WAAAjC,QAAQgC,MAAMG,QAAQ;EAC/B;EAEAG,SAAAA,OAAqCvC,OAAcC,SAAS;AAAA,QAAnD;MAACC;MAAMsC;IAAI,IAAA;AACX,WAAAtC,KAAKsC,MAAMxC,OAAOC,OAAO;EAClC;EAEA,MAAMwC,aAAAA,QAAmDzC,OAAcC,SAAS;AAAA,QAA7D;MAACC;MAAM0B;MAAMY;IAAI,IAAA;AAClC,UAAMN,YAAY,MAAMjC,QAAQ2B,MAAM5B,KAAK;AAC3C,WAAOE,KAAKgC,WAAWM,MAAMxC,OAAOC,OAAO;EAC7C;EAEA,MAAMyC,gBAAgB,QAAc1C,OAAOC,SAAS;AAAA,QAA9B;MAAC2B;MAAMjB;IAAI,IAAA;AAC/B,QAAIlJ,QAAQuI,MAAMvI;AAClB,QAAImK,MAAM;AACAnK,cAAA,MAAMwI,QAAQ2B,MAAM5B,KAAK;IACnC;AACI,QAAAvI,MAAMP,SAAS,UAAU;AAC3B,UAAIO,MAAMJ,KAAKsL,eAAehC,IAAI,GAAG;AACnC,eAAO3G,OAAOvC,MAAMJ,KAAKsJ,KAAK;MAChC;IACF;AAEO,WAAAzG;EACT;EAEA,MAAM0I,cAAc,QAAe5C,OAAOC,SAAS;AAAA,QAA/B;MAAC2B;MAAMiB;IAAK,IAAA;AAC9B,UAAMX,YAAY,MAAMjC,QAAQ2B,MAAM5B,KAAK;AACvC,QAAA,CAACkC,UAAU5K,QAAA,GAAW;AACjB,aAAA4C;IACT;AAEM,UAAA7C,OAAO,MAAM6K,UAAU3K,IAAI;AACjC,UAAMuL,aAAaD,QAAQ,IAAIA,QAAQxL,KAAKQ,SAASgL;AAC9C,WAAA7I,OAAO3C,KAAKyL,WAAW;EAChC;EAEA,MAAMC,MAAAA,QAAwC/C,OAAOC,SAAS;AAAA,QAAlD;MAAC2B;MAAMxD;MAAMC;MAAOwD;IAAc,IAAA;AAC5C,UAAMK,YAAY,MAAMjC,QAAQ2B,MAAM5B,KAAK;AAEvC,QAAA,CAACkC,UAAU5K,QAAA,GAAW;AACjB,aAAA4C;IACT;AAGM,UAAA8I,SAAS,MAAMd,UAAU3K,IAAI;AAEnC,QAAI0L,UAAU7E;AACd,QAAI8E,WAAW7E;AAGf,QAAI4E,UAAU,GAAG;AACfA,gBAAUD,OAAMnL,SAASoL;IAC3B;AACA,QAAIC,WAAW,GAAG;AAChBA,iBAAWF,OAAMnL,SAASqL;IAC5B;AAGA,QAAIrB,aAAa;AACfqB;IACF;AAEA,QAAID,UAAU,GAAG;AACLA,gBAAA;IACZ;AACA,QAAIC,WAAW,GAAG;AACLA,iBAAA;IACb;AAKA,WAAOlJ,OAAOgJ,OAAM5F,MAAM6F,SAASC,QAAQ,CAAC;EAC9C;EAEA,MAAMC,MAAM,QAAQnD,OAAOC,SAAS;AAAA,QAAxB;MAAC2B;QAAI;AACf,UAAMnK,QAAQ,MAAMwI,QAAQ2B,MAAM5B,KAAK;AAEvC,QAAI,CAACA,MAAMR,OAAOlI,QAAA,GAAW;AACpB,aAAA4C;IACT;AAEI,QAAAzC,MAAMP,SAAS,UAAU;AACpB,aAAAgD;IACT;AAEM,UAAAkJ,KAAK3L,MAAMJ,KAAKgM;AAClB,QAAA,OAAOD,OAAO,UAAU;AACnB,aAAAlJ;IACT;AAEiB,qBAAAoJ,OAAOtD,MAAMR,QAAQ;AACpC,UAAI8D,IAAIpM,SAAS,YAAYkM,OAAOE,IAAIjM,KAAKkM,KAAK;AACzC,eAAAD;MACT;IACF;AAEO,WAAApJ;EACT;EAEAsJ,MAAA,QAAe;AAAA,QAAT;MAAC/L;QAAQ;AACb,WAAOuC,OAAOvC,KAAK;EACrB;EAEAgM,MAAM,QAAQzD,OAAOC,SAAS;AAAA,QAAxB;MAAC2B;QAAI;AACF,WAAA3B,QAAQ2B,MAAM5B,KAAK;EAC5B;EAEA,MAAM0D,OAAO,QAAc1D,OAAOC,SAAS;AAAA,QAA9B;MAAC0D;QAAU;AACtB,UAAMnM,SAA+B,CAAA;AACrC,eAAWoM,QAAQD,YAAY;AAC7B,YAAME,WAAWD,KAAK1M;AACtB,cAAQ0M,KAAK1M,MAAM;QACjB,KAAK,wBAAwB;AAC3B,gBAAMO,QAAQ,MAAMwI,QAAQ2D,KAAKnM,OAAOuI,KAAK;AAC7CxI,iBAAOoM,KAAKjD,QAAQ,MAAMlJ,MAAMF,IAAI;AACpC;QACF;QAEA,KAAK,0BAA0B;AAC7B,gBAAMuM,OAAO,MAAM7D,QAAQ2D,KAAKlC,WAAW1B,KAAK;AAChD,cAAI8D,KAAK5M,SAAS,aAAa4M,KAAKzM,SAAS,OAAO;AAClD;UACF;AAEA,gBAAMI,QAAQ,MAAMwI,QAAQ2D,KAAKnM,OAAOuI,KAAK;AACzC,cAAAvI,MAAMP,SAAS,UAAU;AACpBwM,mBAAAK,OAAOvM,QAAQC,MAAMJ,IAAI;UAClC;AACA;QACF;QAEA,KAAK,eAAe;AAClB,gBAAMI,QAAQ,MAAMwI,QAAQ2D,KAAKnM,OAAOuI,KAAK;AACzC,cAAAvI,MAAMP,SAAS,UAAU;AACpBwM,mBAAAK,OAAOvM,QAAQC,MAAMJ,IAAI;UAClC;AACA;QACF;QAEA;AACQ,gBAAA,IAAI4C,MAAM,sBAAA,OAAsB4J,QAAU,CAAA;MAAA;IAEtD;AACA,WAAO7J,OAAOxC,MAAM;EACtB;EAEAsC,MAAM,QAAYkG,OAAOC,SAAS;AAAA,QAA5B;MAAC+D;QAAQ;AACN,WAAA,IAAIhN,YAAY,mBAAmB;AACxC,iBAAW+C,WAAWiK,UAAU;AAC9B,cAAMvM,QAAQ,MAAMwI,QAAQlG,QAAQtC,OAAOuI,KAAK;AAChD,YAAIjG,QAAQkK,SAAS;AACf,cAAAxM,MAAMH,QAAAA,GAAW;AACnB,6BAAiB4M,KAAKzM,OAAO;AACrB,oBAAAyM;YACR;UACF;QAAA,OACK;AACC,gBAAAzM;QACR;MACF;IAAA,CACD;EACH;EAEA0M,QAAQ;AACA,UAAA,IAAIlK,MAAM,6BAA6B;EAC/C;EAEA,MAAMmK,GAAG,QAAepE,OAAOC,SAAS;AAAA,QAA/B;MAAC7B;MAAMC;IAAK,IAAA;AACnB,UAAM8C,YAAY,MAAMlB,QAAQ7B,MAAM4B,KAAK;AAC3C,UAAMoB,aAAa,MAAMnB,QAAQ5B,OAAO2B,KAAK;AAEzC,QAAAmB,UAAUjK,SAAS,WAAW;AAC5B,UAAAiK,UAAU9J,SAAS,MAAM;AACpB,eAAA8C;MACT;IACF;AAEI,QAAAiH,WAAWlK,SAAS,WAAW;AAC7B,UAAAkK,WAAW/J,SAAS,MAAM;AACrB,eAAA8C;MACT;IACF;AAEA,QAAIgH,UAAUjK,SAAS,aAAakK,WAAWlK,SAAS,WAAW;AAC1D,aAAAgD;IACT;AAEO,WAAAE;EACT;EAEA,MAAMiK,IAAI,QAAerE,OAAOC,SAAS;AAAA,QAA/B;MAAC7B;MAAMC;IAAK,IAAA;AACpB,UAAM8C,YAAY,MAAMlB,QAAQ7B,MAAM4B,KAAK;AAC3C,UAAMoB,aAAa,MAAMnB,QAAQ5B,OAAO2B,KAAK;AAEzC,QAAAmB,UAAUjK,SAAS,WAAW;AAC5B,UAAAiK,UAAU9J,SAAS,OAAO;AACrB,eAAA+C;MACT;IACF;AAEI,QAAAgH,WAAWlK,SAAS,WAAW;AAC7B,UAAAkK,WAAW/J,SAAS,OAAO;AACtB,eAAA+C;MACT;IACF;AAEA,QAAI+G,UAAUjK,SAAS,aAAakK,WAAWlK,SAAS,WAAW;AAC1D,aAAAgD;IACT;AAEO,WAAAC;EACT;EAEA,MAAMmK,IAAI,QAAQtE,OAAOC,SAAS;AAAA,QAAxB;MAAC2B;QAAI;AACb,UAAMnK,QAAQ,MAAMwI,QAAQ2B,MAAM5B,KAAK;AACnC,QAAAvI,MAAMP,SAAS,WAAW;AACrB,aAAAgD;IACT;AACO,WAAAzC,MAAMJ,OAAO+C,cAAcD;EACpC;EAEAoK,IAAI,QAAQvE,OAAOC,SAAS;AAAA,QAAxB;MAAC2B;QAAI;AACP,WAAOxB,iBAAiBH,QAAQ2B,MAAM5B,KAAK,GAAIvI,WAAU;AACnD,UAAAA,MAAMP,SAAS,UAAU;AACpB,eAAAgD;MACT;AACO,aAAAe,WAAW,CAACxD,MAAMJ,IAAI;IAAA,CAC9B;EACH;EAEAmN,IAAI,QAAQxE,OAAOC,SAAS;AAAA,QAAxB;MAAC2B;QAAI;AACP,WAAOxB,iBAAiBH,QAAQ2B,MAAM5B,KAAK,GAAIvI,WAAU;AACnD,UAAAA,MAAMP,SAAS,UAAU;AACpB,eAAAgD;MACT;AACO,aAAAe,WAAWxD,MAAMJ,IAAI;IAAA,CAC7B;EACH;EAEAoN,MAAM;AACG,WAAAvK;EACT;EAEAwK,OAAO;AACE,WAAAxK;EACT;EAEA,MAAMyK,YAAY,QAAQ3E,OAAOC,SAAS;AAAA,QAAxB;MAAC2B;QAAI;AACrB,UAAMnK,QAAQ,MAAMwI,QAAQ2B,MAAM5B,KAAK;AAChC,WAAAvI,MAAMH,QAAQ,IAAIG,QAAQyC;EACnC;EAEA,MAAM0K,IAAI,QAAc5E,OAAOC,SAAS;AAAA,QAA9B;MAAC2B;MAAMK;IAAI,IAAA;AACnB,UAAMxK,QAAQ,MAAMwI,QAAQ2B,MAAM5B,KAAK;AACnC,QAAA,CAACvI,MAAMH,QAAA,GAAW;AACb,aAAA4C;IACT;AAEO,WAAA,IAAIlD,YAAY,mBAAmB;AACxC,uBAAiBmL,QAAQ1K,OAAO;AACxB,cAAA2K,WAAWpC,MAAMH,aAAasC,IAAI;AAClC,cAAA,MAAMlC,QAAQgC,MAAMG,QAAQ;MACpC;IAAA,CACD;EACH;EAEA,MAAMyC,QAAQ,QAAc7E,OAAOC,SAAS;AAAA,QAA9B;MAAC2B;MAAMK;IAAI,IAAA;AACvB,UAAMxK,QAAQ,MAAMwI,QAAQ2B,MAAM5B,KAAK;AACnC,QAAA,CAACvI,MAAMH,QAAA,GAAW;AACb,aAAA4C;IACT;AAEO,WAAA,IAAIlD,YAAY,mBAAmB;AACxC,uBAAiBmL,QAAQ1K,OAAO;AACxB,cAAA2K,WAAWpC,MAAMH,aAAasC,IAAI;AACxC,cAAM2C,aAAa,MAAM7E,QAAQgC,MAAMG,QAAQ;AAC3C,YAAA0C,WAAWxN,QAAAA,GAAW;AACxB,2BAAiByN,SAASD,YAAY;AAC9B,kBAAAC;UACR;QAAA,OACK;AACC,gBAAAD;QACR;MACF;IAAA,CACD;EACH;AACF;AAKO,SAASE,cACdC,MAE4B;AAAA,MAD5BC,UAA2B,UAAA,SAAA,KAAA,UAAA,OAAA,SAAA,UAAA,KAAA,CAAA;AAErB,QAAAC,OAAOnL,OAAOkL,QAAQC,IAAI;AAC1B,QAAAC,UAAUpL,OAAOkL,QAAQE,OAAO;AACtC,QAAM7F,SAA+B;IAAC,GAAG2F,QAAQ3F;EAAM;AAEvD,QAAMS,QAAQ,IAAIV,MAChBC,QACA6F,SACAD,MACA;IACEE,WAAWH,QAAQG,aAAa,oBAAI9M,KAAK;IACzC+M,UAAUJ,QAAQI,aAAa,SAAY,OAAOJ,QAAQI;IAC1DC,QAAQL,QAAQK;IAChBC,OAAON,QAAQM,QAAQxL,OAAOkL,QAAQM,KAAK,IAAI;IAC/CC,QAAQP,QAAQO,SAASzL,OAAOkL,QAAQO,MAAM,IAAI;EACpD,GACA,IAAA;AAEK,SAAA3F,SAASmF,MAAMjF,KAAK;AAC7B;ACzdA,SAAS0F,oBAAoB3F,MAAyB;AACpD,UAAQA,KAAK7I,MAAM;IACjB,KAAK;IACL,KAAK;IACL,KAAK;AACI,aAAA;IACT,KAAK;IACL,KAAK;AACI,aAAAwO,oBAAoB3F,KAAK6B,IAAI;IACtC,KAAK;AACH,cAAQ7B,KAAKmB,IAAI;QACf,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;AACH,iBAAOwE,oBAAoB3F,KAAK3B,IAAI,KAAKsH,oBAAoB3F,KAAK1B,KAAK;QACzE;AACS,iBAAA;MAAA;IAEb;AACS,aAAA;EAAA;AAEb;AAEA,IAAMsH,cAAc,IAAIrG,MACtB,CAAC,GACDpF,YACAA,YACA;EAACmL,WAAW,oBAAI9M,KAAK,CAAC;EAAG+M,UAAU;EAAMG,QAAQ;EAAMD,OAAO;AAAI,GAClE,IAAA;AAGK,SAASI,oBAAoB7F,MAA8B;AAC5D,MAAA,CAAC2F,oBAAoB3F,IAAI,GAAG;AACvB,WAAA;EACT;AAEA,SAAO8F,iBAAiB9F,IAAI;AAC9B;AAEA,SAAS8F,iBAAiB9F,MAAuB;AAC/C,QAAMtI,QAAQqI,SAASC,MAAM4F,aAAaE,gBAAgB;AAC1D,MAAI,UAAUpO,OAAO;AACb,UAAA,IAAIwC,MAAM,sDAAsD;EACxE;AACO,SAAAxC;AACT;ACnDA,eAAsBqO,oBAAoBrO,OAAsC;AAC1E,MAAAA,MAAMP,SAAS,UAAU;AACpB,WAAA6O,UAAUtO,MAAMJ,IAAI;EAAA,WAClBI,MAAMH,QAAA,GAAW;AACpB,UAAA0O,QAAQ,MAAMC,UAAUxO,KAAK;AAC/B,QAAAuO,MAAMnO,SAAS,GAAG;AACb,aAAAmO,MAAMxP,KAAK,MAAM;IAC1B;EACF;AAEO,SAAA;AACT;AAEA,eAAeyP,UAAUxO,OAAwD;AAAA,MAA1CD,SAAmB,UAAA,SAAA,KAAA,UAAA,OAAA,SAAA,UAAA,KAAA,CAAA;AACxD,mBAAiB0O,SAASzO,OAAO;AAC3B,QAAAyO,MAAMhP,SAAS,UAAU;AACrB,YAAAwF,OAAOqJ,UAAUG,MAAM7O,IAAI;AACjC,UAAIqF,SAAS;AAAMlF,eAAOlB,KAAKoG,IAAI;IAAA,WAC1BwJ,MAAM5O,QAAA,GAAW;AACpB,YAAA2O,UAAUC,OAAO1O,MAAM;IAC/B;EACF;AAEO,SAAAA;AACT;AAEA,SAASuO,UAAUrK,KAA6C;AAC1D,MAAA,OAAOA,IAAIyK,UAAU;AAAiB,WAAA;AAC1C,QAAMC,WAAW1K,IAAI0K;AACjB,MAAA,CAACtM,MAAMxC,QAAQ8O,QAAQ;AAAU,WAAA;AAErC,MAAI5O,SAAS;AACb,aAAW6O,SAASD,UAAU;AAC5B,QACEC,SACA,OAAOA,UAAU,YACjB,OAAOA,MAAMF,UAAU,YACvBE,MAAMF,UAAU,UAChB,OAAOE,MAAM3J,SAAS,UACtB;AACAlF,gBAAU6O,MAAM3J;IAClB;EACF;AACO,SAAAlF;AACT;ACxCA,IAAM8O,QAAQ;AAEQ,eAAAC,cACpBxG,MACAC,OACAC,SACiB;AACjB,MAAIF,KAAK7I,SAAS,YAAY6I,KAAKmB,OAAO,SAAS;AACjD,WAAOsF,mBAAmBzG,KAAK3B,MAAM2B,KAAK1B,OAAO2B,OAAOC,OAAO;EACjE;AAEA,MAAIF,KAAK7I,SAAS,cAAc6I,KAAKY,SAAS,SAAS;AAC/C,UAAA8F,aAAa,MAAMF,cAAcxG,KAAKyC,KAAK,IAAIxC,OAAOC,OAAO;AACnE,UAAMyG,SAAQ,MAAMzG,QAAQF,KAAKyC,KAAK,IAAIxC,KAAK;AAC/C,QAAI0G,OAAMxP,SAAS,YAAYuP,aAAa,GAAG;AAC7C,aAAOA,aAAaC,OAAMrP;IAC5B;AAEO,WAAA;EACT;AAEA,UAAQ0I,KAAK7I,MAAM;IACjB,KAAK,MAAM;AACT,YAAMyP,YAAY,MAAMJ,cAAcxG,KAAK3B,MAAM4B,OAAOC,OAAO;AAC/D,YAAM2G,aAAa,MAAML,cAAcxG,KAAK1B,OAAO2B,OAAOC,OAAO;AACjE,aAAO0G,YAAYC;IACrB;IACA,KAAK,OAAO;AACV,YAAMD,YAAY,MAAMJ,cAAcxG,KAAK3B,MAAM4B,OAAOC,OAAO;AAC/D,YAAM2G,aAAa,MAAML,cAAcxG,KAAK1B,OAAO2B,OAAOC,OAAO;AAC7D,UAAA0G,cAAc,KAAKC,eAAe;AAAU,eAAA;AAChD,aAAOD,YAAYC;IACrB;IACA,SAAS;AACP,YAAMC,MAAM,MAAM5G,QAAQF,MAAMC,KAAK;AACrC,aAAO6G,IAAI3P,SAAS,aAAa2P,IAAIxP,SAAS,OAAO,IAAI;IAC3D;EAAA;AAEJ;AAEA,eAAemP,mBACbpI,MACAC,OACA2B,OACAC,SACiB;AACjB,QAAMvD,OAAO,MAAMuD,QAAQ7B,MAAM4B,KAAK;AACtC,QAAM9J,UAAU,MAAM+J,QAAQ5B,OAAO2B,KAAK;AAE1C,MAAI1D,SAAkB,CAAA;AACtB,MAAIY,QAAkB,CAAA;AAEhB,QAAAG,WAAWX,MAAOtG,UAAS;AAC/BkG,aAASA,OAAOuC,OAAOpC,cAAcrG,IAAI,CAAC;EAAA,CAC3C;AAED,QAAM0I,aAAa,MAAMzB,WAAWnH,SAAUE,UAAS;AACrD8G,YAAQA,MAAM2B,OAAO/B,kBAAkB1G,IAAI,CAAC;EAAA,CAC7C;AAED,MAAI,CAAC0I,YAAY;AACR,WAAA;EACT;AAEA,MAAIxC,OAAOzE,WAAW,KAAKqF,MAAMrF,WAAW,GAAG;AACtC,WAAA;EACT;AAEA,MAAIiP,SAAQ;AAEZ,aAAW3Q,MAAM+G,OAAO;AACtB,UAAM6J,OAAOzK,OAAO0K,OAAO,CAACC,GAAGhK,UAAUgK,KAAK9Q,GAAGW,KAAKmG,KAAK,IAAI,IAAI,IAAI,CAAC;AAC9D6J,IAAAA,UAAAC,QAAQT,QAAQ,MAAOS,OAAOT;EAC1C;AAEO,SAAAQ;AACT;AC7DA,SAASI,aAAazP,OAAY0P,SAA+B;AACvD,UAAAtL,QAAQpE,KAAK,GAAG;IACtB,KAAK;AACH,iBAAWyM,KAAKzM,OAAO;AACjB,YAAAyP,aAAahD,GAAGiD,OAAO,GAAG;AACrB,iBAAA;QACT;MACF;AACA;IACF,KAAK;AACH,UAAI1P,MAAM4L,MAAM;AACP,eAAA8D,QAAQC,IAAI3P,MAAM4L,IAAI;MAC/B;AACA,iBAAWa,KAAKR,OAAO2D,OAAO5P,KAAK,GAAG;AAChC,YAAAyP,aAAahD,GAAGiD,OAAO,GAAG;AACrB,iBAAA;QACT;MACF;AACA;EAAA;AAGG,SAAA;AACT;AAEA,SAASG,UAAUzQ,KAAqB;AACtC,MAAI0Q,SAAQ;AACZ,WAAS3P,IAAI,GAAGA,IAAIf,IAAIgB,QAAQD,KAAK;AAC7B,UAAA4P,OAAO3Q,IAAI4Q,WAAW7P,CAAC;AACzB,QAAA4P,QAAQ,SAAUA,QAAQ,OAAQ;AAIpC;IACF;AACAD;EACF;AACOA,SAAAA;AACT;AAqBA,IAAMG,UAAuB,CAAA;AAG7BA,QAAQC,WAAW,eAAeA,WAAW;AACrC,QAAA,IAAI1N,MAAM,iBAAiB;AACnC;AAEAyN,QAAQC,SAASC,QAAQ;AAEzBF,QAAQG,WAAW,eAAeA,SAASrF,MAAMxC,OAAOC,SAAS;AAC/D,aAAW6H,OAAOtF,MAAM;AACtB,UAAM/K,QAAQ,MAAMwI,QAAQ6H,KAAK9H,KAAK;AAClC,QAAAvI,MAAMP,SAAS,QAAQ;AAClB,aAAAO;IACT;EACF;AACO,SAAAyC;AACT;AAEAwN,QAAQH,QAAQ,eAAeA,MAAM/E,MAAMxC,OAAOC,SAAS;AACzD,QAAM8E,QAAQ,MAAM9E,QAAQuC,KAAK,IAAIxC,KAAK;AACtC,MAAA,CAAC+E,MAAMzN,QAAA,GAAW;AACb,WAAA4C;EACT;AAEA,MAAIR,MAAM;AAEV,mBAAiB6G,KAAKwE,OAAO;AAC3BrL;EACF;AACA,SAAOuB,WAAWvB,GAAG;AACvB;AACAgO,QAAQH,MAAMK,QAAQ;AAEtBF,QAAQK,WAAW,eAAeA,SAASvF,MAAMxC,OAAOC,SAAS;AAC/D,QAAMrE,MAAM,MAAMqE,QAAQuC,KAAK,IAAIxC,KAAK;AACpC,MAAApE,IAAI1E,SAAS,YAAY;AACpB,WAAA0E;EACT;AACI,MAAAA,IAAI1E,SAAS,UAAU;AAClB,WAAAgD;EACT;AACO,SAAAG,SAASE,aAAaqB,IAAIvE,IAAI;AACvC;AACAqQ,QAAQK,SAASH,QAAQ;AAEzBF,QAAQM,UAAU,eAAeA,QAAQxF,MAAMxC,OAAOC,SAAS;AAC7D,QAAM8E,QAAQ,MAAM9E,QAAQuC,KAAK,IAAIxC,KAAK;AACnC,SAAA+E,MAAM7N,SAAS,SAASkD,cAAcD;AAC/C;AACAuN,QAAQM,QAAQJ,QAAQ;AAGxBF,QAAQpC,WAAW,eAAeA,SAAS9C,MAAMxC,OAAO;AAC/C,SAAA5E,WAAW4E,MAAMP,QAAQ6F,QAAQ;AAC1C;AACAoC,QAAQpC,SAASsC,QAAQ;AAEzBF,QAAQ7P,SAAS,eAAeA,OAAO2K,MAAMxC,OAAOC,SAAS;AAC3D,QAAM8E,QAAQ,MAAM9E,QAAQuC,KAAK,IAAIxC,KAAK;AAEtC,MAAA+E,MAAM7N,SAAS,UAAU;AAC3B,WAAO+D,WAAWqM,UAAUvC,MAAM1N,IAAI,CAAC;EACzC;AAEI,MAAA0N,MAAMzN,QAAAA,GAAW;AACnB,QAAIoC,MAAM;AAEV,qBAAiB6G,KAAKwE,OAAO;AAC3BrL;IACF;AACA,WAAOuB,WAAWvB,GAAG;EACvB;AAEO,SAAAQ;AACT;AACAwN,QAAQ7P,OAAO+P,QAAQ;AAEvBF,QAAQlM,OAAO,eAAeA,KAAKgH,MAAMxC,OAAOC,SAAS;AACvD,QAAM8E,QAAQ,MAAM9E,QAAQuC,KAAK,IAAIxC,KAAK;AACtC,MAAA+E,MAAM7N,SAAS,UAAU;AACpB,WAAAgD;EACT;AAEA,SAAOqB,SAAS,IAAI9E,KAAKsO,MAAM1N,IAAI,CAAC;AACtC;AACAqQ,QAAQlM,KAAKoM,QAAQ;AAErBF,QAAQ3R,SAAS,eAAeA,OAAOyM,MAAMxC,OAAOC,SAAS;AAC3D,QAAMxI,QAAQ,MAAMwI,QAAQuC,KAAK,IAAIxC,KAAK;AAC1C,UAAQvI,MAAMP,MAAM;IAClB,KAAK;IACL,KAAK;IACL,KAAK;IACL,KAAK;AACI,aAAAkE,WAAA,GAAA,OAAc3D,MAAMJ,IAAM,CAAA;IACnC;AACS,aAAA6C;EAAA;AAEb;AACAwN,QAAQ3R,OAAO6R,QAAQ;AAEvBF,QAAQO,aAAa,eAAeA,WAAWzF,MAAMxC,OAAOC,SAAS;AAC7D,QAAAkH,UAAA,oBAAce,IAAY;AAChC,aAAWJ,OAAOtF,MAAM;AACtB,UAAMhH,QAAO,MAAMyE,QAAQ6H,KAAK9H,KAAK;AACjCxE,QAAAA,MAAKtE,SAAS,UAAU;AAClBiQ,cAAAxM,IAAIa,MAAKnE,IAAI;IAAA,WACZmE,MAAKlE,QAAA,GAAW;AACzB,uBAAiB6K,QAAQ3G,OAAM;AACzB,YAAA2G,KAAKjL,SAAS,UAAU;AAClBiQ,kBAAAxM,IAAIwH,KAAK9K,IAAI;QACvB;MACF;IACF;EACF;AAEI,MAAA8P,QAAQgB,SAAS,GAAG;AACf,WAAA/N;EACT;AAEA,QAAMgO,aAAa,MAAMpI,MAAMvI,MAAMF,IAAI;AACzC,SAAO2P,aAAakB,YAAYjB,OAAO,IAAIhN,aAAaC;AAC1D;AACAsN,QAAQO,WAAWL,QAASX,OAAMA,KAAK;AAEvCS,QAAQW,QAAQ,eAAeA,MAAM7F,MAAMxC,OAAOC,SAAS;AACzD,QAAMxI,QAAQ,MAAMwI,QAAQuC,KAAK,IAAIxC,KAAK;AACtC,MAAAvI,MAAMP,SAAS,UAAU;AACpB,WAAAgD;EACT;AAEA,QAAMR,MAAMjC,MAAMJ;AAClB,MAAIiR,OAAO;AAEP,MAAA9F,KAAK3K,WAAW,GAAG;AACrB,UAAM0Q,YAAY,MAAMtI,QAAQuC,KAAK,IAAIxC,KAAK;AAC1C,QAAAuI,UAAUrR,SAAS,YAAYqR,UAAUlR,OAAO,KAAK,CAAC6D,OAAOsN,UAAUD,UAAUlR,IAAI,GAAG;AACnF,aAAA6C;IACT;AACAoO,WAAOC,UAAUlR;EACnB;AAEA,MAAIiR,SAAS,GAAG;AACd,QAAI5O,MAAM,GAAG;AAGX,aAAOuB,WAAW,CAACkE,KAAKkJ,MAAM,CAAC3O,GAAG,CAAC;IACrC;AACA,WAAOuB,WAAWkE,KAAKkJ,MAAM3O,GAAG,CAAC;EACnC;AACA,SAAOuB,WAAWC,OAAOxB,IAAI+O,QAAQH,IAAI,CAAC,CAAC;AAC7C;AACAZ,QAAQW,MAAMT,QAASL,YAAUA,UAAS,KAAKA,UAAS;AAGxDG,QAAQgB,MAAM,eAAeA,IAAIlG,MAAMxC,OAAO;AAC5C,SAAO5E,WAAW4E,MAAMP,QAAQ4F,UAAUsD,YAAAA,CAAa;AACzD;AACAjB,QAAQgB,IAAId,QAAQ;AAGpBF,QAAQhB,QAAQ,eAAeA,QAAQ;AAE/B,QAAA,IAAIzM,MAAM,uBAAuB;AACzC;AAEAyN,QAAQhB,MAAMkB,QAAQ;AAEtB,IAAM7R,UAAsB,CAAA;AAE5BA,QAAO6S,QAAQ,eAAgBpG,MAAMxC,OAAOC,SAAS;AACnD,QAAMxI,QAAQ,MAAMwI,QAAQuC,KAAK,IAAIxC,KAAK;AAEtC,MAAAvI,MAAMP,SAAS,UAAU;AACpB,WAAAgD;EACT;AAEA,SAAOkB,WAAW3D,MAAMJ,KAAKwR,YAAA,CAAa;AAC5C;AACA9S,QAAO6S,MAAMhB,QAAQ;AAErB7R,QAAO+S,QAAQ,eAAgBtG,MAAMxC,OAAOC,SAAS;AACnD,QAAMxI,QAAQ,MAAMwI,QAAQuC,KAAK,IAAIxC,KAAK;AAEtC,MAAAvI,MAAMP,SAAS,UAAU;AACpB,WAAAgD;EACT;AAEA,SAAOkB,WAAW3D,MAAMJ,KAAK0R,YAAA,CAAa;AAC5C;AACAhT,QAAO+S,MAAMlB,QAAQ;AAErB7R,QAAOM,QAAQ,eAAgBmM,MAAMxC,OAAOC,SAAS;AACnD,QAAMpJ,MAAM,MAAMoJ,QAAQuC,KAAK,IAAIxC,KAAK;AACpC,MAAAnJ,IAAIK,SAAS,UAAU;AAClB,WAAAgD;EACT;AACA,QAAM8O,MAAM,MAAM/I,QAAQuC,KAAK,IAAIxC,KAAK;AACpC,MAAAgJ,IAAI9R,SAAS,UAAU;AAClB,WAAAgD;EACT;AAEI,MAAArD,IAAIQ,KAAKQ,WAAW,GAAG;AAClB,WAAAmC,OAAO,CAAA,CAAE;EAClB;AACI,MAAAgP,IAAI3R,KAAKQ,WAAW,GAAG;AAEzB,WAAOmC,OAAOF,MAAMmP,KAAKpS,IAAIQ,IAAI,CAAC;EACpC;AACA,SAAO2C,OAAOnD,IAAIQ,KAAKhB,MAAM2S,IAAI3R,IAAI,CAAC;AACxC;AACAtB,QAAOM,MAAMuR,QAAQ;AAErBF,QAAQkB,QAAQ7S,QAAO6S;AACvBlB,QAAQoB,QAAQ/S,QAAO+S;AAEvB/S,QAAOmT,aAAa,eAAgB1G,MAAMxC,OAAOC,SAAS;AACxD,QAAMpJ,MAAM,MAAMoJ,QAAQuC,KAAK,IAAIxC,KAAK;AACpC,MAAAnJ,IAAIK,SAAS,UAAU;AAClB,WAAAgD;EACT;AAEA,QAAMiP,SAAS,MAAMlJ,QAAQuC,KAAK,IAAIxC,KAAK;AACvC,MAAAmJ,OAAOjS,SAAS,UAAU;AACrB,WAAAgD;EACT;AAEA,SAAOrD,IAAIQ,KAAK6R,WAAWC,OAAO9R,IAAI,IAAI8C,aAAaC;AACzD;AACArE,QAAOmT,WAAWtB,QAAQ;AAE1B,IAAM5E,QAAqB,CAAA;AAE3BA,MAAMxM,OAAO,eAAgBgM,MAAMxC,OAAOC,SAAS;AACjD,QAAMmJ,MAAM,MAAMnJ,QAAQuC,KAAK,IAAIxC,KAAK;AACpC,MAAA,CAACoJ,IAAI9R,QAAA,GAAW;AACX,WAAA4C;EACT;AACA,QAAM8O,MAAM,MAAM/I,QAAQuC,KAAK,IAAIxC,KAAK;AACpC,MAAAgJ,IAAI9R,SAAS,UAAU;AAClB,WAAAgD;EACT;AACA,MAAImP,MAAM;AACV,MAAIC,UAAU;AACd,mBAAiBnH,QAAQiH,KAAK;AAC5B,QAAIE,SAAS;AACXD,aAAOL,IAAI3R;IACb;AACA,YAAQ8K,KAAKjL,MAAM;MACjB,KAAK;MACL,KAAK;MACL,KAAK;MACL,KAAK;AACHmS,eAAA,GAAA,OAAUlH,KAAK9K,IAAA;AACf;MACF;AACS,eAAA6C;IAAA;AAEDoP,cAAA;EACZ;AACA,SAAOtP,OAAOqP,GAAG;AACnB;AACArG,MAAMxM,KAAKoR,QAAQ;AAEnB5E,MAAMuG,UAAU,eAAgB/G,MAAMxC,OAAOC,SAAS;AACpD,QAAMmJ,MAAM,MAAMnJ,QAAQuC,KAAK,IAAIxC,KAAK;AACpC,MAAA,CAACoJ,IAAI9R,QAAA,GAAW;AACX,WAAA4C;EACT;AAEO,SAAA,IAAIlD,YAAY,mBAAmB;AACxC,qBAAiBmL,QAAQiH,KAAK;AACxB,UAAAjH,KAAKjL,SAAS,QAAQ;AAClB,cAAAiL;MACR;IACF;EAAA,CACD;AACH;AACAa,MAAMuG,QAAQ3B,QAAQ;AAEtB5E,MAAMwG,SAAS,eAAgBhH,MAAMxC,OAAOC,SAAS;AACnD,QAAMxI,QAAQ,MAAMwI,QAAQuC,KAAK,IAAIxC,KAAK;AACtC,MAAA,CAACvI,MAAMH,QAAA,GAAW;AACb,WAAA4C;EACT;AAEO,SAAA,IAAIlD,YAAY,mBAAmB;AAClC,UAAAyS,QAAA,oBAAYvB,IAAI;AACtB,qBAAiBwB,QAAQjS,OAAO;AAC9B,cAAQiS,KAAKxS,MAAM;QACjB,KAAK;QACL,KAAK;QACL,KAAK;QACL,KAAK;AACH,cAAI,CAACuS,MAAMrC,IAAIsC,KAAKrS,IAAI,GAAG;AACnBoS,kBAAA9O,IAAI+O,KAAKrS,IAAI;AACb,kBAAAqS;UACR;AACA;QACF;AACQ,gBAAAA;MAAA;IAEZ;EAAA,CACD;AACH;AACA1G,MAAMwG,OAAO5B,QAAQ;AAErB,IAAM+B,KAAkB,CAAA;AACxBA,GAAGjN,OAAO,eAAgB8F,MAAMxC,OAAOC,SAAS;AAC9C,QAAMxI,QAAQ,MAAMwI,QAAQuC,KAAK,IAAIxC,KAAK;AACpC,QAAAtD,OAAO,MAAMoJ,oBAAoBrO,KAAK;AAE5C,MAAIiF,SAAS,MAAM;AACV,WAAAxC;EACT;AAEA,SAAOkB,WAAWsB,IAAI;AACxB;AAEAiN,GAAGjN,KAAKkL,QAAQ;AAEhB,IAAMrC,SAAsB,CAAA;AAE5BA,OAAOqE,YAAY,eAAgBpH,MAAMxC,OAAO;AAC1C,MAAAA,MAAMP,QAAQ8F,QAAQ;AACxB,WAAOnK,WAAW4E,MAAMP,QAAQ8F,OAAOqE,SAAS;EAClD;AAEO,SAAA1P;AACT;AAEAqL,OAAOH,UAAU,eAAgB5C,MAAMxC,OAAO;AACxC,MAAAA,MAAMP,QAAQ8F,QAAQ;AACxB,WAAOnK,WAAW4E,MAAMP,QAAQ8F,OAAOH,OAAO;EAChD;AAEO,SAAAlL;AACT;AASO,IAAM2P,gBAAgE,CAAA;AAE7EA,cAAcC,QAAQ,eAAeA,MAAMlI,MAAMY,MAAMxC,OAAOC,SAAS;AAG/D,QAAA;AAEF,MAAA,CAAC2B,KAAKtK,QAAA,GAAW;AACZ,WAAA4C;EACT;AAEA,QAAM6P,UAAU,CAAA;AAChB,QAAMC,aAAuB,CAAA;AAC7B,MAAIjJ,IAAI;AAER,WAASkJ,UAAUzH,MAAM;AACvB,QAAI0H,YAAY;AAEZ,QAAAD,OAAO/S,SAAS,QAAQ;AACdgT,kBAAA;AACZD,eAASA,OAAOrI;IAAA,WACPqI,OAAO/S,SAAS,OAAO;AAChC+S,eAASA,OAAOrI;IAClB;AAEAmI,YAAQzT,KAAK2T,MAAM;AACnBD,eAAW1T,KAAK4T,SAAS;AACzBnJ;EACF;AAEA,QAAMoJ,MAAM,CAAA;AACZ,MAAIC,MAAM;AAEV,mBAAiB3S,SAASmK,MAAM;AACxB,UAAAQ,WAAWpC,MAAMJ,aAAanI,KAAK;AACzC,UAAM4S,QAAQ,CAAC,MAAM5S,MAAMF,IAAA,GAAO6S,GAAG;AACrC,aAASxS,IAAI,GAAGA,IAAImJ,GAAGnJ,KAAK;AAC1B,YAAMJ,SAAS,MAAMyI,QAAQ8J,QAAQnS,IAAIwK,QAAQ;AACjDiI,YAAM/T,KAAK,MAAMkB,OAAOD,IAAA,CAAK;IAC/B;AACA4S,QAAI7T,KAAK+T,KAAK;AACdD;EACF;AAEID,MAAAG,KAAK,CAACC,QAAQC,WAAW;AAC3B,aAAS5S,IAAI,GAAGA,IAAImJ,GAAGnJ,KAAK;AACtB,UAAAqP,IAAIlJ,aAAawM,OAAO3S,IAAI,IAAI4S,OAAO5S,IAAI,EAAE;AAC7C,UAAAoS,WAAWpS,OAAO,QAAQ;AAC5BqP,YAAI,CAACA;MACP;AACA,UAAIA,MAAM,GAAG;AACJ,eAAAA;MACT;IACF;AAEA,WAAOsD,OAAO,KAAKC,OAAO;EAAC,CAC5B;AAEM,SAAAxQ,OAAOmQ,IAAIpN,IAAKmH,OAAMA,EAAE,EAAE,CAAC;AACpC;AACA2F,cAAcC,MAAMlC,QAASL,YAAUA,UAAS;AAGhDsC,cAAc/C,QAAQ,eAAeA,MAAMlF,MAAMY,MAAMxC,OAAOC,SAAS;AACjE,MAAA,CAAC2B,KAAKtK,QAAQ;AAAU,WAAA4C;AAG5B,QAAMuQ,UAAsB,CAAA;AAC5B,QAAMC,SAAiC,CAAA;AAEvC,mBAAiBjT,SAASmK,MAAM;AAC1B,QAAAnK,MAAMP,SAAS,UAAU;AAC3BuT,cAAQnU,KAAK,MAAMmB,MAAMF,IAAA,CAAK;AAC9B;IACF;AAEM,UAAA6K,WAAWpC,MAAMJ,aAAanI,KAAK;AACrC,QAAAkT,aAAa,OAAOlT,MAAMJ,KAAKuT,WAAW,WAAWnT,MAAMJ,KAAKuT,SAAS;AAE7E,eAAW9C,OAAOtF,MAAM;AACtBmI,oBAAc,MAAMpE,cAAcuB,KAAK1F,UAAUnC,OAAO;IAC1D;AAEM,UAAA4K,YAAYnH,OAAOK,OAAO,CAAC,GAAGtM,MAAMJ,MAAM;MAACuT,QAAQD;IAAA,CAAW;AACpED,WAAOpU,KAAKuU,SAAS;EACvB;AAEAH,SAAOJ,KAAK,CAACvO,GAAGC,MAAMA,EAAE4O,SAAS7O,EAAE6O,MAAM;AACzC,SAAO5Q,OAAO0Q,MAAM;AACtB;AAEAb,cAAc/C,MAAMc,QAASL,YAAUA,UAAS;AAIhD,IAAMuD,QAAqB,CAAA;AAE3BA,MAAMC,YAAY,eAAgBvI,MAAMxC,OAAO;AACvC,QAAAgL,YAAYhL,MAAMP,QAAQgG,WAAW;AACrC,QAAAwF,WAAWjL,MAAMP,QAAQ+F,UAAU;AAEzC,MAAIwF,aAAaC,UAAU;AACzB,WAAO7P,WAAW,QAAQ;EAC5B;AAEA,MAAI6P,UAAU;AACZ,WAAO7P,WAAW,QAAQ;EAC5B;AAEA,MAAI4P,WAAW;AACb,WAAO5P,WAAW,QAAQ;EAC5B;AAEO,SAAAlB;AACT;AAEA4Q,MAAMI,aAAa,MAAM;AACjB,QAAA,IAAIjR,MAAM,iBAAiB;AACnC;AACA6Q,MAAMI,WAAWtD,QAAQ;AACzBkD,MAAMI,WAAWC,OAAO;AAExBL,MAAMM,cAAc,MAAM;AAClB,QAAA,IAAInR,MAAM,iBAAiB;AACnC;AACA6Q,MAAMM,YAAYxD,QAAQ;AAC1BkD,MAAMM,YAAYD,OAAO;AAEzB,IAAME,OAAoB,CAAA;AAC1BA,KAAKH,aAAa,MAAM;AAChB,QAAA,IAAIjR,MAAM,iBAAiB;AACnC;AACAoR,KAAKH,WAAWtD,QAAQ;AAExByD,KAAKD,cAAc,MAAM;AACjB,QAAA,IAAInR,MAAM,iBAAiB;AACnC;AACAoR,KAAKD,YAAYxD,QAAQ;AAEzB,IAAM0D,OAAoB,CAAA;AAC1BA,KAAKC,MAAM,eAAgB/I,MAAMxC,OAAOC,SAAS;AAC/C,QAAMmJ,MAAM,MAAMnJ,QAAQuC,KAAK,IAAIxC,KAAK;AACpC,MAAA,CAACoJ,IAAI9R,QAAA,GAAW;AACX,WAAA4C;EACT;AAEI,MAAA6G;AACJ,mBAAiBoB,QAAQiH,KAAK;AAC5B,QAAIjH,KAAKjL,SAAS;AAAQ;AACtB,QAAAiL,KAAKjL,SAAS,UAAU;AACnB,aAAAgD;IACT;AACA,QAAI6G,MAAM,UAAaoB,KAAK9K,OAAO0J,GAAG;AACpCA,UAAIoB,KAAK9K;IACX;EACF;AACA,SAAO2C,OAAO+G,CAAC;AACjB;AACAuK,KAAKC,IAAI3D,QAAQ;AAEjB0D,KAAKE,MAAM,eAAgBhJ,MAAMxC,OAAOC,SAAS;AAC/C,QAAMmJ,MAAM,MAAMnJ,QAAQuC,KAAK,IAAIxC,KAAK;AACpC,MAAA,CAACoJ,IAAI9R,QAAA,GAAW;AACX,WAAA4C;EACT;AAEI,MAAA6G;AACJ,mBAAiBoB,QAAQiH,KAAK;AAC5B,QAAIjH,KAAKjL,SAAS;AAAQ;AACtB,QAAAiL,KAAKjL,SAAS,UAAU;AACnB,aAAAgD;IACT;AACA,QAAI6G,MAAM,UAAaoB,KAAK9K,OAAO0J,GAAG;AACpCA,UAAIoB,KAAK9K;IACX;EACF;AACA,SAAO2C,OAAO+G,CAAC;AACjB;AACAuK,KAAKE,IAAI5D,QAAQ;AAEjB0D,KAAKG,MAAM,eAAgBjJ,MAAMxC,OAAOC,SAAS;AAC/C,QAAMmJ,MAAM,MAAMnJ,QAAQuC,KAAK,IAAIxC,KAAK;AACpC,MAAA,CAACoJ,IAAI9R,QAAA,GAAW;AACX,WAAA4C;EACT;AAEA,MAAI6G,IAAI;AACR,mBAAiBoB,QAAQiH,KAAK;AAC5B,QAAIjH,KAAKjL,SAAS;AAAQ;AACtB,QAAAiL,KAAKjL,SAAS,UAAU;AACnB,aAAAgD;IACT;AACA6G,SAAKoB,KAAK9K;EACZ;AACA,SAAO2C,OAAO+G,CAAC;AACjB;AACAuK,KAAKG,IAAI7D,QAAQ;AAEjB0D,KAAKI,MAAM,eAAgBlJ,MAAMxC,OAAOC,SAAS;AAC/C,QAAMmJ,MAAM,MAAMnJ,QAAQuC,KAAK,IAAIxC,KAAK;AACpC,MAAA,CAACoJ,IAAI9R,QAAA,GAAW;AACX,WAAA4C;EACT;AAEA,MAAI6G,IAAI;AACR,MAAIkG,IAAI;AACR,mBAAiB9E,QAAQiH,KAAK;AAC5B,QAAIjH,KAAKjL,SAAS;AAAQ;AACtB,QAAAiL,KAAKjL,SAAS,UAAU;AACnB,aAAAgD;IACT;AACA6G,SAAKoB,KAAK9K;AACV4P;EACF;AACA,MAAIA,MAAM,GAAG;AACJ,WAAA/M;EACT;AACO,SAAAF,OAAO+G,IAAIkG,CAAC;AACrB;AACAqE,KAAKI,IAAI9D,QAAQ;AAEV,IAAM+D,aAA2B;EACtCC,QAAQlE;EACR3R,QAAAA;EACAiN;EACA2G;EACAmB;EACAO;EACA9F;EACA+F;AACF;ACtlBO,IAAMO,gBAAN,MAAoB;EAOzBnV,YAAYX,SAAgB+V,OAAeC,cAA4B;AAF1D,SAAAC,aAAA;AAGX,SAAKjW,SAASA;AACd,SAAK+V,QAAQA;AACb,SAAKjJ,QAAQ;AACb,SAAKkJ,eAAeA;EACtB;EAEAE,UAA0B;AAAA,QAAlBC,MAAAA,UAAAA,SAAAA,KAAAA,UAAAA,OAAAA,SAAAA,UAAAA,KAAM;AACZ,WAAO,KAAKrJ,QAAQqJ,MAAM,KAAKJ,MAAMjU;EACvC;EAEAsU,UAAuB;AAAA,QAAfD,MAAAA,UAAAA,SAAAA,KAAAA,UAAAA,OAAAA,SAAAA,UAAAA,KAAM;AACZ,WAAO,KAAKJ,MAAM,KAAKjJ,QAAQqJ;EACjC;EAEAE,QAAc;AACZ,SAAKvJ,SAAS;EAChB;EAEAwJ,QAAWC,SAA4B;AACrC,UAAMC,OAAO,KAAKT,MAAM,KAAKjJ;AAC7B,SAAKuJ,MAAM;AACL,UAAAlM,OAAOoM,QAAQC,KAAK5L;AAC1B,QAAI,CAACT,MAAM;AACT,YAAM,IAAIjG,MAAA,oBAAA,OAA0BsS,KAAK5L,IAAM,CAAA;IACjD;AACA,WAAOT,KAAKsM,KAAKF,SAAS,MAAMC,IAAI;EACtC;EAEAE,gBAAwB;AACtB,SAAKL,MAAM;AACX,WAAO,KAAKM,iBAAiB;EAC/B;EAEAA,mBAA2B;AACzB,UAAMC,OAAO,KAAKb,MAAM,KAAKjJ,QAAQ;AACrC,UAAM+J,OAAO,KAAKd,MAAM,KAAKjJ;AAC7B,SAAKuJ,MAAM;AACX,WAAO,KAAKrW,OAAOqH,MAAMuP,KAAKE,UAAUD,KAAKC,QAAQ;EACvD;EAEAzP,MAAM0P,KAAqB;AACzB,UAAMZ,MAAM,KAAKJ,MAAM,KAAKjJ,OAAOgK;AACnC,WAAO,KAAK9W,OAAOqH,MAAM8O,KAAKA,MAAMY,GAAG;EACzC;AACF;AC5GA,IAAMC,KAAK;AACX,IAAMC,MAAM;AACZ,IAAMC,QAAQ;AAGd,IAAMC,YAAY;AAClB,IAAMC,UAAU;AAChB,IAAMC,WAAW;AACjB,IAAMC,YAAY;AAClB,IAAMC,aAAa;AACnB,IAAMC,WAAW;AACjB,IAAMC,WAAW;AACjB,IAAMC,WAAW;AACjB,IAAMC,WAAW;AACjB,IAAMC,WAAW;AACjB,IAAMC,WAAW;AAGjB,IAAMC,WAAW;AACjB,IAAMC,WAAW;AACjB,IAAMC,WAAW;AAEjB,SAASC,QAAMnX,KAAK;AAClB,MAAIqV,MAAM;AACJA,QAAA+B,OAAOpX,KAAKqV,GAAG;AACrB,MAAI1U,SAAS0W,UAAUrX,KAAKqV,KAAK,CAAC;AAClC,MAAI1U,OAAON,SAAS;AAAgB,WAAAM;AAC9B0U,QAAA+B,OAAOpX,KAAKW,OAAOqV,QAAQ;AAC7B,MAAAX,QAAQrV,IAAIgB,QAAQ;AACtB,QAAIL,OAAO2W,cAAc;AACvBjC,YAAM1U,OAAO2W,eAAe;IAC9B;AACA,WAAO;MAACjX,MAAM;MAAS2V,UAAUX;IAAG;EACtC;AACA,SAAO1U,OAAOqV;AACd,SAAOrV,OAAO2W;AACP,SAAA3W;AACT;AAEA,SAAS0W,UAAUrX,KAAKqV,KAAKkC,OAAO;AAkBlC,MAAIC,WAAWnC;AACX,MAAAjP,QAAQpG,IAAIqV;AACZ,MAAAJ;AAEJ,UAAQ7O,OAAO;IACb,KAAK,KAAK;AACJ,UAAAqR,MAAMJ,UAAUrX,KAAKoX,OAAOpX,KAAKqV,MAAM,CAAC,GAAG2B,QAAQ;AACvD,UAAIS,IAAIpX,SAAS;AAAgB,eAAAoX;AACzBxC,cAAA,CAAC;QAACnL,MAAM;QAAOkM,UAAUwB;MAAS,CAAA,EAAExP,OAAOyP,IAAIxC,KAAK;AAC5DI,YAAMoC,IAAIzB;AACV;IACF;IACA,KAAK,KAAK;AACJ,UAAAyB,MAAMJ,UAAUrX,KAAKoX,OAAOpX,KAAKqV,MAAM,CAAC,GAAG6B,QAAQ;AACvD,UAAIO,IAAIpX,SAAS;AAAgB,eAAAoX;AACzBxC,cAAA,CAAC;QAACnL,MAAM;QAAOkM,UAAUwB;MAAS,CAAA,EAAExP,OAAOyP,IAAIxC,KAAK;AAC5DI,YAAMoC,IAAIzB;AACV;IACF;IACA,KAAK,KAAK;AACJ,UAAAyB,MAAMJ,UAAUrX,KAAKoX,OAAOpX,KAAKqV,MAAM,CAAC,GAAG,CAAC;AAChD,UAAIoC,IAAIpX,SAAS;AAAgB,eAAAoX;AAC3BpC,YAAA+B,OAAOpX,KAAKyX,IAAIzB,QAAQ;AACtB,cAAAhW,IAAIqV,MAAM;QAChB,KAAK,KAAK;AAEAJ,kBAAA,CAAC;YAACnL,MAAM;YAASkM,UAAUwB;UAAS,CAAA,EAAExP,OAAOyP,IAAIxC,KAAK;AACxDI,gBAAA+B,OAAOpX,KAAKqV,MAAM,CAAC;AACzB,iBAAO,MAAM;AACLoC,kBAAAJ,UAAUrX,KAAKqV,KAAK,CAAC;AAC3B,gBAAIoC,IAAIpX,SAAS;AAAgB,qBAAAoX;AAC3BpC,kBAAA+B,OAAOpX,KAAKyX,IAAIzB,QAAQ;AAC1B,gBAAAhW,IAAIqV,SAAS;AAAK;AAChBA,kBAAA+B,OAAOpX,KAAKqV,MAAM,CAAC;UAC3B;AACI,cAAArV,IAAIqV,SAAS;AAAK,mBAAO;cAAChV,MAAM;cAAS2V,UAAUX;YAAG;AAC1DA;AACAJ,gBAAMxV,KAAK;YAACqK,MAAM;YAAakM,UAAUX;WAAI;AAC7C;QACF;QACA,KAAK,KAAK;AACRA;AACQJ,kBAAA,CAAC;YAACnL,MAAM;YAASkM,UAAUwB;UAAS,CAAA,EAAExP,OAAOyP,IAAIxC,KAAK;AAC9D;QACF;QACA;AACE,iBAAO;YAAC5U,MAAM;YAAS2V,UAAUX;UAAG;MAAA;AAExC;IACF;IACA,KAAK,KAAK;AACJ,UAAAoC,MAAMJ,UAAUrX,KAAKoX,OAAOpX,KAAKqV,MAAM,CAAC,GAAG4B,QAAQ;AACvD,UAAIQ,IAAIpX,SAAS;AAAgB,eAAAoX;AACzBxC,cAAA,CAAC;QAACnL,MAAM;QAAOkM,UAAUwB;MAAS,CAAA,EAAExP,OAAOyP,IAAIxC,KAAK;AAC5DI,YAAMoC,IAAIzB;AACV;IACF;IACA,KAAK,KAAK;AACJ,UAAArV,SAAS+W,YAAY1X,KAAKqV,GAAG;AACjC,UAAI1U,OAAON,SAAS;AAAgB,eAAAM;AACpCsU,cAAQtU,OAAOsU;AACfI,YAAM1U,OAAOqV;AACb;IACF;IACA,KAAK;AACHf,cAAQ,CAAC;QAACnL,MAAM;QAASkM,UAAUX;OAAI;AACjCA,YAAA+B,OAAOpX,KAAKqV,MAAM,CAAC;AAErB,UAAArV,IAAIqV,SAAS,KAAK;AACpB,eAAO,MAAM;AACX,cAAIrV,IAAIuG,MAAM8O,KAAKA,MAAM,CAAC,MAAM,OAAO;AACrCJ,kBAAMxV,KAAK;cAACqK,MAAM;cAAekM,UAAUX;aAAI;AACzCA,kBAAA+B,OAAOpX,KAAKqV,MAAM,CAAC;UAC3B;AAEA,cAAIrF,MAAMqH,UAAUrX,KAAKqV,KAAK,CAAC;AAC/B,cAAIrF,IAAI3P,SAAS;AAAgB,mBAAA2P;AACzBiF,kBAAAA,MAAMjN,OAAOgI,IAAIiF,KAAK;AAC9BI,gBAAMrF,IAAIgG;AACJX,gBAAA+B,OAAOpX,KAAKqV,GAAG;AACjB,cAAArV,IAAIqV,SAAS;AAAK;AAChBA,gBAAA+B,OAAOpX,KAAKqV,MAAM,CAAC;AACrB,cAAArV,IAAIqV,SAAS;AAAK;QACxB;MACF;AAEI,UAAArV,IAAIqV,SAAS,KAAK;AACpBA;AACAJ,cAAMxV,KAAK;UAACqK,MAAM;UAAakM,UAAUX;SAAI;MAAA,OACxC;AACL,eAAO;UAAChV,MAAM;UAAS2V,UAAUX;QAAG;MACtC;AAEA;IACF,KAAK;IACL,KAAK,KAAK;AACJ,UAAA1U,SAASgX,YAAY3X,KAAKqV,GAAG;AACjC,UAAI1U,OAAON,SAAS;AAAgB,eAAAM;AACpCsU,cAAQtU,OAAOsU;AACfI,YAAM1U,OAAOqV;AACb;IACF;IACA,KAAK,KAAK;AACRX;AACAJ,cAAQ,CAAA;AACD,aAAAjV,IAAIqV,SAAS,OAAOrV,IAAIqV,MAAM,OAAO,KAAK;AAC/CJ,cAAMxV,KAAK;UAACqK,MAAM;UAAakM,UAAUwB;SAAS;AAC3CnC,eAAA;MACT;AACAJ,YAAMxV,KAAK;QAACqK,MAAM;QAAUkM,UAAUwB;OAAS;AAC/C;IACF;IACA,KAAK;AACHvC,cAAQ,CAAC;QAACnL,MAAM;QAAQkM,UAAUwB;OAAS;AAC3CnC;AACA;IACF,KAAK;AACHJ,cAAQ,CAAC;QAACnL,MAAM;QAAckM,UAAUwB;OAAS;AACjDnC;AACA;IACF,KAAK,KAAK;AACR,UAAIuC,WAAWC,WAAW7X,KAAKqV,MAAM,GAAGe,KAAK;AAC7C,UAAIwB,UAAU;AACZvC,eAAO,IAAIuC;AACH3C,gBAAA,CACN;UAACnL,MAAM;UAASkM,UAAUwB;QAAQ,GAClC;UAAC1N,MAAM;UAASkM,UAAUwB,WAAW;QAAC,GACtC;UAAC1N,MAAM;UAAakM,UAAUX;QAAG,CAAA;MAErC;AACA;IACF;IACA,SAAS;AACP,UAAIyC,SAASD,WAAW7X,KAAKqV,KAAKc,GAAG;AACrC,UAAI2B,QAAQ;AACHzC,eAAAyC;AACP,YAAIhO,OAAO;AAEP,YAAA9J,IAAIqV,SAAS,KAAK;AACpB,cAAI0C,UAAUF,WAAW7X,KAAKqV,MAAM,GAAGc,GAAG;AAC1C,cAAI4B,SAAS;AACJjO,mBAAA;AACPuL,mBAAO,IAAI0C;UACb;QACF;AAEA,YAAI/X,IAAIqV,SAAS,OAAOrV,IAAIqV,SAAS,KAAK;AACjCvL,iBAAA;AACPuL;AACA,cAAIrV,IAAIqV,SAAS,OAAOrV,IAAIqV,SAAS,KAAK;AACxCA;UACF;AACA,cAAI2C,SAASH,WAAW7X,KAAKqV,KAAKc,GAAG;AACrC,cAAI,CAAC6B;AAAQ,mBAAO;cAAC3X,MAAM;cAAS2V,UAAUX;YAAG;AAC1CA,iBAAA2C;QACT;AAEQ/C,gBAAA,CACN;UAACnL;UAAMkM,UAAUwB;QAAQ,GACzB;UAAC1N,MAAMA,OAAO;UAAQkM,UAAUX;QAAG,CAAA;AAGrC;MACF;AAEA,UAAIuC,WAAWC,WAAW7X,KAAKqV,KAAKe,KAAK;AACzC,UAAIwB,UAAU;AACLvC,eAAAuC;AACC,gBAAA5X,IAAIqV,MAAM;UAChB,KAAK;UACL,KAAK,KAAK;AACR,gBAAI1U,SAASsX,cAAcjY,KAAKwX,UAAUnC,GAAG;AAC7C,gBAAI1U,OAAON,SAAS;AAAgB,qBAAAM;AACpCsU,oBAAQtU,OAAOsU;AACfI,kBAAM1U,OAAOqV;AACb;UACF;UACA,SAAS;AACCf,oBAAA,CACN;cAACnL,MAAM;cAAakM,UAAUwB;YAAQ,GACtC;cAAC1N,MAAM;cAASkM,UAAUwB;YAAQ,GAClC;cAAC1N,MAAM;cAAakM,UAAUX;YAAG,CAAA;UAErC;QAAA;AAGF;MACF;IACF;EAAA;AAGF,MAAI,CAACJ,OAAO;AACV,WAAO;MAAC5U,MAAM;MAAS2V,UAAUX;IAAG;EACtC;AAEA,MAAI6C,WAAW;AACX,MAAAC;AAEJC;AAAM,WAAO,MAAM;AACb,UAAAC,WAAWjB,OAAOpX,KAAKqV,GAAG;AAC1B,UAAAgD,aAAarY,IAAIgB,QAAQ;AACrBqU,cAAAgD;AACN;MACF;AAEOF,aAAAG,eAAetY,KAAKqY,QAAQ;AAC/B,UAAAF,KAAK9X,SAAS,WAAW;AAC3B4U,cAAMsD,QAAQ;UAACzO,MAAM;UAAYkM,UAAUwB;SAAS;AAC7C,eAAAW,KAAK9X,SAAS,WAAW;AACtB4U,kBAAAA,MAAMjN,OAAOmQ,KAAKlD,KAAK;AAC/BI,gBAAM8C,KAAKnC;AACXmC,iBAAOG,eAAetY,KAAKoX,OAAOpX,KAAKqV,GAAG,CAAC;QAC7C;AACAJ,cAAMxV,KAAK;UAACqK,MAAM;UAAiBkM,UAAUX;SAAI;AACjD;MACF;AAEIjP,UAAAA,SAAQpG,IAAIqY;AAChB,cAAQjS,QAAO;QACb,KAAK,KAAK;AACJ,cAAAoS,YAAYxY,IAAIqY,WAAW;AAC/B,kBAAQG,WAAW;YACjB,KAAK,KAAK;AAEJ,kBAAAjB,QAAQlB,aAAa6B,YAAY7B;AAAiB,sBAAA+B;AAClD,kBAAAX,MAAMJ,UAAUrX,KAAKoX,OAAOpX,KAAKqY,WAAW,CAAC,GAAGhC,SAAS;AAC7D,kBAAIoB,IAAIpX,SAAS;AAAgB,uBAAAoX;AACzBxC,sBAAAA,MAAMjN,OAAOyP,IAAIxC,KAAK;AAC9BA,oBAAMsD,QAAQ;gBAACzO,MAAM;gBAAQkM,UAAUwB;eAAS;AAChDnC,oBAAMoC,IAAIzB;AACCkC,yBAAA7B;AACX;YACF;YACA,KAAK,KAAK;AAEJ,kBAAAkB,QAAQf,aAAa0B,YAAY1B;AAAiB,sBAAA4B;AAClD,kBAAAX,MAAMJ,UAAUrX,KAAKoX,OAAOpX,KAAKqY,WAAW,CAAC,GAAG,CAAC;AACrD,kBAAIZ,IAAIpX,SAAS;AAAgB,uBAAAoX;AACjCxC,oBAAMsD,QAAQ;gBAACzO,MAAM;gBAAQkM,UAAUwB;eAAS;AAChDvC,oBAAMxV,KAAK;gBAACqK,MAAM;gBAAMkM,UAAUqC;cAAA,GAAW;gBAACvO,MAAM;gBAAUkM,UAAUqC,WAAW;cAAE,CAAA;AAC7EpD,sBAAAA,MAAMjN,OAAOyP,IAAIxC,KAAK;AAC9BI,oBAAMoC,IAAIzB;AACCkC,yBAAA1B;AACX;YACF;YACA;AACQ,oBAAA4B;UAAA;AAEV;QACF;QACA,KAAK,KAAK;AACJ,cAAAb,QAAQb,YAAYwB,WAAWxB;AAAgB,kBAAA0B;AAC/C,cAAAX,MAAMJ,UAAUrX,KAAKoX,OAAOpX,KAAKqY,WAAW,CAAC,GAAG3B,WAAW,CAAC;AAChE,cAAIe,IAAIpX,SAAS;AAAgB,mBAAAoX;AACzBxC,kBAAAA,MAAMjN,OAAOyP,IAAIxC,KAAK;AAC9BA,gBAAMsD,QAAQ;YAACzO,MAAM;YAAOkM,UAAUwB;WAAS;AAC/CnC,gBAAMoC,IAAIzB;AACCkC,qBAAAxB;AACX;QACF;QACA,KAAK,KAAK;AACJ,cAAAa,QAAQZ,YAAYuB,WAAWvB;AAAgB,kBAAAyB;AAC/C,cAAAX,MAAMJ,UAAUrX,KAAKoX,OAAOpX,KAAKqY,WAAW,CAAC,GAAG1B,WAAW,CAAC;AAChE,cAAIc,IAAIpX,SAAS;AAAgB,mBAAAoX;AACzBxC,kBAAAA,MAAMjN,OAAOyP,IAAIxC,KAAK;AAC9BA,gBAAMsD,QAAQ;YAACzO,MAAM;YAAOkM,UAAUwB;WAAS;AAC/CnC,gBAAMoC,IAAIzB;AACCkC,qBAAAvB;AACX;QACF;QACA,KAAK,KAAK;AACR,cAAI3W,IAAIqY,WAAW,OAAO,KAAK;AAEzB,gBAAAd,QAAQR,YAAYmB,YAAYnB;AAAgB,oBAAAqB;AAChDX,gBAAAA,OAAMJ,UAAUrX,KAAKoX,OAAOpX,KAAKqY,WAAW,CAAC,GAAGtB,QAAQ;AAC5D,gBAAIU,KAAIpX,SAAS;AAAgBoX,qBAAAA;AACzBxC,oBAAAA,MAAMjN,OAAOyP,KAAIxC,KAAK;AAC9BA,kBAAMsD,QAAQ;cAACzO,MAAM;cAAOkM,UAAUwB;aAAS;AAC/CnC,kBAAMoC,KAAIzB;AACCkC,uBAAAnB;AACX;UACF;AAGI,cAAAQ,QAAQX,YAAYsB,WAAWtB;AAAgB,kBAAAwB;AAC/C,cAAAX,MAAMJ,UAAUrX,KAAKoX,OAAOpX,KAAKqY,WAAW,CAAC,GAAGzB,WAAW,CAAC;AAChE,cAAIa,IAAIpX,SAAS;AAAgB,mBAAAoX;AACzBxC,kBAAAA,MAAMjN,OAAOyP,IAAIxC,KAAK;AAC9BA,gBAAMsD,QAAQ;YAACzO,MAAM;YAAOkM,UAAUwB;WAAS;AAC/CnC,gBAAMoC,IAAIzB;AACCkC,qBAAAtB;AACX;QACF;QACA,KAAK,KAAK;AACJ,cAAAW,QAAQV,YAAYqB,WAAWrB;AAAgB,kBAAAuB;AAC/C,cAAAX,MAAMJ,UAAUrX,KAAKoX,OAAOpX,KAAKqY,WAAW,CAAC,GAAGxB,WAAW,CAAC;AAChE,cAAIY,IAAIpX,SAAS;AAAgB,mBAAAoX;AACzBxC,kBAAAA,MAAMjN,OAAOyP,IAAIxC,KAAK;AAC9BA,gBAAMsD,QAAQ;YAACzO,MAAM;YAAOkM,UAAUwB;WAAS;AAC/CnC,gBAAMoC,IAAIzB;AACCkC,qBAAArB;AACX;QACF;QACA,KAAK,KAAK;AACJ,cAAAU,QAAQT,YAAYoB,WAAWpB;AAAgB,kBAAAsB;AAC/C,cAAAX,MAAMJ,UAAUrX,KAAKoX,OAAOpX,KAAKqY,WAAW,CAAC,GAAGvB,WAAW,CAAC;AAChE,cAAIW,IAAIpX,SAAS;AAAgB,mBAAAoX;AACzBxC,kBAAAA,MAAMjN,OAAOyP,IAAIxC,KAAK;AAC9BA,gBAAMsD,QAAQ;YAACzO,MAAM;YAAOkM,UAAUwB;WAAS;AAC/CnC,gBAAMoC,IAAIzB;AACCkC,qBAAApB;AACX;QACF;QACA,KAAK;QACL,KAAK,KAAK;AACJ,cAAAS,QAAQf,aAAa0B,YAAY1B;AAAiB,kBAAA4B;AACtD,cAAIK,UAAUJ,WAAW;AACrB,cAAArY,IAAIyY,aAAa,KAAK;AACxBA;UACF;AACI,cAAAhB,MAAMJ,UAAUrX,KAAKoX,OAAOpX,KAAKyY,OAAO,GAAGjC,YAAY,CAAC;AAC5D,cAAIiB,IAAIpX,SAAS;AAAgB,mBAAAoX;AACjCxC,gBAAMsD,QAAQ;YAACzO,MAAM;YAAQkM,UAAUwB;WAAS;AAChDvC,gBAAMxV,KAAK;YAACqK,MAAM;YAAMkM,UAAUqC;aAAW;YAACvO,MAAM;YAAUkM,UAAUyC;UAAQ,CAAA;AACxExD,kBAAAA,MAAMjN,OAAOyP,IAAIxC,KAAK;AAC9BI,gBAAMoC,IAAIzB;AACCkC,qBAAA1B;AACX;QACF;QACA,KAAK,KAAK;AACR,cAAIxW,IAAIqY,WAAW,OAAO,KAAK;AAEzB,gBAAAd,QAAQjB,WAAW4B,WAAW5B;AAAe,oBAAA8B;AAC7C,gBAAAX,MAAMJ,UAAUrX,KAAKoX,OAAOpX,KAAKqY,WAAW,CAAC,GAAG/B,UAAU,CAAC;AAC/D,gBAAImB,IAAIpX,SAAS;AAAgB,qBAAAoX;AACzBxC,oBAAAA,MAAMjN,OAAOyP,IAAIxC,KAAK;AAC9BA,kBAAMsD,QAAQ;cAACzO,MAAM;cAAMkM,UAAUwB;aAAS;AAC9CnC,kBAAMoC,IAAIzB;AACCkC,uBAAA5B;UAAA,OACN;AACD,gBAAAiB,QAAQ,MAAMW,WAAW;AAAU,oBAAAE;AAEvC,gBAAIM,WAAWtB,OAAOpX,KAAKqY,WAAW,CAAC;AACvC,gBAAIT,WAAWC,WAAW7X,KAAK0Y,UAAUtC,KAAK;AAC9C,gBAAI,CAACwB;AAAU,qBAAO;gBAACvX,MAAM;gBAAS2V,UAAU0C;cAAQ;AACxDrD,kBAAMqD,WAAWd;AACjB,gBAAI5X,IAAIqV,SAAS,OAAOrV,IAAIqV,SAAS,KAAK;AACxC,kBAAI1U,SAASsX,cAAcjY,KAAK0Y,UAAUrD,GAAG;AAC7C,kBAAI1U,OAAON,SAAS;AAAgB,uBAAAM;AAC5BsU,sBAAAA,MAAMjN,OAAOrH,OAAOsU,KAAK;AACjCA,oBAAMsD,QAAQ;gBAACzO,MAAM;gBAAYkM,UAAUwB;eAAS;AACpDnC,oBAAM1U,OAAOqV;AACFkC,yBAAA;YACb;UACF;AACA;QACF;QACA,KAAK,KAAK;AAEJ,cAAAlY,IAAIqY,WAAW,MAAM;AAAW,kBAAAD;AAChC,cAAAb,QAAQhB,YAAY2B,WAAW3B;AAAgB,kBAAA6B;AAC/C,cAAAX,MAAMJ,UAAUrX,KAAKoX,OAAOpX,KAAKqY,WAAW,CAAC,GAAG9B,WAAW,CAAC;AAChE,cAAIkB,IAAIpX,SAAS;AAAgB,mBAAAoX;AACzBxC,kBAAAA,MAAMjN,OAAOyP,IAAIxC,KAAK;AAC9BA,gBAAMsD,QAAQ;YAACzO,MAAM;YAAOkM,UAAUwB;WAAS;AAC/CnC,gBAAMoC,IAAIzB;AACCkC,qBAAA3B;AACX;QACF;QACA,KAAK,KAAK;AAEJ,cAAAvW,IAAIqY,WAAW,OAAO;AAAW,kBAAAD;AACjC,cAAAb,QAAQf,aAAa0B,WAAW1B;AAAiB,kBAAA4B;AACjD,cAAAX,MAAMJ,UAAUrX,KAAKoX,OAAOpX,KAAKqY,WAAW,CAAC,GAAG7B,YAAY,CAAC;AACjE,cAAIiB,IAAIpX,SAAS;AAAgB,mBAAAoX;AACjCxC,gBAAMsD,QAAQ;YAACzO,MAAM;YAAQkM,UAAUwB;WAAS;AAChDvC,gBAAMxV,KAAK;YAACqK,MAAM;YAAMkM,UAAUqC;UAAA,GAAW;YAACvO,MAAM;YAAUkM,UAAUqC,WAAW;UAAE,CAAA;AAC7EpD,kBAAAA,MAAMjN,OAAOyP,IAAIxC,KAAK;AAC9BI,gBAAMoC,IAAIzB;AACCkC,qBAAA1B;AACX;QACF;QACA,KAAK,KAAK;AAER,cAAIxW,IAAIuG,MAAM8R,UAAUA,WAAW,CAAC,MAAM;AAAc,kBAAAD;AACpD,cAAAb,QAAQd,cAAcyB,WAAWzB;AAAkB,kBAAA2B;AACvDnD,gBAAMsD,QAAQ;YAACzO,MAAM;YAAQkM,UAAUwB;WAAS;AAChDnC,gBAAMgD,WAAW;AACNH,qBAAAzB;AACX;QACF;QACA,KAAK,KAAK;AAER,cAAIzW,IAAIuG,MAAM8R,UAAUA,WAAW,CAAC,MAAM;AAAa,kBAAAD;AACnD,cAAAb,QAAQd,cAAcyB,WAAWzB;AAAkB,kBAAA2B;AACvDnD,gBAAMsD,QAAQ;YAACzO,MAAM;YAAOkM,UAAUwB;WAAS;AAC/CnC,gBAAMgD,WAAW;AACNH,qBAAAzB;AACX;QACF;QACA,SAAS;AACP,cAAIkC,QAAQC,cAAc5Y,KAAKqY,UAAUjC,KAAK;AAC9C,kBAAQuC,OAAO;YACb,KAAK,MAAM;AACL,kBAAApB,QAAQf,aAAa0B,YAAY1B;AAAiB,sBAAA4B;AAEhD/C,oBAAA+B,OAAOpX,KAAKqY,WAAW,CAAC;AAE9B,kBAAIQ,UAAU;AAEV,kBAAA7Y,IAAIqV,SAAS,KAAK;AACVwD,0BAAA;AACJxD,sBAAA+B,OAAOpX,KAAKqV,MAAM,CAAC;cAC3B;AAEA,kBAAIyD,WAAWzD;AACf,kBAAI1U,SAAS0W,UAAUrX,KAAKqV,KAAKmB,YAAY,CAAC;AAC9C,kBAAI7V,OAAON,SAAS;AAAgB,uBAAAM;AAE9B0U,oBAAA+B,OAAOpX,KAAKW,OAAOqV,QAAQ;AAE7B,kBAAAhW,IAAIqV,SAAS,OAAOrV,IAAIqV,MAAM,OAAO,KAAK;AAE5C,oBAAIhV,OAAO;AACX,oBAAIL,IAAIqV,MAAM,OAAO,KAAK;AACjBhV,yBAAA;AACDgV,wBAAA+B,OAAOpX,KAAKqV,MAAM,CAAC;gBAAA,OACpB;AACCA,wBAAA+B,OAAOpX,KAAKqV,MAAM,CAAC;gBAC3B;AAEA,oBAAIoC,MAAMJ,UAAUrX,KAAKqV,KAAKmB,YAAY,CAAC;AAC3C,oBAAIiB,IAAIpX,SAAS;AAAgB,yBAAAoX;AACjCxC,sBAAMsD,QAAQ;kBAACzO,MAAM;kBAAYkM,UAAUwB;iBAAS;AAC5CvC,wBAAAA,MAAMjN,OAAO;kBAAC8B,MAAMzJ;kBAAM2V,UAAU8C;gBAAA,GAAWnY,OAAOsU,OAAOwC,IAAIxC,KAAK;AAC9EI,sBAAMoC,IAAIzB;cAAA,OACL;AAELf,sBAAMsD,QAAQ;kBAACzO,MAAM;kBAAQkM,UAAUwB;iBAAS;AAChDvC,sBAAMxV,KAAK;kBAACqK,MAAM;kBAAMkM,UAAUqC;gBAAA,GAAW;kBAACvO,MAAM;kBAAUkM,UAAUqC,WAAW;gBAAE,CAAA;AAC7EpD,wBAAAA,MAAMjN,OAAOrH,OAAOsU,KAAK;cACnC;AAEA,kBAAI4D,SAAS;AACLxD,sBAAA+B,OAAOpX,KAAKqV,GAAG;AACjB,oBAAArV,IAAIqV,SAAS;AAAK,yBAAO;oBAAChV,MAAM;oBAAS2V,UAAUX;kBAAG;AAC1DA;cACF;AAEW6C,yBAAA1B;AACX;YACF;YACA,KAAK,SAAS;AAER,kBAAAe,QAAQf,aAAa0B,YAAY1B;AAAiB,sBAAA4B;AAClD,kBAAAX,MAAMJ,UAAUrX,KAAKoX,OAAOpX,KAAKqY,WAAW,CAAC,GAAG7B,YAAY,CAAC;AACjE,kBAAIiB,IAAIpX,SAAS;AAAgB,uBAAAoX;AACjCxC,oBAAMsD,QAAQ;gBAACzO,MAAM;gBAAQkM,UAAUwB;eAAS;AAChDvC,oBAAMxV,KAAK;gBAACqK,MAAM;gBAAMkM,UAAUqC;cAAA,GAAW;gBAACvO,MAAM;gBAAUkM,UAAUqC,WAAW;cAAE,CAAA;AAC7EpD,sBAAAA,MAAMjN,OAAOyP,IAAIxC,KAAK;AAC9BI,oBAAMoC,IAAIzB;AACCkC,yBAAA;AACX;YACF;YACA,SAAS;AACD,oBAAAE;YACR;UAAA;QAEJ;MAAA;IAEJ;AAEA,MAAId,gBAAea,QAAA,OAAA,SAAAA,KAAM9X,UAAS,WAAW8X,KAAKnC;AAElD,SAAO;IAAC3V,MAAM;IAAW4U;IAAOe,UAAUX;IAAKiC;;AACjD;AAEA,SAASgB,eAAetY,KAAKqV,KAAK;AAChC,MAAImC,WAAWnC;AACP,UAAArV,IAAIqV,MAAM;IAChB,KAAK,KAAK;AACFA,YAAA+B,OAAOpX,KAAKqV,MAAM,CAAC;AACzB,UAAI0D,aAAa1D;AACjB,UAAIuC,YAAWC,WAAW7X,KAAKqV,KAAKe,KAAK;AACzC,UAAI,CAACwB;AAAU,eAAO;UAACvX,MAAM;UAAS2V,UAAUX;QAAG;AAC5CuC,aAAAA;AAEA,aAAA;QACLvX,MAAM;QACN4U,OAAO,CACL;UAACnL,MAAM;UAAekM,UAAUwB;QAAQ,GACxC;UAAC1N,MAAM;UAASkM,UAAU+C;QAAU,GACpC;UAACjP,MAAM;UAAakM,UAAUX;QAAG,CAAA;QAEnCW,UAAUX;MAAA;IAEd;IACA,KAAK;AACC,UAAArV,IAAIqV,MAAM,OAAO;AAAK,eAAO;UAAChV,MAAM;UAAS2V,UAAUX;QAAG;AAG9D,UAAIJ,QAAQ,CAAC;QAACnL,MAAM;QAASkM,UAAUwB;OAAS;AACzCnC,aAAA;AAEH,UAAAqD,WAAWtB,OAAOpX,KAAKqV,GAAG;AAC9B,UAAIuC,WAAWC,WAAW7X,KAAK0Y,UAAUtC,KAAK;AAC9C,UAAIwB,UAAU;AACZvC,cAAMqD,WAAWd;AACX3C,cAAAxV,KACJ;UAACqK,MAAM;UAAckM,UAAU0C;QAAQ,GACvC;UAAC5O,MAAM;UAASkM,UAAU0C;QAAQ,GAClC;UAAC5O,MAAM;UAAakM,UAAUX;QAAG,CAAA;MAErC;AAEO,aAAA;QACLhV,MAAM;QACN4U;QACAe,UAAUX;MAAA;IAEd,KAAK,KAAK;AACFA,YAAA+B,OAAOpX,KAAKqV,MAAM,CAAC;AAErB,UAAArV,IAAIqV,SAAS,KAAK;AACb,eAAA;UACLhV,MAAM;UACN4U,OAAO,CAAC;YAACnL,MAAM;YAAiBkM,UAAUwB;WAAS;UACnDxB,UAAUX,MAAM;QAAA;MAEpB;AAEA,UAAIyD,WAAWzD;AACf,UAAI1U,SAAS0W,UAAUrX,KAAKqV,KAAK,CAAC;AAClC,UAAI1U,OAAON,SAAS;AAAgB,eAAAM;AAE9B0U,YAAA+B,OAAOpX,KAAKW,OAAOqV,QAAQ;AAE7B,UAAAhW,IAAIqV,SAAS,OAAOrV,IAAIqV,MAAM,OAAO,KAAK;AAC5C,YAAIhV,OAAO;AACX,YAAIL,IAAIqV,MAAM,OAAO,KAAK;AACjBhV,iBAAA;AACAgV,iBAAA;QAAA,OACF;AACEA,iBAAA;QACT;AAEMA,cAAA+B,OAAOpX,KAAKqV,GAAG;AACrB,YAAIoC,MAAMJ,UAAUrX,KAAKqV,KAAK,CAAC;AAC/B,YAAIoC,IAAIpX,SAAS;AAAgB,iBAAAoX;AAC3BpC,cAAA+B,OAAOpX,KAAKyX,IAAIzB,QAAQ;AAC1B,YAAAhW,IAAIqV,SAAS;AAAK,iBAAO;YAAChV,MAAM;YAAS2V,UAAUX;UAAG;AAEnD,eAAA;UACLhV,MAAM;UACN4U,OAAO,CACL;YAACnL,MAAM;YAASkM,UAAUwB;UAAQ,GAClC;YAAC1N,MAAMzJ;YAAM2V,UAAU8C;UAAQ,CAAA,EAC/B9Q,OAAOrH,OAAOsU,OAAOwC,IAAIxC,KAAK;UAChCe,UAAUX,MAAM;QAAA;MAEpB;AAEI,UAAArV,IAAIqV,SAAS;AAAK,eAAO;UAAChV,MAAM;UAAS2V,UAAUX;QAAG;AAEnD,aAAA;QACLhV,MAAM;QACN4U,OAAO,CAAC;UAACnL,MAAM;UAAkBkM,UAAUwB;QAAA,CAAS,EAAExP,OAAOrH,OAAOsU,KAAK;QACzEe,UAAUX,MAAM;MAAA;IAEpB;IACA,KAAK,KAAK;AACFA,YAAA+B,OAAOpX,KAAKqV,MAAM,CAAC;AACrB,UAAArV,IAAIqV,SAAS,KAAK;AAChB,YAAA1U,SAAS+W,YAAY1X,KAAKqV,GAAG;AACjC,YAAI1U,OAAON,SAAS;AAAgB,iBAAAM;AACpCA,eAAOsU,MAAMsD,QAAQ;UAACzO,MAAM;UAAckM,UAAUwB;SAAS;AACtD,eAAA7W;MACT;AACA;IACF;IACA,KAAK,KAAK;AACJ,UAAAA,SAAS+W,YAAY1X,KAAKqV,GAAG;AACjC,UAAI1U,OAAON,SAAS;AAAgB,eAAAM;AACpCA,aAAOsU,MAAMsD,QAAQ;QAACzO,MAAM;QAAckM,UAAUwB;OAAS;AACtD,aAAA7W;IACT;EAAA;AAGF,SAAO;IAACN,MAAM;IAAS2V,UAAUX;EAAG;AACtC;AAEA,SAAS4C,cAAcjY,KAAKwX,UAAUnC,KAAK;AACzC,MAAIJ,QAAQ,CAAA;AAEZA,QAAMxV,KAAK;IAACqK,MAAM;IAAakM,UAAUwB;GAAS;AAE9C,MAAAxX,IAAIqV,SAAS,OAAOrV,IAAIqV,MAAM,OAAO,KAAK;AAC5CJ,UAAMxV,KAAK;MAACqK,MAAM;MAAakM,UAAUwB;KAAS;AAClDvC,UAAMxV,KAAK;MAACqK,MAAM;MAASkM,UAAUwB;OAAW;MAAC1N,MAAM;MAAakM,UAAUX;IAAI,CAAA;AAC5EA,UAAA+B,OAAOpX,KAAKqV,MAAM,CAAC;AACzB,QAAI2D,UAAUnB,WAAW7X,KAAKqV,KAAKe,KAAK;AACxC,QAAI,CAAC4C;AAAS,aAAO;QAAC3Y,MAAM;QAAS2V,UAAUX;MAAG;AAClDJ,UAAMxV,KAAK;MAACqK,MAAM;MAASkM,UAAUX;IAAA,GAAM;MAACvL,MAAM;MAAakM,UAAUX,MAAM2D;IAAQ,CAAA;AACjF3D,UAAA+B,OAAOpX,KAAKqV,MAAM2D,OAAO;AAC3B,QAAAhZ,IAAIqV,SAAS;AAAK,aAAO;QAAChV,MAAM;QAAS2V,UAAUX;MAAG;AAC1DA;AAEMA,UAAA+B,OAAOpX,KAAKqV,GAAG;EAAA,OAChB;AACLJ,UAAMxV,KAAK;MAACqK,MAAM;MAASkM,UAAUwB;OAAW;MAAC1N,MAAM;MAAakM,UAAUX;IAAI,CAAA;AAC5EA,UAAA+B,OAAOpX,KAAKqV,MAAM,CAAC;EAC3B;AAEA,MAAI4D,UAAU5D;AAEV,MAAArV,IAAIqV,SAAS,KAAK;AACpB,WAAO,MAAM;AACX,UAAI1U,SAAS0W,UAAUrX,KAAKqV,KAAK,CAAC;AAClC,UAAI1U,OAAON,SAAS;AAAgB,eAAAM;AAC5BsU,cAAAA,MAAMjN,OAAOrH,OAAOsU,KAAK;AACjCgE,gBAAUtY,OAAOqV;AACXX,YAAA+B,OAAOpX,KAAKW,OAAOqV,QAAQ;AAC7B,UAAAhW,IAAIqV,SAAS;AAAK;AAChBA,YAAA+B,OAAOpX,KAAKqV,MAAM,CAAC;AAErB,UAAArV,IAAIqV,SAAS;AAAK;IACxB;EACF;AAEI,MAAArV,IAAIqV,SAAS,KAAK;AACpB,WAAO;MAAChV,MAAM;MAAS2V,UAAUX;IAAG;EACtC;AAGAJ,QAAMxV,KAAK;IAACqK,MAAM;IAAiBkM,UAAUiD;GAAQ;AAE9C,SAAA;IACL5Y,MAAM;IACN4U;IACAe,UAAUX,MAAM;EAAA;AAEpB;AAEA,SAASqC,YAAY1X,KAAKqV,KAAK;AAC7B,MAAIJ,QAAQ,CAAC;IAACnL,MAAM;IAAUkM,UAAUX;GAAI;AACtCA,QAAA+B,OAAOpX,KAAKqV,MAAM,CAAC;AAEZ,SAAArV,IAAIqV,SAAS,KAAK;AAC7B,QAAI6D,UAAU7D;AAEd,QAAIrV,IAAIuG,MAAM8O,KAAKA,MAAM,CAAC,MAAM,OAAO;AAC/BA,YAAA+B,OAAOpX,KAAKqV,MAAM,CAAC;AACzB,UAAIrV,IAAIqV,SAAS,OAAOrV,IAAIqV,SAAS,KAAK;AACxC,YAAIjK,OAAOiM,UAAUrX,KAAKqV,KAAK,CAAC;AAChC,YAAIjK,KAAK/K,SAAS;AAAgB,iBAAA+K;AAClC6J,cAAMxV,KAAK;UAACqK,MAAM;UAAgBkM,UAAUkD;SAAQ;AAC5CjE,gBAAAA,MAAMjN,OAAOoD,KAAK6J,KAAK;AAC/BI,cAAMjK,KAAK4K;MAAA,OACN;AACLf,cAAMxV,KAAK;UAACqK,MAAM;UAAqBkM,UAAUkD;SAAQ;MAC3D;IAAA,OACK;AACL,UAAI9N,OAAOiM,UAAUrX,KAAKqV,KAAK,CAAC;AAChC,UAAIjK,KAAK/K,SAAS;AAAgB,eAAA+K;AAClC,UAAIqN,UAAUrB,OAAOpX,KAAKoL,KAAK4K,QAAQ;AACnC,UAAA5K,KAAK6J,MAAM,GAAGnL,SAAS,SAAS9J,IAAIyY,aAAa,KAAK;AACpD,YAAA7X,QAAQyW,UAAUrX,KAAKoX,OAAOpX,KAAKyY,UAAU,CAAC,GAAG,CAAC;AACtD,YAAI7X,MAAMP,SAAS;AAAgB,iBAAAO;AACnCqU,cAAMxV,KAAK;UAACqK,MAAM;UAAekM,UAAUkD;SAAQ;AACnDjE,gBAAQA,MAAMjN,OAAOoD,KAAK6J,OAAOrU,MAAMqU,KAAK;AAC5CI,cAAMzU,MAAMoV;MAAA,OACP;AACGf,gBAAAA,MAAMjN,OAAO;UAAC8B,MAAM;UAAekM,UAAUX;QAAM,GAAAjK,KAAK6J,KAAK;AACrEI,cAAMjK,KAAK4K;MACb;IACF;AACMX,UAAA+B,OAAOpX,KAAKqV,GAAG;AACjB,QAAArV,IAAIqV,SAAS;AAAK;AAChBA,UAAA+B,OAAOpX,KAAKqV,MAAM,CAAC;EAC3B;AAEI,MAAArV,IAAIqV,SAAS,KAAK;AACpB,WAAO;MAAChV,MAAM;MAAS2V,UAAUX;IAAG;EACtC;AAEAA;AACAJ,QAAMxV,KAAK;IAACqK,MAAM;IAAckM,UAAUX;GAAI;AAC9C,SAAO;IAAChV,MAAM;IAAW4U;IAAOe,UAAUX;EAAG;AAC/C;AAEA,SAASsC,YAAY3X,KAAKqV,KAAK;AACzB,MAAAjP,QAAQpG,IAAIqV;AAChBA,QAAMA,MAAM;AACZ,QAAMJ,QAAQ,CAAC;IAACnL,MAAM;IAAOkM,UAAUX;GAAI;AAC3CrV;AAAK,aAASqV,OAAO;AACnB,UAAIA,MAAMrV,IAAIgB;AAAQ,eAAO;UAACX,MAAM;UAAS2V,UAAUX;QAAG;AAElD,cAAArV,IAAIqV,MAAM;QAChB,KAAKjP,OAAO;AACV6O,gBAAMxV,KAAK;YAACqK,MAAM;YAAWkM,UAAUX;WAAI;AAC3CA;AACM,gBAAArV;QACR;QACA,KAAK,MAAM;AACTiV,gBAAMxV,KAAK;YAACqK,MAAM;YAAakM,UAAUX;WAAI;AAC7C,cAAIrV,IAAIqV,MAAM,OAAO,KAAK;AACxB,gBAAIrV,IAAIqV,MAAM,OAAO,KAAK;AACxBJ,oBAAMxV,KAAK;gBAACqK,MAAM;gBAAekM,UAAUX,MAAM;eAAE;AACnDA,oBAAMrV,IAAImZ,QAAQ,KAAK9D,MAAM,CAAC;AAC9BJ,oBAAMxV,KAAK;gBAACqK,MAAM;gBAAmBkM,UAAUX;eAAI;YAAA,OAC9C;AACLJ,oBAAMxV,KAAK;gBAACqK,MAAM;gBAAekM,UAAUX,MAAM;eAAE;AACnDJ,oBAAMxV,KAAK;gBAACqK,MAAM;gBAAmBkM,UAAUX,MAAM;eAAE;AAChDA,qBAAA;YACT;UAAA,OACK;AACLJ,kBAAMxV,KAAK;cAACqK,MAAM;cAAiBkM,UAAUX,MAAM;aAAE;AAC9CA,mBAAA;UACT;AACAJ,gBAAMxV,KAAK;YAACqK,MAAM;YAAakM,UAAUX,MAAM;WAAE;QACnD;MAAA;IAEJ;AAEA,SAAO;IAAChV,MAAM;IAAW4U;IAAOe,UAAUX;EAAG;AAC/C;AAEA,SAAS+B,OAAOpX,KAAKqV,KAAK;AACxB,SAAOA,MAAMwC,WAAW7X,KAAKqV,KAAKa,EAAE;AACtC;AAKA,SAAS2B,WAAW7X,KAAKqV,KAAK/V,IAAI;AAChC,MAAI8Z,IAAI9Z,GAAG+Z,KAAKrZ,IAAIuG,MAAM8O,GAAG,CAAC;AAC9B,SAAO+D,IAAIA,EAAE,GAAGpY,SAAS;AAC3B;AAKA,SAAS4X,cAAc5Y,KAAKqV,KAAK/V,IAAI;AACnC,MAAI8Z,IAAI9Z,GAAG+Z,KAAKrZ,IAAIuG,MAAM8O,GAAG,CAAC;AACvB,SAAA+D,IAAIA,EAAE,KAAK;AACpB;AC3xBA,SAASzZ,KAAKuF,GAAcC,GAAyB;AACnD,SAAQ4F,UAAmB5F,EAAED,EAAE6F,IAAI,CAAC;AACtC;AAKA,SAAS7E,IAAIgI,OAA6B;AACxC,SAAQnD,WAAoB;IAAC1K,MAAM;IAAO0K;IAAMK,MAAM8C,MAAM;MAAC7N,MAAM;IAAO,CAAA;EAAC;AAC7E;AAEA,SAASiZ,QAAQpL,OAA6B;AAC5C,SAAQnD,WAAoB;IAAC1K,MAAM;IAAW0K;IAAMK,MAAM8C,MAAM;MAAC7N,MAAM;IAAO,CAAA;EAAC;AACjF;AAOgB,SAAAkZ,cAAcC,OAAkBhS,OAAgD;AAC9F,MAAI,CAACA,OAAO;AACH,WAAA;MACLnH,MAAM;MACNmZ;IAAA;EAEJ;AAEA,UAAQhS,MAAMnH,MAAM;IAClB,KAAK;AACI,aAAA;QACLA,MAAM;QACNmZ,OAAO7Z,KAAK6Z,OAAOhS,MAAMgS,KAAK;MAAA;IAGlC,KAAK;AACI,aAAA;QACLnZ,MAAM;QACNmZ,OAAO7Z,KAAK6Z,OAAOhS,MAAMgS,KAAK;MAAA;IAGlC,KAAK;AACI,aAAA;QACLnZ,MAAM;QACNmZ,OAAO7Z,KAAK6Z,OAAOtT,IAAIsB,MAAMgS,KAAK,CAAC;MAAA;IAGvC,KAAK;AACI,aAAA;QACLnZ,MAAM;QACNmZ,OAAO7Z,KAAK6Z,OAAOF,QAAQ9R,MAAMgS,KAAK,CAAC;MAAA;IAG3C;AACE,YAAM,IAAIpW,MAAA,iBAAA,OAAuBoE,MAAMnH,IAAM,CAAA;EAAA;AAEnD;AAEgB,SAAAoZ,cAAcrG,QAAmB5L,OAAgD;AAC/F,MAAI,CAACA,OAAO;AACH,WAAA;MACLnH,MAAM;MACNmZ,OAAOpG;IAAA;EAEX;AAEA,UAAQ5L,MAAMnH,MAAM;IAClB,KAAK;IACL,KAAK;AACI,aAAA;QACLA,MAAM;QACNmZ,OAAO7Z,KAAKyT,QAAQ5L,MAAMgS,KAAK;MAAA;IAGnC,KAAK;IACL,KAAK;AACI,aAAA;QACLnZ,MAAM;QACNmZ,OAAO7Z,KAAKyT,QAAQ5L,MAAMgS,KAAK;MAAA;IAGnC;AACE,YAAM,IAAIpW,MAAA,iBAAA,OAAuBoE,MAAMnH,IAAM,CAAA;EAAA;AAEnD;AAEgB,SAAAqZ,gBAAgBtG,QAAmB5L,OAAgD;AACjG,MAAI,CAACA,OAAO;AACH,WAAA;MACLnH,MAAM;MACNmZ,OAAOpG;IAAA;EAEX;AAEA,UAAQ5L,MAAMnH,MAAM;IAClB,KAAK;IACL,KAAK;AACI,aAAA;QACLA,MAAM;QACNmZ,OAAO7Z,KAAKyT,QAAQ5L,MAAMgS,KAAK;MAAA;IAGnC,KAAK;IACL,KAAK;AACI,aAAA;QACLnZ,MAAM;QACNmZ,OAAO7Z,KAAKyT,QAAQ5L,MAAMgS,KAAK;MAAA;IAGnC;AACE,YAAM,IAAIpW,MAAA,iBAAA,OAAuBoE,MAAMnH,IAAM,CAAA;EAAA;AAEnD;AAEgB,SAAAsZ,mBACdvG,QACA5L,OACiB;AACjB,MAAI,CAACA,OAAO;AACH,WAAA;MACLnH,MAAM;MACNmZ,OAAOpG;IAAA;EAEX;AAEA,UAAQ5L,MAAMnH,MAAM;IAClB,KAAK;AACI,aAAA;QACLA,MAAM;QACNmZ,OAAO7Z,KAAKuG,IAAIkN,MAAM,GAAG5L,MAAMgS,KAAK;MAAA;IAExC,KAAK;AACI,aAAA;QACLnZ,MAAM;QACNmZ,OAAO7Z,KAAKuG,IAAIkN,MAAM,GAAG5L,MAAMgS,KAAK;MAAA;IAExC,KAAK;AACI,aAAA;QACLnZ,MAAM;QACNmZ,OAAO7Z,KAAKyT,QAAQ5L,MAAMgS,KAAK;MAAA;IAEnC,KAAK;AACI,aAAA;QACLnZ,MAAM;QACNmZ,OAAO7Z,KAAKyT,QAAQ5L,MAAMgS,KAAK;MAAA;IAEnC;AACE,YAAM,IAAIpW,MAAA,iBAAA,OAAuBoE,MAAMnH,IAAM,CAAA;EAAA;AAEnD;ACpIA,IAAMuZ,kBAAsD;EAC1D,KAAK;EACL,KAAK;EACL,MAAM;EACN,KAAK;EACLzU,GAAG;EACH0U,GAAG;EACH3P,GAAG;EACH4P,GAAG;EACHC,GAAG;AACL;AAEA,SAASC,UAAUha,KAAqB;AAChC,QAAAia,WAAWC,SAASla,KAAK,EAAE;AAC1B,SAAAma,OAAOC,aAAaH,QAAQ;AACrC;AAEA,IAAMI,iBAAN,cAA6BjX,MAAM;EAAnCvD,cAAA;AAAA,UAAA,GAAAya,SAAA;AACE,SAAOxQ,OAAO;EAAA;AAChB;AAEA,IAAMyQ,eAAsC;EAC1CC,MAAMC,GAAG;AACD,UAAAvM,QAAQuM,EAAEjF,QAAQ+E,YAAY;AAC7B,WAAA;MACLla,MAAM;MACN0K,MAAMmD;IAAA;EAEV;EAEAwM,aAAa;AACJ,WAAA;MAACra,MAAM;;EAChB;EAEAsa,OAAO;AACE,WAAA;MAACta,MAAM;;EAChB;EAEAwI,SAAS;AACA,WAAA;MACLxI,MAAM;MACN6J,GAAG;IAAA;EAEP;EAEA0Q,UAAUH,GAAG;AACL,UAAA3V,OAAO2V,EAAEjF,QAAQ+E,YAAY;AAC5B,WAAA;MACLla,MAAM;MACN6J,GAAGpF,KAAKoF,IAAI;IAAA;EAEhB;EAEA2Q,SAASJ,GAAG;AACJ,UAAA1P,OAAO0P,EAAEjF,QAAQ+E,YAAY;AACnC,UAAMO,gBAA2E,CAAA;AACjF,WAAOL,EAAEnF,QAAA,EAAUxL,SAAS,iBAAiB;AAC3CgR,oBAAcrb,KAAKgb,EAAEjF,QAAQuF,gBAAgB,CAAC;IAChD;AACAN,MAAElF,MAAM;AACR,QAAIyF,YAAoC;AACxC,aAASja,IAAI+Z,cAAc9Z,SAAS,GAAGD,KAAK,GAAGA,KAAK;AACtCia,kBAAAF,cAAc/Z,GAAGia,SAAS;IACxC;AACI,QAAAjQ,KAAK1K,SAAS,gBAAgB0K,KAAK1K,SAAS,WAAW0K,KAAK1K,SAAS,gBAAgB;AACvF2a,kBAAYzB,cAAexU,SAAQA,KAAKiW,SAAS;IACnD;AACA,QAAIA,cAAc;AAAY,YAAA,IAAI5X,MAAM,iCAAiC;AAClE,WAAA4X,UAAUxB,MAAMzO,IAAI;EAC7B;EAEAkQ,UAAUR,GAAG;AACL,UAAA3Q,OAAO2Q,EAAE7E,cAAc;AAE7B,QAAI9L,SAAS,QAAQ;AACnB,aAAO;QAACzJ,MAAM;QAASO,OAAO;MAAI;IACpC;AACA,QAAIkJ,SAAS,QAAQ;AACnB,aAAO;QAACzJ,MAAM;QAASO,OAAO;MAAI;IACpC;AACA,QAAIkJ,SAAS,SAAS;AACpB,aAAO;QAACzJ,MAAM;QAASO,OAAO;MAAK;IACrC;AAEO,WAAA;MACLP,MAAM;MACNyJ;IAAA;EAEJ;EAEAoR,IAAIT,GAAG;AACC,UAAA1P,OAAO0P,EAAEjF,QAAQ+E,YAAY;AAE5B,WAAA;MACLla,MAAM;MACN0K;IAAA;EAEJ;EAEAsK,IAAIoF,GAAG;AACC,UAAA1P,OAAO0P,EAAEjF,QAAQ+E,YAAY;AAE5B,WAAA;MACLla,MAAM;MACN0K;IAAA;EAEJ;EAEAjH,IAAI2W,GAAG;AACC,UAAAlT,OAAOkT,EAAEjF,QAAQ+E,YAAY;AAC7B,UAAA/S,QAAQiT,EAAEjF,QAAQ+E,YAAY;AAC7B,WAAA;MACLla,MAAM;MACNgK,IAAI;MACJ9C;MACAC;IAAA;EAEJ;EAEA2T,IAAIV,GAAG;AACC,UAAAlT,OAAOkT,EAAEjF,QAAQ+E,YAAY;AAC7B,UAAA/S,QAAQiT,EAAEjF,QAAQ+E,YAAY;AAC7B,WAAA;MACLla,MAAM;MACNgK,IAAI;MACJ9C;MACAC;IAAA;EAEJ;EAEA4T,IAAIX,GAAG;AACC,UAAAlT,OAAOkT,EAAEjF,QAAQ+E,YAAY;AAC7B,UAAA/S,QAAQiT,EAAEjF,QAAQ+E,YAAY;AAC7B,WAAA;MACLla,MAAM;MACNgK,IAAI;MACJ9C;MACAC;IAAA;EAEJ;EAEA6T,IAAIZ,GAAG;AACC,UAAAlT,OAAOkT,EAAEjF,QAAQ+E,YAAY;AAC7B,UAAA/S,QAAQiT,EAAEjF,QAAQ+E,YAAY;AAC7B,WAAA;MACLla,MAAM;MACNgK,IAAI;MACJ9C;MACAC;IAAA;EAEJ;EAEA8T,IAAIb,GAAG;AACC,UAAAlT,OAAOkT,EAAEjF,QAAQ+E,YAAY;AAC7B,UAAA/S,QAAQiT,EAAEjF,QAAQ+E,YAAY;AAC7B,WAAA;MACLla,MAAM;MACNgK,IAAI;MACJ9C;MACAC;IAAA;EAEJ;EAEAe,IAAIkS,GAAG;AACC,UAAAlT,OAAOkT,EAAEjF,QAAQ+E,YAAY;AAC7B,UAAA/S,QAAQiT,EAAEjF,QAAQ+E,YAAY;AAC7B,WAAA;MACLla,MAAM;MACNgK,IAAI;MACJ9C;MACAC;IAAA;EAEJ;EAEA+T,KAAKd,GAAG;AACA,UAAAlT,OAAOkT,EAAEjF,QAAQ+E,YAAY;AAC7B,UAAAlQ,KAAKoQ,EAAE7E,cAAc;AACrB,UAAApO,QAAQiT,EAAEjF,QAAQ+E,YAAY;AAC7B,WAAA;MACLla,MAAM;MACNgK;MACA9C;MACAC;IAAA;EAEJ;EAEAgU,SAASf,GAAG;AACJ,UAAA1P,OAAO0P,EAAEjF,QAAQ+E,YAAY;AACnC,UAAMvP,cAAcyP,EAAEnF,QAAQ,EAAExL,SAAS;AACzC2Q,MAAElF,MAAM;AACF,UAAAhO,OAAOkT,EAAEjF,QAAQ+E,YAAY;AAC7B,UAAA/S,QAAQiT,EAAEjF,QAAQ+E,YAAY;AAC7B,WAAA;MACLla,MAAM;MACN0K;MACAxD;MACAC;MACAwD;IAAA;EAEJ;EAEAhL,IAAIya,GAAG;AACL,QAAI7Z,QAAQ;AAEZwX;AAAa,aAAAqC,EAAErF,QAAAA,GAAW;AAClB,cAAAM,OAAO+E,EAAEnF,QAAQ;AACvB,gBAAQI,KAAK5L,MAAM;UACjB,KAAK;AACHlJ,qBAAS6Z,EAAE5E,iBAAiB;AAEtB,kBAAAuC;UACR,KAAK;AACHxX,qBAAS6Z,EAAE5E,iBAAiB;AAC5B;UACF,KAAK;AACH4E,cAAElF,MAAM;AACR;UACF,KAAK,iBAAiB;AACd,kBAAAkG,OAAOhB,EAAElU,MAAM,CAAC;AACtBkU,cAAElF,MAAM;AACR3U,qBAASgZ,gBAAgB6B;AACzB;UACF;UACA,KAAK;AACHhB,cAAElF,MAAM;AACC3U,qBAAAoZ,UAAUS,EAAE5E,iBAAA,CAAkB;AACvC;UACF;AACE,kBAAM,IAAIzS,MAAA,oBAAA,OAA0BsS,KAAK5L,IAAM,CAAA;QAAA;MAErD;AACO,WAAA;MAACzJ,MAAM;MAASO;;EACzB;EAEA8a,QAAQjB,GAAG;AACH,UAAAkB,WAAWlB,EAAE5E,iBAAiB;AAC7B,WAAA;MACLxV,MAAM;MACNO,OAAOyD,OAAOsX,QAAQ;IAAA;EAE1B;EAEAC,MAAMnB,GAAG;AACD,UAAAkB,WAAWlB,EAAE5E,iBAAiB;AAC7B,WAAA;MACLxV,MAAM;MACNO,OAAOyD,OAAOsX,QAAQ;IAAA;EAE1B;EAEAE,IAAIpB,GAAG;AACC,UAAAkB,WAAWlB,EAAE5E,iBAAiB;AAC7B,WAAA;MACLxV,MAAM;MACNO,OAAOyD,OAAOsX,QAAQ;IAAA;EAE1B;EAEAG,OAAOrB,GAAG;AACR,UAAM3N,aAAoC,CAAA;AAC1C,WAAO2N,EAAEnF,QAAA,EAAUxL,SAAS,cAAc;AACxCgD,iBAAWrN,KAAKgb,EAAEjF,QAAQuG,cAAc,CAAC;IAC3C;AACAtB,MAAElF,MAAM;AAED,WAAA;MACLlV,MAAM;MACNyM;IAAA;EAEJ;EAEAX,MAAMsO,GAAG;AACP,UAAMtN,WAA+B,CAAA;AACrC,WAAOsN,EAAEnF,QAAA,EAAUxL,SAAS,aAAa;AACvC,UAAIsD,UAAU;AACd,UAAIqN,EAAEnF,QAAA,EAAUxL,SAAS,eAAe;AAC5BsD,kBAAA;AACVqN,UAAElF,MAAM;MACV;AACM,YAAA3U,QAAQ6Z,EAAEjF,QAAQ+E,YAAY;AACpCpN,eAAS1N,KAAK;QACZY,MAAM;QACNO;QACAwM;MAAA,CACD;IACH;AACAqN,MAAElF,MAAM;AACD,WAAA;MACLlV,MAAM;MACN8M;IAAA;EAEJ;EAEAqG,MAAMiH,GAAG;AACP,UAAMuB,UAAsB,CAAA;AAC5B,WAAOvB,EAAEnF,QAAA,EAAUxL,SAAS,aAAa;AACvCkS,cAAQvc,KAAKgb,EAAEjF,QAAQ+E,YAAY,CAAC;IACtC;AACAE,MAAElF,MAAM;AACD,WAAA;MACLlV,MAAM;MACN2b;IAAA;EAEJ;EAEAC,UAAUxB,GAAG;AACX,QAAIyB,YAAY;AAChB,QAAIzB,EAAEnF,QAAA,EAAUxL,SAAS,aAAa;AACpC2Q,QAAElF,MAAM;AACR2G,kBAAYzB,EAAE7E,cAAc;IAC9B;AAEM,UAAA9L,OAAO2Q,EAAE7E,cAAc;AACzB,QAAAsG,cAAc,YAAYpS,SAAS,UAAU;AAC/C,YAAMnJ,SAAqB;QACzBN,MAAM;QACNoK,cAAc,CAAA;MAAC;AAGjB,aAAOgQ,EAAEnF,QAAA,EAAUxL,SAAS,iBAAiB;AAC3C,YAAI2Q,EAAEnF,QAAA,EAAUxL,SAAS,QAAQ;AAC/B,cAAInJ,OAAO+J;AAAgB,kBAAA,IAAI2P,eAAAA,iCAAAA;AAC/BI,YAAElF,MAAM;AACF,gBAAA1K,YAAY4P,EAAEjF,QAAQ+E,YAAY;AAClC,gBAAA3Z,QAAQ6Z,EAAEjF,QAAQ+E,YAAY;AACpC5Z,iBAAO8J,aAAahL,KAAK;YACvBY,MAAM;YACNwK;YACAjK;UAAA,CACD;QAAA,OACI;AACL,cAAID,OAAO+J;AAAgB,kBAAA,IAAI2P,eAAAA,iCAAAA;AACzB,gBAAAzZ,QAAQ6Z,EAAEjF,QAAQ+E,YAAY;AACpC5Z,iBAAO+J,WAAW9J;QACpB;MACF;AACA6Z,QAAElF,MAAM;AACD,aAAA5U;IACT;AAEA,UAAMgL,OAAmB,CAAA;AAEzB,WAAO8O,EAAEnF,QAAA,EAAUxL,SAAS,iBAAiB;AAC3C,UAAIqS,yBAAyBD,WAAWpS,MAAM6B,KAAK3K,MAAM,GAAG;AAG1DyZ,UAAEjF,QAAQ4G,gBAAgB;AAC1BzQ,aAAKlM,KAAK;UAACY,MAAM;QAAW,CAAA;MAAA,OACvB;AACLsL,aAAKlM,KAAKgb,EAAEjF,QAAQ+E,YAAY,CAAC;MACnC;IACF;AAEAE,MAAElF,MAAM;AAER,QAAI2G,cAAc,aAAapS,SAAS,YAAYA,SAAS,UAAU;AACjE,UAAA2Q,EAAEvF,aAAaZ,SAAS,SAAS;AAC5B,eAAA;UACLjU,MAAM;UACN2J,KAAKF;QAAA;MAET;IACF;AAEA,QAAIoS,cAAc,YAAYpS,SAAS,WAAW,CAAC2Q,EAAEtF;AAC7C,YAAA,IAAIkF,eAAe,kBAAkB;AAEvC,UAAAgC,QAAQvH,WAAWoH;AACzB,QAAI,CAACG,OAAO;AACJ,YAAA,IAAIhC,eAAe,wBAAA,OAAwB6B,SAAW,CAAA;IAC9D;AAEM,UAAA7S,OAAOgT,MAAMvS;AACnB,QAAI,CAACT,MAAM;AACH,YAAA,IAAIgR,eAAe,uBAAA,OAAuBvQ,IAAM,CAAA;IACxD;AACI,QAAAT,KAAK0H,UAAU,QAAW;AAC5BuL,oBAAcxS,MAAMT,KAAK0H,OAAOpF,KAAK3K,MAAM;IAC7C;AAEA,QAAIqI,KAAKiL,SAAS,UAAajL,KAAKiL,SAASmG,EAAEvF,aAAaZ,MAAM;AAC1D,YAAA,IAAI+F,eAAe,uBAAA,OAAuBvQ,IAAM,CAAA;IACxD;AAEO,WAAA;MACLzJ,MAAM;MACNgJ;MACAS;MACA6B;IAAA;EAEJ;EAEA4Q,SAAS9B,GAAG;AACJ,UAAA1P,OAAO0P,EAAEjF,QAAQ+E,YAAY;AACnCE,MAAElF,MAAM;AAER,QAAI2G,YAAY;AAChB,QAAIzB,EAAEnF,QAAA,EAAUxL,SAAS,aAAa;AACpC2Q,QAAElF,MAAM;AACR2G,kBAAYzB,EAAE7E,cAAc;IAC9B;AACA,QAAIsG,cAAc,UAAU;AACpB,YAAA,IAAI7B,eAAe,wBAAA,OAAwB6B,SAAW,CAAA;IAC9D;AAEM,UAAApS,OAAO2Q,EAAE7E,cAAc;AAC7B,UAAMjK,OAAmB,CAAA;AAEzB,UAAM6Q,gBAAgB/B,EAAEtF;AACxB,QAAIrL,SAAS,SAAS;AAEpB2Q,QAAEtF,aAAa;IACjB;AAES,eAAA;AACD,YAAAsH,WAAWhC,EAAEnF,QAAA,EAAUxL;AAC7B,UAAI2S,aAAa,iBAAiB;AAChC;MACF;AAEA,UAAI3S,SAAS,SAAS;AACpB,YAAI2S,aAAa,OAAO;AACtBhC,YAAElF,MAAM;AACH5J,eAAAlM,KAAK;YAACY,MAAM;YAAO0K,MAAM0P,EAAEjF,QAAQ+E,YAAY;UAAA,CAAE;AACtD;QAAA,WACSkC,aAAa,QAAQ;AAC9BhC,YAAElF,MAAM;AACH5J,eAAAlM,KAAK;YAACY,MAAM;YAAQ0K,MAAM0P,EAAEjF,QAAQ+E,YAAY;UAAA,CAAE;AACvD;QACF;MACF;AAEA5O,WAAKlM,KAAKgb,EAAEjF,QAAQ+E,YAAY,CAAC;IACnC;AACAE,MAAElF,MAAM;AAERkF,MAAEtF,aAAaqH;AAET,UAAAnT,OAAO2J,cAAclJ;AAC3B,QAAI,CAACT,MAAM;AACH,YAAA,IAAIgR,eAAe,4BAAA,OAA4BvQ,IAAM,CAAA;IAC7D;AACA,QAAIT,KAAK0H,OAAO;AACduL,oBAAcxS,MAAMT,KAAK0H,OAAOpF,KAAK3K,MAAM;IAC7C;AAEO,WAAA;MACLX,MAAM;MACNgJ;MACA0B;MACAjB;MACA6B;IAAA;EAEJ;EAEA+Q,KAAKjC,GAAG;AACA,UAAA,IAAIJ,eAAAA,eAAAA;EACZ;EAEAsC,IAAIlC,GAAG;AACC,UAAAlT,OAAOkT,EAAEjF,QAAQ+E,YAAY;AAC7B,UAAA/S,QAAQiT,EAAEjF,QAAQ+E,YAAY;AAC7B,WAAA;MACLla,MAAM;MACNkH;MACAC;IAAA;EAEJ;EAEAoV,GAAGnC,GAAG;AACE,UAAAlT,OAAOkT,EAAEjF,QAAQ+E,YAAY;AAC7B,UAAA/S,QAAQiT,EAAEjF,QAAQ+E,YAAY;AAC7B,WAAA;MACLla,MAAM;MACNkH;MACAC;IAAA;EAEJ;EAEAqV,IAAIpC,GAAG;AACC,UAAA1P,OAAO0P,EAAEjF,QAAQ+E,YAAY;AAC5B,WAAA;MACLla,MAAM;MACN0K;IAAA;EAEJ;EAEA+R,IAAIrC,GAAG;AACC,UAAA,IAAIJ,eAAe,gBAAgB;EAC3C;EAEA0C,KAAKtC,GAAG;AACA,UAAA,IAAIJ,eAAe,iBAAiB;EAC5C;EAEA2C,MAAMvC,GAAG;AACD,UAAA3Q,OAAO2Q,EAAE7E,cAAc;AAEzB,QAAA6E,EAAEvF,aAAaxM,UAAU+R,EAAEvF,aAAaxM,OAAOoD,eAAehC,IAAI,GAAG;AAChE,aAAA;QACLzJ,MAAM;QACNO,OAAO6Z,EAAEvF,aAAaxM,OAAOoB;MAAI;IAErC;AAEO,WAAA;MACLzJ,MAAM;MACNyJ;IAAA;EAEJ;AACF;AAEA,IAAMiS,iBAAmD;EACvDkB,YAAYxC,GAAG;AACb,QAAIA,EAAEnF,QAAA,EAAUxL,SAAS,QAAQ;AAC/B2Q,QAAElF,MAAM;AACF,YAAA1K,YAAY4P,EAAEjF,QAAQ+E,YAAY;AAClC3Z,YAAAA,SAAQ6Z,EAAEjF,QAAQ+E,YAAY;AAE7B,aAAA;QACLla,MAAM;QACNwK;QACAjK,OAAAA;MAAA;IAEJ;AAEM,UAAAA,QAAQ6Z,EAAEjF,QAAQ+E,YAAY;AAE7B,WAAA;MACLla,MAAM;MACNyJ,MAAMoT,mBAAmBtc,KAAK;MAC9BA;IAAA;EAEJ;EAEAuc,YAAY1C,GAAG;AACP,UAAA3Q,OAAO2Q,EAAEjF,QAAQ+E,YAAY;AACnC,QAAIzQ,KAAKzJ,SAAS;AAAe,YAAA,IAAI+C,MAAM,qBAAqB;AAE1D,UAAAxC,QAAQ6Z,EAAEjF,QAAQ+E,YAAY;AAC7B,WAAA;MACLla,MAAM;MACNyJ,MAAMA,KAAKlJ;MACXA;IAAA;EAEJ;EAEAwc,aAAa3C,GAAoB;AACzB,UAAA7Z,QAAQ6Z,EAAEjF,QAAQ+E,YAAY;AAE7B,WAAA;MACLla,MAAM;MACNO;IAAA;EAEJ;EAEAyc,oBAAqC;AAC5B,WAAA;MACLhd,MAAM;MACNO,OAAO;QAACP,MAAM;MAAM;IAAA;EAExB;AACF;AAEA,IAAM0a,mBAAkF;EACtFuC,eAAe7C,GAAG;AACV,UAAArP,OAAOqP,EAAEjF,QAAQ+E,YAAY;AAE7B,UAAA3Z,QAAQmO,oBAAoB3D,IAAI;AAClC,QAAAxK,SAASA,MAAMP,SAAS,UAAU;AACpC,aAAQmH,WACNkS,gBAAiB3O,WAAU;QAAC1K,MAAM;QAAiB0K;QAAMiB,OAAOpL,MAAMJ;MAAA,IAAQgH,KAAK;IACvF;AAEI,QAAA5G,SAASA,MAAMP,SAAS,UAAU;AACpC,aAAQmH,WACNiS,cAAe1O,WAAU;QAAC1K,MAAM;QAAmB0K;QAAMjB,MAAMlJ,MAAMJ;MAAA,IAAQgH,KAAK;IACtF;AAEA,WAAQA,WACN+R,cACGxO,WAAU;MACT1K,MAAM;MACN0K;MACAK;IAAA,IAEF5D,KAAA;EAEN;EAEAjB,MAAMkU,GAAG;AACP,UAAMzP,cAAcyP,EAAEnF,QAAQ,EAAExL,SAAS;AACzC2Q,MAAElF,MAAM;AAEF,UAAAhO,OAAOkT,EAAEjF,QAAQ+E,YAAY;AAC7B,UAAA/S,QAAQiT,EAAEjF,QAAQ+E,YAAY;AAE9B,UAAAjQ,YAAYyE,oBAAoBxH,IAAI;AACpC,UAAAgD,aAAawE,oBAAoBvH,KAAK;AAExC,QAAA,CAAC8C,aAAa,CAACC,cAAcD,UAAUjK,SAAS,YAAYkK,WAAWlK,SAAS,UAAU;AACtF,YAAA,IAAIga,eAAe,mCAAmC;IAC9D;AAEA,WAAQ5C,SACN8B,cACGxO,WAAU;MACT1K,MAAM;MACN0K;MACAxD,MAAM+C,UAAU9J;MAChBgH,OAAO+C,WAAW/J;MAClBwK;IAAA,IAEFyM,GAAA;EAEN;EAEA8F,WAAW9C,GAAG;AACN,UAAA5V,MAAM4V,EAAEjF,QAAQ+E,YAAY;AAClC,WAAQ/S,WACNmS,mBAAoB5O,WAAU;MAAC1K,MAAM;MAAc0K;MAAYK,MAAMvG;QAAO2C,KAAK;EACrF;EAEAgW,YAAY/C,GAAG;AACP,UAAA3Q,OAAO2Q,EAAE7E,cAAc;AAEtB,WAACpO,WAAUiS,cAAe1O,WAAU;MAAC1K,MAAM;MAAmB0K;MAAMjB;QAAQtC,KAAK;EAC1F;EAEAiW,MAAMhD,GAAG;AACP,QAAI1N,OAAsB;AAE1B,QAAI0N,EAAEnF,QAAA,EAAUxL,SAAS,cAAc;AACrC2Q,QAAElF,MAAM;AACRxI,aAAO0N,EAAE7E,cAAc;IACzB;AAEM,UAAA8H,OAAQ3S,UACZgC,OAAO;MAAC1M,MAAM;MAAmB0K;MAAMjB,MAAMiD;IAAA,IAAQhC;AAEvD,WAAQvD,WACNiS,cACG1O,UACC2S,KAAK;MACHrd,MAAM;MACN0K;IAAA,CACD,GACHvD,KAAA;EAEN;EAEAmW,cAAclD,GAAG;AACR,WAACjT,WAAU+R,cAAexO,WAAU;MAAC1K,MAAM;MAAe0K;IAAI,IAAIvD,KAAK;EAChF;AACF;AAEA,IAAM4U,mBAAsC;EAC1C5B,MAAMC,GAAG;AACPA,MAAEjF,QAAQ4G,gBAAgB;AACnB,WAAA;EACT;EAEA1B,aAAa;AACL,UAAA,IAAItX,MAAM,yBAAyB;EAC3C;EAEAuX,OAAO;AACC,UAAA,IAAIvX,MAAM,yBAAyB;EAC3C;EAEAyF,SAAS;AACD,UAAA,IAAIzF,MAAM,yBAAyB;EAC3C;EAEAwX,UAAUH,GAAG;AACL,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEAyX,SAASJ,GAAG;AACVA,MAAEjF,QAAQ4G,gBAAgB;AAC1B,WAAO3B,EAAEnF,QAAA,EAAUxL,SAAS,iBAAiB;AAC3C2Q,QAAEjF,QAAQuF,gBAAgB;IAC5B;AAEAN,MAAElF,MAAM;AACD,WAAA;EACT;EAEA0F,UAAUR,GAAG;AACXA,MAAE7E,cAAc;AACT,WAAA;EACT;EAEAsF,IAAIT,GAAG;AACC,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEAiS,IAAIoF,GAAG;AACC,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEAU,IAAI2W,GAAG;AACC,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEA+X,IAAIV,GAAG;AACC,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEAgY,IAAIX,GAAG;AACC,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEAiY,IAAIZ,GAAG;AACC,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEAkY,IAAIb,GAAG;AACC,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEAmF,IAAIkS,GAAG;AACC,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEAmY,KAAKd,GAAG;AACA,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEAoY,SAASf,GAAG;AACJ,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEApD,IAAIya,GAAG;AACC,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEAsY,QAAQjB,GAAG;AACH,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEAwY,MAAMnB,GAAG;AACD,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEAyY,IAAIpB,GAAG;AACC,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEA0Y,OAAOrB,GAAG;AACF,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEA+I,MAAMsO,GAAG;AACD,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEAoQ,MAAMiH,GAAG;AAED,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEA6Y,UAAUxB,GAAG/E,MAAM;AACjB,UAAMrM,OAAOkR,aAAa0B,UAAUxB,GAAG/E,IAAI;AAC3C,QAAIrM,KAAKS,SAAS,cAAcT,KAAKsC,KAAK3K,WAAW;AAAU,aAAA;AAEzD,UAAA,IAAIoC,MAAM,yBAAyB;EAC3C;EAEAmZ,SAAS9B,GAAG;AACJ,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEAsZ,KAAKjC,GAAG;AACA,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEAuZ,IAAIlC,GAAG;AACC,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEAwZ,GAAGnC,GAAG;AACE,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEAyZ,IAAIpC,GAAG;AACC,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEA0Z,IAAIrC,GAAG;AACC,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEA2Z,KAAKtC,GAAG;AACA,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;EAEA4Z,MAAMvC,GAAG;AACD,UAAA,IAAIrX,MAAM,yBAAyB;EAC3C;AACF;AAEA,SAAS8Z,mBAAmBhU,MAAwB;AAClD,MAAIA,KAAK7I,SAAS,qBAAqB,CAAC6I,KAAK6B,MAAM;AACjD,WAAO7B,KAAKY;EACd;AAGE,MAAAZ,KAAK7I,SAAS,WACd6I,KAAK7I,SAAS,SACd6I,KAAK7I,SAAS,gBACd6I,KAAK7I,SAAS,WACd6I,KAAK7I,SAAS,YACd6I,KAAK7I,SAAS,mBACd6I,KAAK7I,SAAS,eACd;AACO,WAAA6c,mBAAmBhU,KAAK6B,IAAI;EACrC;AAEA,QAAM,IAAIsP,eAAA,2CAAA,OAA0DnR,KAAK7I,IAAM,CAAA;AACjF;AAEA,SAASic,cAAcxS,MAAciH,OAA0BL,QAAe;AACxE,MAAA,OAAOK,UAAU,UAAU;AAC7B,QAAIL,WAAUK,OAAO;AACnB,YAAM,IAAIsJ,eAAA,6CAAA,OACqCvQ,MAAAA,eAAAA,EAAAA,OAAoBiH,OAAc,QAAA,EAAA,OAAAL,QAAA,GAAA,CAAA;IAEnF;aACSK,OAAO;AACZ,QAAA,CAACA,MAAML,MAAK,GAAG;AACX,YAAA,IAAI2J,eAAe,6CAAA,OAA6CvQ,MAAS,KAAA,CAAA;IACjF;EACF;AACF;AAEA,SAASqS,yBAAyBD,WAAmB0B,cAAsBC,UAAkB;AACrF,QAAAC,8BAA8B,CAAC,cAAc,aAAa;AAEhE,SAAO5B,aAAa,UAAU2B,YAAY,KAAKC,4BAA4BC,SAASH,YAAY;AAClG;AAEA,IAAMI,kBAAN,cAA8B5a,MAAM;EAIlCvD,YAAYmW,UAAkB;AAC5B,UAAA,0CAAA,OAAgDA,QAAU,CAAA;AAH5D,SAAOlM,OAAO;AAIZ,SAAKkM,WAAWA;EAClB;AACF;AAKO,SAASmB,MAAM8G,OAAqD;AAAA,MAAtC5P,UAAwB,UAAA,SAAA,KAAA,UAAA,OAAA,SAAA,UAAA,KAAA,CAAA;AACrD,QAAA1N,SAASud,QAASD,KAAK;AACzB,MAAAtd,OAAON,SAAS,SAAS;AACrB,UAAA,IAAI2d,gBAAgBrd,OAAOqV,QAAQ;EAC3C;AACA,QAAMmI,YAAY,IAAInJ,cAAciJ,OAAOtd,OAAOsU,OAAiB5G,OAAO;AACnE,SAAA8P,UAAU3I,QAAQ+E,YAAY;AACvC;;;;;;;;;;ACp3BA,IAAM6D,6BACJC,iBAEA,OAAOC,WAAW,eAClBD,YAAYE,qBAAqBD,OAAOE,YAAYC,UAAUF;AAEhE,IAAMG,yBAAyB,CAC7BL,aACAM,MACAC,aACS;AACL,MAAAR,2BAA2BC,WAAW,GAAG;AAC/BA,gBAAAE,iBAAiBI,MAAMC,UAAU,KAAK;EACpD;AAGYP,cAAAE,iBAAiBI,MAAMC,QAAQ;AAC7C;AAEgB,SAAAC,OACdC,iBACAC,QACAC,UAKc;AACd,QAAM;IAACC;IAAWC;IAASC;EAAA,IAASJ;AACpC,QAAMK,UAAUD,QAAQ;IAACE,eAAe,UAAA,OAAUF,KAAAA;MAAW;AACvD,QAAAG,MAAA,WAAA,OAAiBL,WAA0C,gCAAA,EAAA,OAAAC,SAAA,+BAAA;AAC3D,QAAAK,KAAK,IAAIT,gBAAgBQ,KAAK;IAACE,iBAAiB;IAAMJ;GAAQ;AAE7CV,yBAAAa,IAAI,WAAWP,SAASS,IAAI;AAEnDf,yBAAuBa,IAAI,YAAYG,kBAAkBV,SAASW,IAAI,CAAC;AAEhDjB,yBAAAa,IAAI,gBAAiBK,SAAa;AACvDL,OAAGM,MAAM;AAEL,QAAAC;AACA,QAAA;AACKA,aAAAC,KAAKC,MAAMJ,IAAIE,IAAI;aACnBG;AACPjB,eAASkB,MAAM,IAAIC,MAAM,wCAAwC,CAAC;AAClE;IACF;AAESnB,aAAAkB,MACP,IAAIC,MAAML,KAAKM,WAAWN,KAAKI,SAAS,0BAAA,OAA0BJ,KAAKO,UAAY,CAAA,CAAA;EACrF,CACD;AAEsB3B,yBAAAa,IAAI,SAAUU,SAAe;AAClD,UAAMK,SAAS,OAAOhC,WAAW,eAAeA,OAAOiC,SAASD;AAC1D,UAAAE,aAAaF,SAAS,+BAAA,OAA+BA,QAAuB,cAAA,IAAA;AAClF,UAAMG,eAAeC,YAAYT,GAAG,IAAI,KAAA,OAAKA,IAAIG,SAAa,GAAA,IAAA;AACrDpB,aAAAkB,MACP,IAAIC,MAAA,kFAAA,OACgFK,UAAa,EAAA,OAAAC,YAAA,CAAA,CACjG;EACF,CACD;AAEM,SAAA;IACLE,aAAa,MAAqBC,QAAQC,QAAQtB,GAAGM,MAAAA,CAAO;EAAA;AAEhE;AAEA,SAASH,kBAAkBoB,IAAwD;AACjF,SAAQlB,SAAa;AACf,QAAAE;AACA,QAAA;AACKA,aAAAC,KAAKC,MAAMJ,IAAIE,IAAI;aACnBG;AAEP;IACF;AAEAa,OAAGhB,IAAI;EAAA;AAEX;AAEA,SAASY,YAAYT,KAAwC;AAC3D,SAAO,OAAOA,QAAQ,YAAYA,QAAQ,QAAQ,aAAaA;AACjE;ACvFO,SAASc,QAAQC,KAA8B;AAC7C,SAAAA,IAAIC,IAAIC,WAAW,SAAS;AACrC;AAEO,SAASC,eAAeC,UAAkC;AACxD,SAAAL,QAAQK,QAAQ,IAAIA,SAASH,IAAII,MAAM,CAAC,IAAID,SAASH;AAC9D;ACLgB,SAAAK,qBACdN,KACAO,OACuB;AACjB,QAAAC,WAAW;IAAC,GAAGR;;AACrB,SAAOQ,SAASC;AACT,SAAAC,WAAWF,UAAUD,KAAK;AACnC;ACJA,IAAMI,cAAc;AAEpB,SAASC,OAAO;AACd,SAAOhB,QAAQC,QAAQ;AACzB;AAEO,SAASgB,kBACd9C,QACA+C,gBAAA,MAEwC;AAAA,MADxC;IAACC,cAAAA;IAAcvD;MACyB;AAClC,QAAA;IACJS;IACAC;IACAL,QAAQmD;IACRC;IACAC;IACA/C;IACAgD;EACE,IAAApD;AAEJ,MAAI,CAACiD,aAAa;AAChB,UAAMI,UAASL,cAAa;MAAC9C;MAAWC;MAASgD;MAAe/C;MAAOgD;IAAa,CAAA,EACjFE,KAAKC,QAAQ,EACbD,KAAKT,IAAI;AACZ,WAAO;MAACjB,aAAaiB;MAAMQ,QAAAA;IAAM;EACnC;AAEM,QAAAG,mBAAA,oBAAuBC,IAA4B;AAGrD,MAAAC;AAGJ,QAAMC,SAA0B,CAAA;AAG5B,MAAAC;AACA,MAAAC;AACJ,QAAMR,SAAS,IAAIxB,QAAc,CAACC,SAASgC,WAAW;AACpCF,oBAAA9B;AACF+B,kBAAAC;EAAA,CACf;AAMG,MAAAC;AACA,MAAAC;AACA,MAAAC;AAEE,QAAApE,WAAWC,OAAOL,aAAaO,QAAQ;IAC3CY,MAAMsD;IACNxD,MAAMyD;IACNhD,OAAQA,WAAiB0C,YAAY1C,KAAK;EAAA,CAC3C;AAED,SAAO;IAACS,aAAa/B,SAAS+B;IAAayB;EAAM;AAEjD,iBAAec,SAAS;AAChB,UAAAC,UAAU,MAAMpB,cAAa;MAAC9C;MAAWC;MAASgD;MAAe/C;MAAOgD;IAAA,CAAa;AAC/EM,gBAAAW,uBAAuBD,SAAST,MAAM;AACxCD,cAAAY,QAASrC,SAAQuB,iBAAiBe,IAAItC,IAAIC,KAAKD,GAAG,CAAC;AAC7DsB,aAASG,SAAS;AACJE,kBAAA;EAChB;AAEA,WAASM,mBAAmBrD,KAAoB;AAC9C,QAAI6C,WAAW;AACbc,oBAAc3D,GAAG;AACjB4D,qBAAef,WAAW7C,GAAG;IAAA,OACxB;AACL8C,aAAOe,KAAK7D,GAAG;IACjB;EACF;AAES,WAAA4D,eAAeE,MAAwB9D,KAAoB;AAClE+D,iBAAaX,YAAY;AAErB,QAAAD,gBAAgBnD,IAAIgE,iBAAiBd,YAAY;AAGnDR,eAASQ,UAAU;AACLC,oBAAA;IAAA,OACT;AACLA,oBAAcnD,IAAIgE;AAClBd,mBAAaY,KAAKrC,MAAM;IAC1B;AAEA2B,mBAAea,WAAWvB,UAAUX,aAAa+B,KAAKrC,MAAAA,CAAO;EAC/D;AAEA,WAASiB,SAASoB,MAAwB;AAC3BZ,iBAAA;AACEE,mBAAA;AACDD,kBAAA;AACdjB,mBAAeG,gBAAgB6B,QAAQJ,IAAI,IAAIA,IAAI;EACrD;AAEA,WAASH,cAAc3D,KAAoB;AACzC,QAAI,CAACA,IAAImE,WAAWnE,IAAIoE,WAAW9C,WAAW,IAAI,GAAG;AACnD;IACF;AAEA,UAAME,WAAWmB,iBAAiB0B,IAAIrE,IAAIoE,UAAU,KAAK;AACzDE,oBAAgBtE,IAAIoE,YAAY1C,qBAAqBF,UAAUxB,IAAImE,QAAQI,KAAK,CAAC;EACnF;AAES,WAAAD,gBAAgBE,IAAYhD,UAAiC;AAC9D,UAAAiD,UAAU9B,iBAAiB0B,IAAIG,EAAE;AACjC,UAAAV,OAAOjB,aAAa,CAAA;AAC1B,UAAM6B,WAAWD,UAAUX,KAAKa,QAAQF,OAAO,IAAI;AAE/C,QAAAC,aAAa,MAAMlD,UAAU;AAE/BsC,WAAKD,KAAKrC,QAAQ;AACDmB,uBAAAe,IAAIc,IAAIhD,QAAQ;eACxBA,UAAU;AAEdsC,WAAAc,OAAOF,UAAU,GAAGlD,QAAQ;AAChBmB,uBAAAe,IAAIc,IAAIhD,QAAQ;IAAA,OAC5B;AAEAsC,WAAAc,OAAOF,UAAU,CAAC;AACvB/B,uBAAiBkC,OAAOL,EAAE;IAC5B;EACF;AACF;AAEA,SAAShB,uBACPX,WACAiC,WACkB;AAEZ,QAAAC,SAAA,oBAAanC,IAA6B;AACtCkC,YAAArB,QAASuB,cAAa;AAC9B,UAAMC,QAAQF,OAAOV,IAAIW,SAASZ,UAAU,KAAK,CAAA;AACjDa,UAAMpB,KAAKmB,QAAQ;AACZD,WAAArB,IAAIsB,SAASZ,YAAYa,KAAK;EAAA,CACtC;AAGMF,SAAAtB,QAAQ,CAACwB,OAAOT,OAAO;AAC5B,UAAMhD,WAAWqB,UAAUqC,KAAM9D,SAAQA,IAAIC,QAAQmD,EAAE;AACvD,QAAI,CAAChD,UAAU;AAGL2D,cAAAC,KAAK,6CAA6CZ,EAAE;AAC5D;IACF;AAIA,QAAIa,mBAAmB;AACvB,QAAIZ,UAAiCjD;AAC/ByD,UAAAxB,QAASuB,cAAa;AACPK,yBAAAA,oBAAoBL,SAASM,gBAAgB9D,SAASK;AACzE,UAAI,CAACwD,kBAAkB;AACrB;MACF;AAEA,UAAIL,SAASb,SAAS;AACpBM,kBAAU/C,qBAAqB+C,SAASO,SAASb,QAAQI,KAAK;MAChE;IAAA,CACD;AAGD1B,cAAU+B,OAAO/B,UAAU8B,QAAQnD,QAAQ,GAAG,GAAGiD,OAAO;EAAA,CACzD;AAEM,SAAA5B;AACT;AAEA,SAASqB,QAAQrB,WAA+C;AACxD,QAAA0C,YAAA,oBAAgB3C,IAA4B;AAExCC,YAAAY,QAASrC,SAAQ;AACzB,UAAMoE,WAAWD,UAAUlB,IAAI9C,eAAeH,GAAG,CAAC;AAClD,QAAIA,IAAIC,IAAIC,WAAW,SAAS,GAAG;AAEjCiE,gBAAU7B,IAAInC,eAAeH,GAAG,GAAGqE,wBAAwBrE,GAAG,CAAC;IAAA,WACtD,CAACoE,UAAU;AAEVD,gBAAA7B,IAAItC,IAAIC,KAAKD,GAAG;IAC5B;EAAA,CACD;AAED,SAAOsE,MAAMC,KAAKJ,UAAUK,OAAA,CAAQ;AACtC;AAIA,SAASH,wBAAwBrE,KAAqC;AACpE,SAAO;IAAC,GAAGA;IAAKC,KAAKE,eAAeH,GAAG;EAAC;AAC1C;ACjMgB,SAAAyE,YAAU1G,QAAgB2G,oBAAmD;AAC3F,MAAIjD,YAA8B,CAAA;AAClC,QAAMkD,mBAAmBC,SAAS7G,OAAO8G,0BAA0B,IAAIC,uBAAuB;AAC9F,QAAMC,sBAA0C,CAAA;AAE5C,MAAA7G;AAEJ,iBAAe8G,cAAc;AAC3B,QAAI,CAAC9G,SAAS;AACFA,gBAAA2C,kBACR9C,QACC2E,UAAS;AACIjB,oBAAAiB;AACKiC,yBAAA;MACnB,GACAD,kBAAA;IAEJ;AAEA,UAAMxG,QAAQkD;EAChB;AAEe,iBAAA6D,MAAeC,WAAmBC,QAA8C;AAC7F,UAAMH,YAAY;AAClB,UAAMI,OAAOpG,MAAMkG,WAAW;MAACC;IAAO,CAAA;AAChC,UAAAE,SAAS,MAAMC,cAASF,MAAa;MAAClH,SAASuD;MAAW0D;KAAO;AACvE,WAAOE,OAAOpC,IAAI;EACpB;AAEA,iBAAesC,YAAYvC,YAAoD;AAC7E,UAAMgC,YAAY;AAClB,WAAOC,MAAMO,KAAA,oBAAA,kBAAA,uBAAA,CAAA,kBAAA,CAAA,EAAA,GAAwB;MAACpC,IAAIJ;KAAW;EACvD;AAEA,iBAAejC,cAAa0E,aAA2D;AACrF,UAAMT,YAAY;AACZ,UAAAU,aAAaD,YAAYE,IAAKvC,QAAAA,aAAAA,OAAoBA,IAAA,OAAA,CAAS,EAAEwC,KAAK,KAAK;AACtE,WAAAX,MAAA,IAAA,OAAUS,YAAa,GAAA,CAAA;EAChC;AAES,WAAAG,UACPX,WACAC,QACAW,UACc;AACV,QAAA,CAAC/H,OAAOF,QAAQ;AACZ,YAAA,IAAIsB,MAAM,iDAAiD;IACnE;AAKA,UAAM4G,eAAe;MAACd,OAAOC;MAAWC;MAAQW;IAAQ;AACxDf,wBAAoBtC,KAAKsD,YAAY;AAErC,QAAIC,eAAe;AACnB,UAAMrG,cAAc,MAAM;AACxB,UAAIqG,cAAc;AAChB,eAAOpG,QAAQC,QAAQ;MACzB;AAEemG,qBAAA;AACfjB,0BAAoBvB,OAAOuB,oBAAoBxB,QAAQwC,YAAY,GAAG,CAAC;AACvE,aAAOnG,QAAQC,QAAQ;IAAA;AAGzBoG,6BAAyBF,YAAY;AACrC,WAAO;MAACpG;IAAW;EACrB;AAEA,WAASsG,yBAAyBF,cAAgC;AACzD,WAAAd,MAAMc,aAAad,OAAOc,aAAaZ,MAAM,EACjD9D,KAAM6E,SAAQ;AACb,UAAI,oBAAoBH,oBAAgBI,uBAAAA,SAAUJ,aAAaK,gBAAgBF,GAAG,GAAG;AACnF;MACF;AAEAH,mBAAaK,iBAAiBF;AACjBH,mBAAAD,SAAS,QAAWI,GAAG;IAAA,CACrC,EACAG,MAAOpH,SAAQ;AACd8G,mBAAaD,SAAS7G,GAAG;IAAA,CAC1B;EACL;AAEA,WAAS6F,0BAA0B;AACjCC,wBAAoB1C,QAAQ4D,wBAAwB;EACtD;AAEA,WAASpH,QAAQ;AACf8F,qBAAiB2B,OAAO;AACxB,WAAOpI,UAAUA,QAAQyB,YAAY,IAAIC,QAAQC,QAAQ;EAC3D;AAEA,SAAO;IAACoF;IAAOM;IAAaxE,cAAAA;IAAc8E;IAAWhH;EAAK;AAC5D;ACjGa,IAAAkC,eAAmD,eAAeA,cAAa,OAY9D;AAAA,MAZ8D;IAC1F9C;IACAC;IACAC;IACA+C;IACAC,eAAe,CAAA;EACjB,IAM8B;AACtB,QAAAoF,UAAA,WAAA,OAAqBtI,WAA0C,gCAAA,EAAA,OAAAC,OAAA;AACrE,QAAMiH,SACJhE,aAAaqF,SAAS,IAAI,IAAIC,gBAAgB;IAACC,OAAOvF,gBAAc,OAAA,SAAAA,aAAAyE,KAAK,GAAI;EAAA,CAAC,IAAI;AAC9E,QAAAtH,MAAA,GAAA,OAASiI,SAAW,GAAA,EAAA,OAAApB,MAAA;AAC1B,QAAM/G,UAAUD,QAAQ;IAACE,eAAe,UAAA,OAAUF,KAAAA;MAAW;AACvD,QAAAwI,WAAW,MAAMC,MAAMtI,KAAK;IAACuI,aAAa;IAAWzI;GAAQ;AAE/D,MAAAuI,SAASG,WAAW,KAAK;AACrB,UAAA,IAAI3H,MAAAA,4BAAAA,OAAkC4H,SAAS,MAAMJ,SAASK,KAAA,CAAM,CAAG,CAAA;EAC/E;AAEM,QAAAC,SAASC,kBAAkBP,SAASQ,IAAI;AACxC,QAAAC,SAASH,OAAOI,UAAU;AAEhC,QAAM5F,YAA8B,CAAA;AAChC,MAAA4D;AACA,MAAAjF;AACD,KAAA;AACQiF,aAAA,MAAM+B,OAAOE,KAAK;AAC3BlH,eAAWiF,OAAOkC;AAEd,QAAAC,cAAcpH,QAAQ,GAAG;AAC3B,YAAM,IAAIjB,MAAA,4BAAA,OAAkCiB,SAASlB,KAAO,CAAA;IACnD,WAAAkB,YAAYqH,mBAAmBrH,QAAQ,GAAG;AACnDqB,gBAAUgB,KAAKrC,QAAQ;IACzB;AAEI,QAAAc,iBAAiBO,UAAU+E,SAAStF,eAAe;AACrDkG,aAAOd,OAAO,wBAAwB;AACtC,YAAM,IAAInH,MAAA,6CAAA,OACqC+B,eAAA,yGAAA,CAAA;IAEjD;EAAA,SACO,CAACmE,OAAOqC;AAEV,SAAAjG;AACT;AAEA,SAASyF,kBAAkBC,MAAsD;AAC/E,MAAI,CAACA,MAAM;AACH,UAAA,IAAIhI,MAAM,mCAAmC;EACrD;AAEI,MAAAiI;AACJ,MAAIO,YAAY;AAEhB,WAASrB,SAAS;AACJqB,gBAAA;AACZ,QAAIP,QAAQ;AACVA,aAAOd,OAAO;IAChB;EACF;AAEA,SAAO,IAAIsB,eAA+B;IACxCC,MAAMC,YAAsC;AAC1CV,eAASD,KAAKE,UAAU;AAClB,YAAAU,UAAU,IAAIC,YAAY;AAChC,UAAItG,SAAS;AAGV0F,aAAAE,KAAA,EACAjG,KAAK4G,aAAa,EAClB5B,MAAOpH,SAAQ6I,WAAW5I,MAAMD,GAAG,CAAC;AAEvC,qBAAegJ,cAAc5C,QAA6D;AACxF,YAAIA,OAAOqC,MAAM;AACf,cAAIC,WAAW;AACb;UACF;AAEAjG,mBAASA,OAAOwG,KAAK;AACjB,cAAAxG,OAAO8E,WAAW,GAAG;AACvBsB,uBAAWjJ,MAAM;AACjB;UACF;AAEAiJ,qBAAWK,QAAQpJ,KAAKC,MAAM0C,MAAM,CAAC;AACrCoG,qBAAWjJ,MAAM;AACjB;QACF;AAEA6C,kBAAUqG,QAAQK,OAAO/C,OAAOkC,OAAO;UAACN,QAAQ;SAAK;AAC/C,cAAAoB,QAAQ3G,OAAO4G,MAAM,IAAI;AAE/B,iBAASC,IAAI,GAAGA,IAAIF,MAAM7B,SAAS,GAAG,EAAE+B,GAAG;AACzC,gBAAMC,OAAOH,MAAME,GAAGL,KAAK;AACvB,cAAAM,KAAKhC,WAAW,GAAG;AACrB;UACF;AAEI,cAAA;AACFsB,uBAAWK,QAAQpJ,KAAKC,MAAMwJ,IAAI,CAAC;mBAC5BvJ;AACP6I,uBAAW5I,MAAMD,GAAG;AACbqH,mBAAA;AACP;UACF;QACF;AAES5E,iBAAA2G,MAAMA,MAAM7B,SAAS;AAE9B,YAAI,CAACY,QAAQ;AACX;QACF;AAEI,YAAA;AACYa,wBAAA,MAAMb,OAAOE,KAAA,CAAM;iBAC1BrI;AACP6I,qBAAW5I,MAAMD,GAAG;QACtB;MACF;IACF;IAEAqH;EAAA,CACD;AACH;AAEA,SAASkB,cAAcnC,QAAyD;AAC9E,MAAI,CAACA,QAAQ;AACJ,WAAA;EACT;AAEI,MAAA,EAAE,WAAWA,WAAW,OAAOA,OAAOnG,UAAU,YAAYmG,OAAOnG,UAAU,MAAM;AAC9E,WAAA;EACT;AAGE,SAAA,iBAAiBmG,OAAOnG,SACxB,OAAQmG,OAAuBnG,MAAMuJ,gBAAgB,YACrD,EAAE,SAASpD;AAEf;AAEA,SAAS0B,SAASI,MAAmB;AACnC,MAAI,OAAOA,SAAS,YAAY,WAAWA,QAAQ,aAAaA,MAAM;AAC7D,WAAAA,KAAK/H,WAAW+H,KAAKjI;EAC9B;AAEO,SAAA;AACT;AAEA,SAASuI,mBAAmBzH,KAA8B;AACxD,SAAO,CAACA,IAAIC,IAAIC,WAAW,IAAI;AACjC;AClKO,SAASwI,mBAAyB;AACvC,QAAMC,WAAW,CAAC,eAAe,kBAAkB,OAAO;AAC1D,QAAMC,cAAcD,SAASE,OAAQC,SAAQ,EAAEA,OAAOxL,OAAO;AAEzD,MAAAsL,YAAYpC,SAAS,GAAG;AAC1B,UAAM,IAAIrH,MAAM,gDAAA,OAAgDyJ,YAAYhD,KAAK,IAAI,CAAG,CAAA;EAC1F;AACF;ACDO,SAASnB,UAAU1G,QAA2B;AANrD,MAAAgL;AAOmBL,mBAAA;AAEjB,QAAMlL,eAAcuL,KAAAhL,OAAOP,gBAAP,OAAAuL,KAAsBzL,OAAOE;AAEjD,MAAIO,OAAOI,OAAO;AACZ,QAAA,CAACJ,OAAOP,aAAa;AACvB,YAAM,IAAI2B,MACR,iFAAA;IAEJ;AACI,QAAApB,OAAOP,gBAAgBF,OAAOE;AAChC,YAAM,IAAI2B,MACR,qKAAA;EAGN;AAEA,SAAO6J,YAAajL,QAAQ;IAC1BP;IACAuD;EAAA,CACD;AACH;",
  "names": ["length", "groq", "strings", "keys", "lastIndex", "length", "slice", "reduce", "acc", "str", "i", "delay", "callback", "options", "noTrailing", "noLeading", "debounceMode", "undefined", "timeoutID", "cancelled", "lastExec", "clearExistingTimeout", "clearTimeout", "cancel", "upcomingOnly", "wrapper", "arguments_", "self", "elapsed", "Date", "now", "exec", "apply", "clear", "setTimeout", "escapeRegExp", "string", "replace", "pathRegExp", "pattern", "re", "part", "split", "push", "RegExp", "join", "Path", "constructor", "patternRe", "matches", "str", "test", "toJSON", "StreamValue", "generator", "type", "ticker", "isDone", "data", "isArray", "get", "result", "value", "Symbol", "asyncIterator", "i", "length", "_nextTick", "currentResolver", "setupTicker", "Promise", "resolve", "tick", "fetch", "RFC3339_REGEX", "parseRFC3339", "Date", "formatRFC3339", "d", "year", "addLeadingZero", "getUTCFullYear", "month", "getUTCMonth", "day", "getUTCDate", "hour", "getUTCHours", "minute", "getUTCMinutes", "second", "getUTCSeconds", "fractionalSecond", "millis", "getMilliseconds", "num", "targetLength", "toString", "StaticValue", "Array", "element", "fromJS", "Error", "NULL_VALUE", "TRUE_VALUE", "FALSE_VALUE", "DateTime", "date", "parseToValue", "equals", "other", "getTime", "add", "secs", "copy", "setTime", "difference", "compareTo", "fromNumber", "Number", "isFinite", "fromString", "fromDateTime", "dt", "fromPath", "path", "isIterator", "obj", "next", "val", "getType", "isEqual", "a", "b", "CHARS", "CHARS_WITH_WILDCARD", "EDGE_CHARS", "MAX_TERM_LENGTH", "matchText", "tokens", "patterns", "every", "matchTokenize", "text", "match", "matchAnalyzePattern", "termsRe", "matchPatternRegex", "map", "some", "token", "terms", "term", "slice", "gatherText", "cb", "success", "TYPE_ORDER", "datetime", "number", "boolean", "partialCompare", "aType", "bType", "totalCompare", "aTypeOrder", "bTypeOrder", "operators", "eq", "left", "right", "neq", "gt", "gte", "lt", "lte", "in", "inop", "concat", "didSucceed", "matched", "plus", "minus", "numericOperator", "Math", "pow", "impl", "Scope", "params", "source", "context", "parent", "isHidden", "createNested", "createHidden", "evaluate", "node", "scope", "execute", "func", "EXECUTORS", "promiselessApply", "then", "This", "_", "Selector", "Everything", "Parameter", "name", "Context", "key", "Parent", "n", "current", "OpCall", "op", "leftValue", "rightValue", "Select", "alternatives", "fallback", "alt", "altCond", "condition", "InRange", "base", "isInclusive", "leftCmp", "rightCmp", "Filter", "expr", "baseValue", "elem", "newScope", "exprValue", "Projection", "FuncCall", "args", "PipeFuncCall", "AccessAttribute", "hasOwnProperty", "AccessElement", "index", "finalIndex", "Slice", "array", "leftIdx", "rightIdx", "Deref", "id", "_ref", "doc", "_id", "Value", "Group", "Object", "attributes", "attr", "attrType", "cond", "assign", "elements", "isSplat", "v", "Tuple", "Or", "And", "Not", "Neg", "Pos", "Asc", "Desc", "ArrayCoerce", "Map", "FlatMap", "innerValue", "inner", "evaluateQuery", "tree", "options", "root", "dataset", "timestamp", "identity", "sanity", "after", "before", "canConstantEvaluate", "DUMMY_SCOPE", "tryConstantEvaluate", "constantEvaluate", "portableTextContent", "blockText", "texts", "arrayText", "block", "_type", "children", "child", "BM25k", "evaluateScore", "evaluateMatchScore", "innerScore", "boost", "leftScore", "rightScore", "res", "score", "freq", "reduce", "c", "hasReference", "pathSet", "has", "values", "countUTF8", "count", "code", "charCodeAt", "_global", "anywhere", "arity", "coalesce", "arg", "dateTime", "defined", "references", "Set", "size", "scopeValue", "round", "prec", "precValue", "isInteger", "toFixed", "now", "toISOString", "lower", "toLowerCase", "upper", "toUpperCase", "sep", "from", "startsWith", "prefix", "arr", "buf", "needSep", "compact", "unique", "added", "iter", "pt", "projectId", "pipeFunctions", "order", "mappers", "directions", "mapper", "direction", "aux", "idx", "tuple", "sort", "aTuple", "bTuple", "unknown", "scored", "valueScore", "_score", "newObject", "delta", "operation", "hasBefore", "hasAfter", "changedAny", "mode", "changedOnly", "diff", "math", "min", "max", "sum", "avg", "namespaces", "global", "MarkProcessor", "marks", "parseOptions", "allowBoost", "hasMark", "pos", "getMark", "shift", "process", "visitor", "mark", "call", "processString", "processStringEnd", "prev", "curr", "position", "len", "WS", "NUM", "IDENT", "PREC_PAIR", "PREC_OR", "PREC_AND", "PREC_COMP", "PREC_ORDER", "PREC_ADD", "PREC_SUB", "PREC_MUL", "PREC_DIV", "PREC_MOD", "PREC_POW", "PREC_POS", "PREC_NOT", "PREC_NEG", "parse", "skipWS", "parseExpr", "failPosition", "level", "startPos", "rhs", "parseObject", "parseString", "identLen", "parseRegex", "numLen", "fracLen", "expLen", "parseFuncCall", "lhsLevel", "trav", "loop", "innerPos", "parseTraversal", "unshift", "nextToken", "nextPos", "identPos", "ident", "parseRegexStr", "isGroup", "rangePos", "identStart", "nameLen", "lastPos", "pairPos", "indexOf", "m", "exec", "flatMap", "traverseArray", "build", "traversePlain", "traverseElement", "traverseProjection", "ESCAPE_SEQUENCE", "f", "r", "t", "expandHex", "charCode", "parseInt", "String", "fromCharCode", "GroqQueryError", "arguments", "EXPR_BUILDER", "group", "p", "everything", "this", "dblparent", "traverse", "traversalList", "TRAVERSE_BUILDER", "traversal", "this_attr", "neg", "sub", "mul", "div", "mod", "comp", "in_range", "char", "integer", "strValue", "float", "sci", "object", "OBJECT_BUILDER", "members", "func_call", "namespace", "argumentShouldBeSelector", "SELECTOR_BUILDER", "funcs", "validateArity", "pipecall", "oldAllowBoost", "markName", "pair", "and", "or", "not", "asc", "desc", "param", "object_expr", "extractPropertyKey", "object_pair", "object_splat", "object_splat_this", "square_bracket", "projection", "attr_access", "deref", "wrap", "array_postfix", "functionName", "argCount", "functionsRequiringSelectors", "includes", "GroqSyntaxError", "input", "rawParse", "processor", "isNativeBrowserEventSource", "eventSource", "window", "addEventListener", "EventSource", "prototype", "addEventSourceListener", "type", "listener", "listen", "EventSourceImpl", "config", "handlers", "projectId", "dataset", "token", "headers", "Authorization", "url", "es", "withCredentials", "open", "getMutationParser", "next", "msg", "close", "data", "JSON", "parse", "err", "error", "Error", "message", "statusCode", "origin", "location", "hintSuffix", "errorMessage", "isErrorLike", "unsubscribe", "Promise", "resolve", "cb", "isDraft", "doc", "_id", "startsWith", "getPublishedId", "document", "slice", "applyPatchWithoutRev", "patch", "patchDoc", "_rev", "applyPatch", "DEBOUNCE_MS", "noop", "getSyncingDataset", "onNotifyUpdate", "getDocuments", "useListener", "overlayDrafts", "documentLimit", "includeTypes", "loaded", "then", "onUpdate", "indexedDocuments", "Map", "documents", "buffer", "onDoneLoading", "onLoadError", "reject", "stagedDocs", "previousTrx", "flushTimeout", "onMutationReceived", "onOpen", "initial", "applyBufferedMutations", "forEach", "set", "applyMutation", "scheduleUpdate", "push", "docs", "clearTimeout", "transactionId", "setTimeout", "overlay", "effects", "documentId", "get", "replaceDocument", "apply", "id", "current", "position", "indexOf", "splice", "delete", "mutations", "groups", "mutation", "group", "find", "console", "warn", "hasFoundRevision", "previousRev", "overlayed", "existing", "pretendThatItsPublished", "Array", "from", "values", "groqStore", "envImplementations", "executeThrottled", "throttle", "subscriptionThrottleMs", "executeAllSubscriptions", "activeSubscriptions", "loadDataset", "query", "groqQuery", "params", "tree", "result", "evaluate", "getDocument", "groq", "documentIds", "subQueries", "map", "join", "subscribe", "callback", "subscription", "unsubscribed", "executeQuerySubscription", "res", "deepEqual", "previousResult", "catch", "cancel", "baseUrl", "length", "URLSearchParams", "types", "response", "fetch", "credentials", "status", "getError", "json", "stream", "getDocumentStream", "body", "reader", "getReader", "read", "value", "isStreamError", "isRelevantDocument", "done", "cancelled", "ReadableStream", "start", "controller", "decoder", "TextDecoder", "processResult", "trim", "enqueue", "decode", "lines", "split", "i", "line", "description", "assertEnvSupport", "required", "unsupported", "filter", "api", "_a", "groqStoreApi"]
}
