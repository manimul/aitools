{
  "version": 3,
  "sources": ["../../../node_modules/get-youtube-id/index.js", "../../../node_modules/@portabletext/toolkit/src/asserters.ts", "../../../node_modules/@portabletext/toolkit/src/sortMarksByOccurences.ts", "../../../node_modules/@portabletext/toolkit/src/buildMarksTree.ts", "../../../node_modules/@portabletext/toolkit/src/nestLists.ts", "../../../node_modules/@portabletext/toolkit/src/toPlainText.ts", "../../../node_modules/@portabletext/toolkit/src/spanToPlainText.ts", "../../../node_modules/@portabletext/toolkit/src/types.ts", "../../../node_modules/@portabletext/react/src/components/merge.ts", "../../../node_modules/@portabletext/react/src/components/marks.tsx", "../../../node_modules/@portabletext/react/src/components/list.tsx", "../../../node_modules/@portabletext/react/src/warnings.ts", "../../../node_modules/@portabletext/react/src/components/unknown.tsx", "../../../node_modules/@portabletext/react/src/components/defaults.tsx", "../../../node_modules/@portabletext/react/src/react-portable-text.tsx", "../../../app/components/SanityImage.tsx", "../../../app/components/SanityYoutube.tsx", "../../../node_modules/react-lite-youtube-embed/dist/index.es.jsx", "../../../app/components/SanityContent.tsx"],
  "sourcesContent": ["\n(function (root, factory) {\n  if (typeof exports === 'object') {\n    module.exports = factory();\n  } else if (typeof define === 'function' && define.amd) {\n    define(factory);\n  } else {\n    root.getYouTubeID = factory();\n  }\n}(this, function (exports) {\n\n  return function (url, opts) {\n    if (opts == undefined) {\n      opts = {fuzzy: true};\n    }\n\n    if (/youtu\\.?be/.test(url)) {\n\n      // Look first for known patterns\n      var i;\n      var patterns = [\n        /youtu\\.be\\/([^#\\&\\?]{11})/,  // youtu.be/<id>\n        /\\?v=([^#\\&\\?]{11})/,         // ?v=<id>\n        /\\&v=([^#\\&\\?]{11})/,         // &v=<id>\n        /embed\\/([^#\\&\\?]{11})/,      // embed/<id>\n        /\\/v\\/([^#\\&\\?]{11})/         // /v/<id>\n      ];\n\n      // If any pattern matches, return the ID\n      for (i = 0; i < patterns.length; ++i) {\n        if (patterns[i].test(url)) {\n          return patterns[i].exec(url)[1];\n        }\n      }\n\n      if (opts.fuzzy) {\n        // If that fails, break it apart by certain characters and look \n        // for the 11 character key\n        var tokens = url.split(/[\\/\\&\\?=#\\.\\s]/g);\n        for (i = 0; i < tokens.length; ++i) {\n          if (/^[^#\\&\\?]{11}$/.test(tokens[i])) {\n            return tokens[i];\n          }\n        }\n      }\n    }\n\n    return null;\n  };\n\n}));\n", "import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextListItemBlock,\n  PortableTextSpan,\n  TypedObject,\n} from '@portabletext/types'\nimport type {ToolkitNestedPortableTextSpan, ToolkitPortableTextList, ToolkitTextNode} from './types'\n\n/**\n * Strict check to determine if node is a correctly formatted Portable Text span.\n *\n * @param node - Node to check\n * @returns True if valid Portable Text span, otherwise false\n */\nexport function isPortableTextSpan(\n  node: ArbitraryTypedObject | PortableTextSpan\n): node is PortableTextSpan {\n  return (\n    node._type === 'span' &&\n    'text' in node &&\n    typeof node.text === 'string' &&\n    (typeof node.marks === 'undefined' ||\n      (Array.isArray(node.marks) && node.marks.every((mark) => typeof mark === 'string')))\n  )\n}\n\n/**\n * Strict check to determine if node is a correctly formatted Portable Text block.\n *\n * @param node - Node to check\n * @returns True if valid Portable Text block, otherwise false\n */\nexport function isPortableTextBlock(\n  node: PortableTextBlock | TypedObject\n): node is PortableTextBlock {\n  return (\n    // A block doesn't _have_ to be named 'block' - to differentiate between\n    // allowed child types and marks, one might name them differently\n    typeof node._type === 'string' &&\n    // Toolkit-types like nested spans are @-prefixed\n    node._type[0] !== '@' &&\n    // `markDefs` isn't _required_ per say, but if it's there, it needs to be an array\n    (!('markDefs' in node) ||\n      (Array.isArray(node.markDefs) &&\n        // Every mark definition needs to have an `_key` to be mappable in child spans\n        node.markDefs.every((def) => typeof def._key === 'string'))) &&\n    // `children` is required and needs to be an array\n    'children' in node &&\n    Array.isArray(node.children) &&\n    // All children are objects with `_type` (usually spans, but can contain other stuff)\n    node.children.every((child) => typeof child === 'object' && '_type' in child)\n  )\n}\n\n/**\n * Strict check to determine if node is a correctly formatted portable list item block.\n *\n * @param block - Block to check\n * @returns True if valid Portable Text list item block, otherwise false\n */\nexport function isPortableTextListItemBlock(\n  block: PortableTextBlock | TypedObject\n): block is PortableTextListItemBlock {\n  return (\n    isPortableTextBlock(block) &&\n    'listItem' in block &&\n    typeof block.listItem === 'string' &&\n    (typeof block.level === 'undefined' || typeof block.level === 'number')\n  )\n}\n\n/**\n * Loose check to determine if block is a toolkit list node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param block - Block to check\n * @returns True if toolkit list, otherwise false\n */\nexport function isPortableTextToolkitList(\n  block: TypedObject | ToolkitPortableTextList\n): block is ToolkitPortableTextList {\n  return block._type === '@list'\n}\n\n/**\n * Loose check to determine if span is a toolkit span node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param span - Span to check\n * @returns True if toolkit span, otherwise false\n */\nexport function isPortableTextToolkitSpan(\n  span: TypedObject | ToolkitNestedPortableTextSpan\n): span is ToolkitNestedPortableTextSpan {\n  return span._type === '@span'\n}\n\n/**\n * Loose check to determine if node is a toolkit text node.\n * Only checks `_type`, assumes correct structure.\n *\n * @param node - Node to check\n * @returns True if toolkit text node, otherwise false\n */\nexport function isPortableTextToolkitTextNode(\n  node: TypedObject | ToolkitTextNode\n): node is ToolkitTextNode {\n  return node._type === '@text'\n}\n", "import type {PortableTextSpan, TypedObject} from '@portabletext/types'\nimport {isPortableTextSpan} from './asserters'\n\nconst knownDecorators = ['strong', 'em', 'code', 'underline', 'strike-through']\n\n/**\n * Figures out the optimal order of marks, in order to minimize the amount of\n * nesting/repeated elements in environments such as HTML. For instance, a naive\n * implementation might render something like:\n *\n * ```html\n * <strong>This block contains </strong>\n * <strong><a href=\"https://some.url/\">a link</a></strong>\n * <strong> and some bolded text</strong>\n * ```\n *\n * ...whereas an optimal order would be:\n *\n * ```html\n * <strong>\n *   This block contains <a href=\"https://some.url/\">a link</a> and some bolded text\n * </strong>\n * ```\n *\n * This is particularly necessary for cases like links, where you don't want multiple\n * individual links for different segments of the link text, even if parts of it are\n * bolded/italicized.\n *\n * This function is meant to be used like: `block.children.map(sortMarksByOccurences)`,\n * and is used internally in {@link buildMarksTree | `buildMarksTree()`}.\n *\n * The marks are sorted in the following order:\n *\n *  1. Marks that are shared amongst the most adjacent siblings\n *  2. Non-default marks (links, custom metadata)\n *  3. Decorators (bold, emphasis, code etc), in a predefined, preferred order\n *\n * @param span - The current span to sort\n * @param index - The index of the current span within the block\n * @param blockChildren - All children of the block being sorted\n * @returns Array of decorators and annotations, sorted by \"most adjacent siblings\"\n */\nexport function sortMarksByOccurences(\n  span: PortableTextSpan | TypedObject,\n  index: number,\n  blockChildren: (PortableTextSpan | TypedObject)[]\n): string[] {\n  if (!isPortableTextSpan(span) || !span.marks) {\n    return []\n  }\n\n  if (!span.marks.length) {\n    return []\n  }\n\n  // Slicing because we'll be sorting with `sort()`, which mutates\n  const marks = span.marks.slice()\n  const occurences: Record<string, number> = {}\n  marks.forEach((mark) => {\n    occurences[mark] = 1\n\n    for (let siblingIndex = index + 1; siblingIndex < blockChildren.length; siblingIndex++) {\n      const sibling = blockChildren[siblingIndex]\n\n      if (\n        sibling &&\n        isPortableTextSpan(sibling) &&\n        Array.isArray(sibling.marks) &&\n        sibling.marks.indexOf(mark) !== -1\n      ) {\n        occurences[mark]++\n      } else {\n        break\n      }\n    }\n  })\n\n  return marks.sort((markA, markB) => sortMarks(occurences, markA, markB))\n}\n\nfunction sortMarks<U extends string, T extends Record<U, number>>(\n  occurences: T,\n  markA: U,\n  markB: U\n): number {\n  const aOccurences = occurences[markA]\n  const bOccurences = occurences[markB]\n\n  if (aOccurences !== bOccurences) {\n    return bOccurences - aOccurences\n  }\n\n  const aKnownPos = knownDecorators.indexOf(markA)\n  const bKnownPos = knownDecorators.indexOf(markB)\n\n  // Sort known decorators last\n  if (aKnownPos !== bKnownPos) {\n    return aKnownPos - bKnownPos\n  }\n\n  // Sort other marks simply by key\n  return markA.localeCompare(markB)\n}\n", "import type {\n  ArbitraryTypedObject,\n  PortableTextBlock,\n  PortableTextMarkDefinition,\n} from '@portabletext/types'\nimport type {ToolkitNestedPortableTextSpan, ToolkitTextNode} from './types'\nimport {isPortableTextSpan} from './asserters'\nimport {sortMarksByOccurences} from './sortMarksByOccurences'\n\n/**\n * Takes a Portable Text block and returns a nested tree of nodes optimized for rendering\n * in HTML-like environments where you want marks/annotations to be nested inside of eachother.\n * For instance, a naive span-by-span rendering might yield:\n *\n * ```html\n * <strong>This block contains </strong>\n * <strong><a href=\"https://some.url/\">a link</a></strong>\n * <strong> and some bolded and </strong>\n * <em><strong>italicized text</strong></em>\n * ```\n *\n * ...whereas an optimal order would be:\n *\n * ```html\n * <strong>\n *   This block contains <a href=\"https://some.url/\">a link</a>\n *   and some bolded and <em>italicized text</em>\n * </strong>\n * ```\n *\n * Note that since \"native\" Portable Text spans cannot be nested,\n * this function returns an array of \"toolkit specific\" types:\n * {@link ToolkitTextNode | `@text`} and {@link ToolkitNestedPortableTextSpan | `@span` }.\n *\n * The toolkit-specific type can hold both types, as well as any arbitrary inline objects,\n * creating an actual tree.\n *\n * @param block - The Portable Text block to create a tree of nodes from\n * @returns Array of (potentially) nested spans, text nodes and/or arbitrary inline objects\n */\nexport function buildMarksTree<M extends PortableTextMarkDefinition = PortableTextMarkDefinition>(\n  block: PortableTextBlock<M>\n): (ToolkitNestedPortableTextSpan<M> | ToolkitTextNode | ArbitraryTypedObject)[] {\n  const {children, markDefs = []} = block\n  if (!children || !children.length) {\n    return []\n  }\n\n  const sortedMarks = children.map(sortMarksByOccurences)\n\n  const rootNode: ToolkitNestedPortableTextSpan<M> = {\n    _type: '@span',\n    children: [],\n    markType: '<unknown>',\n  }\n\n  let nodeStack: ToolkitNestedPortableTextSpan<M>[] = [rootNode]\n\n  for (let i = 0; i < children.length; i++) {\n    const span = children[i]\n    if (!span) {\n      continue\n    }\n\n    const marksNeeded = sortedMarks[i] || []\n    let pos = 1\n\n    // Start at position one. Root is always plain and should never be removed\n    if (nodeStack.length > 1) {\n      for (pos; pos < nodeStack.length; pos++) {\n        const mark = nodeStack[pos]?.markKey || ''\n        const index = marksNeeded.indexOf(mark)\n\n        if (index === -1) {\n          break\n        }\n\n        marksNeeded.splice(index, 1)\n      }\n    }\n\n    // Keep from beginning to first miss\n    nodeStack = nodeStack.slice(0, pos)\n\n    // Add needed nodes\n    let currentNode = nodeStack[nodeStack.length - 1]\n    if (!currentNode) {\n      continue\n    }\n\n    for (const markKey of marksNeeded) {\n      const markDef = markDefs.find((def) => def._key === markKey)\n      const markType = markDef ? markDef._type : markKey\n      const node: ToolkitNestedPortableTextSpan<M> = {\n        _type: '@span',\n        _key: span._key,\n        children: [],\n        markDef,\n        markType,\n        markKey,\n      }\n\n      currentNode.children.push(node)\n      nodeStack.push(node)\n      currentNode = node\n    }\n\n    // Split at newlines to make individual line chunks, but keep newline\n    // characters as individual elements in the array. We use these characters\n    // in the span serializer to trigger hard-break rendering\n    if (isPortableTextSpan(span)) {\n      const lines = span.text.split('\\n')\n      for (let line = lines.length; line-- > 1; ) {\n        lines.splice(line, 0, '\\n')\n      }\n\n      currentNode.children = currentNode.children.concat(\n        lines.map((text) => ({_type: '@text', text}))\n      )\n    } else {\n      // This is some other inline object, not a text span\n      currentNode.children = currentNode.children.concat(span)\n    }\n  }\n\n  return rootNode.children\n}\n", "import type {PortableTextBlock, PortableTextListItemBlock, TypedObject} from '@portabletext/types'\nimport type {\n  ToolkitListNestMode,\n  ToolkitPortableTextDirectList,\n  ToolkitPortableTextHtmlList,\n  ToolkitPortableTextList,\n  ToolkitPortableTextListItem,\n} from './types'\nimport {\n  isPortableTextListItemBlock,\n  isPortableTextSpan,\n  isPortableTextToolkitList,\n} from './asserters'\n\nexport type ToolkitNestListsOutputNode<T> =\n  | T\n  | ToolkitPortableTextHtmlList\n  | ToolkitPortableTextDirectList\n\n/**\n * Takes an array of blocks and returns an array of nodes optimized for rendering in HTML-like\n * environment, where lists are nested inside of eachother instead of appearing \"flat\" as in\n * native Portable Text data structures.\n *\n * Note that the list node is not a native Portable Text node type, and thus is represented\n * using the {@link ToolkitPortableTextList | `@list`} type name (`{_type: '@list'}`).\n *\n * The nesting can be configured in two modes:\n *\n * - `direct`: deeper list nodes will appear as a direct child of the parent list\n * - `html`, deeper list nodes will appear as a child of the last _list item_ in the parent list\n *\n * When using `direct`, all list nodes will be of type {@link ToolkitPortableTextDirectList},\n * while with `html` they will be of type {@link ToolkitPortableTextHtmlList}\n *\n * These modes are available as {@link LIST_NEST_MODE_HTML} and {@link LIST_NEST_MODE_DIRECT}.\n *\n * @param blocks - Array of Portable Text blocks and other arbitrary types\n * @param mode - Mode to use for nesting, `direct` or `html`\n * @returns Array of potentially nested nodes optimized for rendering\n */\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'direct'\n): (T | ToolkitPortableTextDirectList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'html'\n): (T | ToolkitPortableTextHtmlList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: 'direct' | 'html'\n): (T | ToolkitPortableTextHtmlList | ToolkitPortableTextDirectList)[]\nexport function nestLists<T extends TypedObject = PortableTextBlock | TypedObject>(\n  blocks: T[],\n  mode: ToolkitListNestMode\n): ToolkitNestListsOutputNode<T>[] {\n  const tree: ToolkitNestListsOutputNode<T>[] = []\n  let currentList: ToolkitPortableTextList | undefined\n\n  for (let i = 0; i < blocks.length; i++) {\n    const block = blocks[i]\n    if (!block) {\n      continue\n    }\n\n    if (!isPortableTextListItemBlock(block)) {\n      tree.push(block)\n      currentList = undefined\n      continue\n    }\n\n    // Start of a new list?\n    if (!currentList) {\n      currentList = listFromBlock(block, i, mode)\n      tree.push(currentList)\n      continue\n    }\n\n    // New list item within same list?\n    if (blockMatchesList(block, currentList)) {\n      currentList.children.push(block)\n      continue\n    }\n\n    // Different list props, are we going deeper?\n    if ((block.level || 1) > currentList.level) {\n      const newList = listFromBlock(block, i, mode)\n\n      if (mode === 'html') {\n        // Because HTML is kinda weird, nested lists needs to be nested within list items.\n        // So while you would think that we could populate the parent list with a new sub-list,\n        // we actually have to target the last list element (child) of the parent.\n        // However, at this point we need to be very careful - simply pushing to the list of children\n        // will mutate the input, and we don't want to blindly clone the entire tree.\n\n        // Clone the last child while adding our new list as the last child of it\n        const lastListItem = currentList.children[\n          currentList.children.length - 1\n        ] as ToolkitPortableTextListItem\n\n        const newLastChild: ToolkitPortableTextListItem = {\n          ...lastListItem,\n          children: [...lastListItem.children, newList],\n        }\n\n        // Swap the last child\n        currentList.children[currentList.children.length - 1] = newLastChild\n      } else {\n        ;(currentList as ToolkitPortableTextDirectList).children.push(\n          newList as ToolkitPortableTextDirectList\n        )\n      }\n\n      // Set the newly created, deeper list as the current\n      currentList = newList\n      continue\n    }\n\n    // Different list props, are we going back up the tree?\n    if ((block.level || 1) < currentList.level) {\n      // Current list has ended, and we need to hook up with a parent of the same level and type\n      const matchingBranch = tree[tree.length - 1]\n      const match = matchingBranch && findListMatching(matchingBranch, block)\n      if (match) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      }\n\n      // Similar parent can't be found, assume new list\n      currentList = listFromBlock(block, i, mode)\n      tree.push(currentList)\n      continue\n    }\n\n    // Different list props, different list style?\n    if (block.listItem !== currentList.listItem) {\n      const matchingBranch = tree[tree.length - 1]\n      const match = matchingBranch && findListMatching(matchingBranch, {level: block.level || 1})\n      if (match && match.listItem === block.listItem) {\n        currentList = match\n        currentList.children.push(block)\n        continue\n      } else {\n        currentList = listFromBlock(block, i, mode)\n        tree.push(currentList)\n        continue\n      }\n    }\n\n    // eslint-disable-next-line no-console\n    console.warn('Unknown state encountered for block', block)\n    tree.push(block)\n  }\n\n  return tree\n}\n\nfunction blockMatchesList(block: PortableTextBlock, list: ToolkitPortableTextList) {\n  return (block.level || 1) === list.level && block.listItem === list.listItem\n}\n\nfunction listFromBlock(\n  block: PortableTextListItemBlock,\n  index: number,\n  mode: ToolkitListNestMode\n): ToolkitPortableTextList {\n  return {\n    _type: '@list',\n    _key: `${block._key || `${index}`}-parent`,\n    mode,\n    level: block.level || 1,\n    listItem: block.listItem,\n    children: [block],\n  }\n}\n\nfunction findListMatching<T extends TypedObject | PortableTextBlock>(\n  rootNode: T,\n  matching: Partial<PortableTextListItemBlock>\n): ToolkitPortableTextList | undefined {\n  const level = matching.level || 1\n  const style = matching.listItem || 'normal'\n  const filterOnType = typeof matching.listItem === 'string'\n  if (\n    isPortableTextToolkitList(rootNode) &&\n    (rootNode.level || 1) === level &&\n    filterOnType &&\n    (rootNode.listItem || 'normal') === style\n  ) {\n    return rootNode\n  }\n\n  if (!('children' in rootNode)) {\n    return undefined\n  }\n\n  const node = rootNode.children[rootNode.children.length - 1]\n  return node && !isPortableTextSpan(node) ? findListMatching(node, matching) : undefined\n}\n", "import type {ArbitraryTypedObject, PortableTextBlock} from '@portabletext/types'\nimport {isPortableTextBlock, isPortableTextSpan} from './asserters'\n\nconst leadingSpace = /^\\s/\nconst trailingSpace = /^\\s/\n\n/**\n * Takes a Portable Text block (or an array of them) and returns the text value\n * of all the Portable Text span nodes. Adds whitespace when encountering inline,\n * non-span nodes to ensure text flow is optimal.\n *\n * Note that this only accounts for regular Portable Text blocks - any text inside\n * custom content types are not included in the output.\n *\n * @param block - Single block or an array of blocks to extract text from\n * @returns The plain-text content of the blocks\n */\nexport function toPlainText(\n  block: PortableTextBlock | ArbitraryTypedObject[] | PortableTextBlock[]\n): string {\n  const blocks = Array.isArray(block) ? block : [block]\n  let text = ''\n\n  blocks.forEach((current, index) => {\n    if (!isPortableTextBlock(current)) {\n      return\n    }\n\n    let pad = false\n    current.children.forEach((span) => {\n      if (isPortableTextSpan(span)) {\n        // If the previous element was a non-span, and we have no natural whitespace\n        // between the previous and the next span, insert it to give the spans some\n        // room to breathe. However, don't do so if this is the first span.\n        text += pad && text && !trailingSpace.test(text) && !leadingSpace.test(span.text) ? ' ' : ''\n        text += span.text\n        pad = false\n      } else {\n        pad = true\n      }\n    })\n\n    if (index !== blocks.length - 1) {\n      text += '\\n\\n'\n    }\n  })\n\n  return text\n}\n", "import type {ToolkitNestedPortableTextSpan} from './types'\nimport {isPortableTextToolkitSpan, isPortableTextToolkitTextNode} from './asserters'\n\n/**\n * Returns the plain-text representation of a\n * {@link ToolkitNestedPortableTextSpan | toolkit-specific Portable Text span}.\n *\n * Useful if you have a subset of nested nodes and want the text from just those,\n * instead of for the entire Portable Text block.\n *\n * @param span - Span node to get text from (Portable Text toolkit specific type)\n * @returns The plain-text version of the span\n */\nexport function spanToPlainText(span: ToolkitNestedPortableTextSpan): string {\n  let text = ''\n  span.children.forEach((current) => {\n    if (isPortableTextToolkitTextNode(current)) {\n      text += current.text\n    } else if (isPortableTextToolkitSpan(current)) {\n      text += spanToPlainText(current)\n    }\n  })\n  return text\n}\n", "import type {\n  ArbitraryTypedObject,\n  PortableTextListItemBlock,\n  PortableTextMarkDefinition,\n  PortableTextSpan,\n} from '@portabletext/types'\n\n/**\n * List nesting mode for HTML, see the {@link nestLists | `nestLists()` function}\n */\nexport const LIST_NEST_MODE_HTML = 'html'\n\n/**\n * List nesting mode for direct, nested lists, see the {@link nestLists | `nestLists()` function}\n */\nexport const LIST_NEST_MODE_DIRECT = 'direct'\n\n/**\n * List nesting mode, see the {@link nestLists | `nestLists()` function}\n */\nexport type ToolkitListNestMode = 'html' | 'direct'\n\n/**\n * Toolkit-specific type representing a nested list\n *\n * See the `nestLists()` function for more info\n */\nexport type ToolkitPortableTextList = ToolkitPortableTextHtmlList | ToolkitPortableTextDirectList\n\n/**\n * Toolkit-specific type representing a nested list in HTML mode, where deeper lists are nested\n * inside of the _list items_, eg `<ul><li>Some text<ul><li>Deeper</li></ul></li></ul>`\n */\nexport interface ToolkitPortableTextHtmlList {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@list'\n\n  /**\n   * Unique key for this list (within its parent)\n   */\n  _key: string\n\n  /**\n   * List mode, signaling that list nodes will appear as children of the _list items_\n   */\n  mode: 'html'\n\n  /**\n   * Level/depth of this list node (starts at `1`)\n   */\n  level: number\n\n  /**\n   * Style of this list item (`bullet`, `number` are common values, but can be customized)\n   */\n  listItem: string\n\n  /**\n   * Child nodes of this list - toolkit-specific list items which can themselves hold deeper lists\n   */\n  children: ToolkitPortableTextListItem[]\n}\n\n/**\n * Toolkit-specific type representing a nested list in \"direct\" mode, where deeper lists are nested\n * inside of the lists children, alongside other blocks.\n */\nexport interface ToolkitPortableTextDirectList {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@list'\n\n  /**\n   * Unique key for this list (within its parent)\n   */\n  _key: string\n\n  /**\n   * List mode, signaling that list nodes can appear as direct children\n   */\n  mode: 'direct'\n\n  /**\n   * Level/depth of this list node (starts at `1`)\n   */\n  level: number\n\n  /**\n   * Style of this list item (`bullet`, `number` are common values, but can be customized)\n   */\n  listItem: string\n\n  /**\n   * Child nodes of this list - either portable text list items, or another, deeper list\n   */\n  children: (PortableTextListItemBlock | ToolkitPortableTextDirectList)[]\n}\n\n/**\n * Toolkit-specific type representing a list item block, but where the children can be another list\n */\nexport interface ToolkitPortableTextListItem\n  extends PortableTextListItemBlock<\n    PortableTextMarkDefinition,\n    PortableTextSpan | ToolkitPortableTextList\n  > {}\n\n/**\n * Toolkit-specific type representing a text node, used when nesting spans.\n *\n * See the {@link buildMarksTree | `buildMarksTree()` function}\n */\nexport interface ToolkitTextNode {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@text'\n\n  /**\n   * The actual string value of the text node\n   */\n  text: string\n}\n\n/**\n * Toolkit-specific type representing a portable text span that can hold other spans.\n * In this type, each span only has a single mark, instead of an array of them.\n */\nexport interface ToolkitNestedPortableTextSpan<\n  M extends PortableTextMarkDefinition = PortableTextMarkDefinition\n> {\n  /**\n   * Type name, prefixed with `@` to signal that this is a toolkit-specific node.\n   */\n  _type: '@span'\n\n  /**\n   * Unique key for this span\n   */\n  _key?: string\n\n  /**\n   * Holds the value (definition) of the mark in the case of annotations.\n   * `undefined` if the mark is a decorator (strong, em or similar).\n   */\n  markDef?: M\n\n  /**\n   * The key of the mark definition (in the case of annotations).\n   * `undefined` if the mark is a decorator (strong, em or similar).\n   */\n  markKey?: string\n\n  /**\n   * Type of the mark. For annotations, this is the `_type` property of the value.\n   * For decorators, it will hold the name of the decorator (strong, em or similar).\n   */\n  markType: string\n\n  /**\n   * Child nodes of this span. Can be toolkit-specific text nodes, nested spans\n   * or any inline object type.\n   */\n  children: (\n    | ToolkitTextNode\n    | ToolkitNestedPortableTextSpan<PortableTextMarkDefinition>\n    | ArbitraryTypedObject\n  )[]\n}\n", "import type {PortableTextReactComponents, PortableTextComponents} from '../types'\n\nexport function mergeComponents(\n  parent: PortableTextReactComponents,\n  overrides: PortableTextComponents\n): PortableTextReactComponents {\n  const {block, list, listItem, marks, types, ...rest} = overrides\n  // @todo figure out how to not `as ...` these\n  return {\n    ...parent,\n    block: mergeDeeply(parent, overrides, 'block') as PortableTextReactComponents['block'],\n    list: mergeDeeply(parent, overrides, 'list') as PortableTextReactComponents['list'],\n    listItem: mergeDeeply(parent, overrides, 'listItem') as PortableTextReactComponents['listItem'],\n    marks: mergeDeeply(parent, overrides, 'marks') as PortableTextReactComponents['marks'],\n    types: mergeDeeply(parent, overrides, 'types') as PortableTextReactComponents['types'],\n    ...rest,\n  }\n}\n\nfunction mergeDeeply(\n  parent: PortableTextReactComponents,\n  overrides: PortableTextComponents,\n  key: 'block' | 'list' | 'listItem' | 'marks' | 'types'\n): PortableTextReactComponents[typeof key] {\n  const override = overrides[key]\n  const parentVal = parent[key]\n\n  if (typeof override === 'function') {\n    return override\n  }\n\n  if (override && typeof parentVal === 'function') {\n    return override\n  }\n\n  if (override) {\n    return {...parentVal, ...override} as PortableTextReactComponents[typeof key]\n  }\n\n  return parentVal\n}\n", "import type {TypedObject} from '@portabletext/types'\nimport React from 'react'\nimport type {PortableTextMarkComponent} from '../types'\n\ninterface DefaultLink extends TypedObject {\n  _type: 'link'\n  href: string\n}\n\nconst link: PortableTextMarkComponent<DefaultLink> = ({children, value}) => (\n  <a href={value?.href}>{children}</a>\n)\n\nconst underlineStyle = {textDecoration: 'underline'}\n\nexport const defaultMarks: Record<string, PortableTextMarkComponent | undefined> = {\n  em: ({children}) => <em>{children}</em>,\n  strong: ({children}) => <strong>{children}</strong>,\n  code: ({children}) => <code>{children}</code>,\n  underline: ({children}) => <span style={underlineStyle}>{children}</span>,\n  'strike-through': ({children}) => <del>{children}</del>,\n  link,\n}\n", "import React from 'react'\nimport type {PortableTextListComponent, PortableTextListItemComponent} from '../types'\n\nexport const defaultLists: Record<'number' | 'bullet', PortableTextListComponent> = {\n  number: ({children}) => <ol>{children}</ol>,\n  bullet: ({children}) => <ul>{children}</ul>,\n}\n\nexport const DefaultListItem: PortableTextListItemComponent = ({children}) => <li>{children}</li>\n", "const getTemplate = (type: string, prop: string): string =>\n  `[@portabletext/react] Unknown ${type}, specify a component for it in the \\`components.${prop}\\` prop`\n\nexport const unknownTypeWarning = (typeName: string): string =>\n  getTemplate(`block type \"${typeName}\"`, 'types')\n\nexport const unknownMarkWarning = (markType: string): string =>\n  getTemplate(`mark type \"${markType}\"`, 'marks')\n\nexport const unknownBlockStyleWarning = (blockStyle: string): string =>\n  getTemplate(`block style \"${blockStyle}\"`, 'block')\n\nexport const unknownListStyleWarning = (listStyle: string): string =>\n  getTemplate(`list style \"${listStyle}\"`, 'list')\n\nexport const unknownListItemStyleWarning = (listStyle: string): string =>\n  getTemplate(`list item style \"${listStyle}\"`, 'listItem')\n\nexport function printWarning(message: string): void {\n  console.warn(message)\n}\n", "import React from 'react'\nimport type {PortableTextReactComponents} from '../types'\nimport {unknownTypeWarning} from '../warnings'\n\nconst hidden = {display: 'none'}\n\nexport const DefaultUnknownType: PortableTextReactComponents['unknownType'] = ({\n  value,\n  isInline,\n}) => {\n  const warning = unknownTypeWarning(value._type)\n  return isInline ? <span style={hidden}>{warning}</span> : <div style={hidden}>{warning}</div>\n}\n\nexport const DefaultUnknownMark: PortableTextReactComponents['unknownMark'] = ({\n  markType,\n  children,\n}) => {\n  return <span className={`unknown__pt__mark__${markType}`}>{children}</span>\n}\n\nexport const DefaultUnknownBlockStyle: PortableTextReactComponents['unknownBlockStyle'] = ({\n  children,\n}) => {\n  return <p>{children}</p>\n}\n\nexport const DefaultUnknownList: PortableTextReactComponents['unknownList'] = ({children}) => {\n  return <ul>{children}</ul>\n}\n\nexport const DefaultUnknownListItem: PortableTextReactComponents['unknownListItem'] = ({\n  children,\n}) => {\n  return <li>{children}</li>\n}\n", "import React from 'react'\nimport type {PortableTextBlockStyle} from '@portabletext/types'\nimport type {PortableTextBlockComponent, PortableTextReactComponents} from '../types'\nimport {defaultMarks} from './marks'\nimport {defaultLists, DefaultListItem} from './list'\nimport {\n  DefaultUnknownType,\n  DefaultUnknownMark,\n  DefaultUnknownList,\n  DefaultUnknownListItem,\n  DefaultUnknownBlockStyle,\n} from './unknown'\n\nexport const DefaultHardBreak = () => <br />\n\nexport const defaultBlockStyles: Record<\n  PortableTextBlockStyle,\n  PortableTextBlockComponent | undefined\n> = {\n  normal: ({children}) => <p>{children}</p>,\n  blockquote: ({children}) => <blockquote>{children}</blockquote>,\n  h1: ({children}) => <h1>{children}</h1>,\n  h2: ({children}) => <h2>{children}</h2>,\n  h3: ({children}) => <h3>{children}</h3>,\n  h4: ({children}) => <h4>{children}</h4>,\n  h5: ({children}) => <h5>{children}</h5>,\n  h6: ({children}) => <h6>{children}</h6>,\n}\n\nexport const defaultComponents: PortableTextReactComponents = {\n  types: {},\n\n  block: defaultBlockStyles,\n  marks: defaultMarks,\n  list: defaultLists,\n  listItem: DefaultListItem,\n  hardBreak: DefaultHardBreak,\n\n  unknownType: DefaultUnknownType,\n  unknownMark: DefaultUnknownMark,\n  unknownList: DefaultUnknownList,\n  unknownListItem: DefaultUnknownListItem,\n  unknownBlockStyle: DefaultUnknownBlockStyle,\n}\n", "import React, {ReactNode, useMemo} from 'react'\nimport {\n  LIST_NEST_MODE_HTML,\n  ToolkitNestedPortableTextSpan,\n  ToolkitTextNode,\n} from '@portabletext/toolkit'\nimport type {\n  MissingComponentHandler,\n  NodeRenderer,\n  PortableTextProps,\n  PortableTextReactComponents,\n  ReactPortableTextList,\n  Serializable,\n  SerializedBlock,\n} from './types'\nimport {\n  isPortableTextBlock,\n  isPortableTextListItemBlock,\n  isPortableTextToolkitList,\n  isPortableTextToolkitSpan,\n  isPortableTextToolkitTextNode,\n  nestLists,\n  spanToPlainText,\n  buildMarksTree,\n} from '@portabletext/toolkit'\nimport type {\n  PortableTextBlock,\n  PortableTextListItemBlock,\n  PortableTextMarkDefinition,\n  PortableTextSpan,\n  TypedObject,\n} from '@portabletext/types'\nimport {mergeComponents} from './components/merge'\nimport {defaultComponents} from './components/defaults'\nimport {\n  printWarning,\n  unknownBlockStyleWarning,\n  unknownListItemStyleWarning,\n  unknownListStyleWarning,\n  unknownMarkWarning,\n  unknownTypeWarning,\n} from './warnings'\n\nexport function PortableText<B extends TypedObject = PortableTextBlock>({\n  value: input,\n  components: componentOverrides,\n  listNestingMode,\n  onMissingComponent: missingComponentHandler = printWarning,\n}: PortableTextProps<B>) {\n  const handleMissingComponent = missingComponentHandler || noop\n  const blocks = Array.isArray(input) ? input : [input]\n  const nested = nestLists(blocks, listNestingMode || LIST_NEST_MODE_HTML)\n\n  const components = useMemo(() => {\n    return componentOverrides\n      ? mergeComponents(defaultComponents, componentOverrides)\n      : defaultComponents\n  }, [componentOverrides])\n\n  const renderNode = useMemo(\n    () => getNodeRenderer(components, handleMissingComponent),\n    [components, handleMissingComponent]\n  )\n  const rendered = nested.map((node, index) =>\n    renderNode({node: node, index, isInline: false, renderNode})\n  )\n\n  return <>{rendered}</>\n}\n\nconst getNodeRenderer = (\n  components: PortableTextReactComponents,\n  handleMissingComponent: MissingComponentHandler\n): NodeRenderer => {\n  function renderNode<N extends TypedObject>(options: Serializable<N>): ReactNode {\n    const {node, index, isInline} = options\n    const key = node._key || `node-${index}`\n\n    if (isPortableTextToolkitList(node)) {\n      return renderList(node, index, key)\n    }\n\n    if (isPortableTextListItemBlock(node)) {\n      return renderListItem(node, index, key)\n    }\n\n    if (isPortableTextToolkitSpan(node)) {\n      return renderSpan(node, index, key)\n    }\n\n    if (isPortableTextBlock(node)) {\n      return renderBlock(node, index, key, isInline)\n    }\n\n    if (isPortableTextToolkitTextNode(node)) {\n      return renderText(node, key)\n    }\n\n    return renderCustomBlock(node, index, key, isInline)\n  }\n\n  /* eslint-disable react/jsx-no-bind */\n  function renderListItem(\n    node: PortableTextListItemBlock<PortableTextMarkDefinition, PortableTextSpan>,\n    index: number,\n    key: string\n  ) {\n    const tree = serializeBlock({node, index, isInline: false, renderNode})\n    const renderer = components.listItem\n    const handler = typeof renderer === 'function' ? renderer : renderer[node.listItem]\n    const Li = handler || components.unknownListItem\n\n    if (Li === components.unknownListItem) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListItemStyleWarning(style), {\n        type: style,\n        nodeType: 'listItemStyle',\n      })\n    }\n\n    let children = tree.children\n    if (node.style && node.style !== 'normal') {\n      // Wrap any other style in whatever the block serializer says to use\n      const {listItem, ...blockNode} = node\n      children = renderNode({node: blockNode, index, isInline: false, renderNode})\n    }\n\n    return (\n      <Li key={key} value={node} index={index} isInline={false} renderNode={renderNode}>\n        {children}\n      </Li>\n    )\n  }\n\n  function renderList(node: ReactPortableTextList, index: number, key: string) {\n    const children = node.children.map((child, childIndex) =>\n      renderNode({\n        node: child._key ? child : {...child, _key: `li-${index}-${childIndex}`},\n        index: index,\n        isInline: false,\n        renderNode,\n      })\n    )\n\n    const component = components.list\n    const handler = typeof component === 'function' ? component : component[node.listItem]\n    const List = handler || components.unknownList\n\n    if (List === components.unknownList) {\n      const style = node.listItem || 'bullet'\n      handleMissingComponent(unknownListStyleWarning(style), {nodeType: 'listStyle', type: style})\n    }\n\n    return (\n      <List key={key} value={node} index={index} isInline={false} renderNode={renderNode}>\n        {children}\n      </List>\n    )\n  }\n\n  function renderSpan(node: ToolkitNestedPortableTextSpan, _index: number, key: string) {\n    const {markDef, markType, markKey} = node\n    const Span = components.marks[markType] || components.unknownMark\n    const children = node.children.map((child, childIndex) =>\n      renderNode({node: child, index: childIndex, isInline: true, renderNode})\n    )\n\n    if (Span === components.unknownMark) {\n      handleMissingComponent(unknownMarkWarning(markType), {nodeType: 'mark', type: markType})\n    }\n\n    return (\n      <Span\n        key={key}\n        text={spanToPlainText(node)}\n        value={markDef}\n        markType={markType}\n        markKey={markKey}\n        renderNode={renderNode}\n      >\n        {children}\n      </Span>\n    )\n  }\n\n  function renderBlock(node: PortableTextBlock, index: number, key: string, isInline: boolean) {\n    const {_key, ...props} = serializeBlock({node, index, isInline, renderNode})\n    const style = props.node.style || 'normal'\n    const handler =\n      typeof components.block === 'function' ? components.block : components.block[style]\n    const Block = handler || components.unknownBlockStyle\n\n    if (Block === components.unknownBlockStyle) {\n      handleMissingComponent(unknownBlockStyleWarning(style), {\n        nodeType: 'blockStyle',\n        type: style,\n      })\n    }\n\n    return <Block key={key} {...props} value={props.node} renderNode={renderNode} />\n  }\n\n  function renderText(node: ToolkitTextNode, key: string) {\n    if (node.text === '\\n') {\n      const HardBreak = components.hardBreak\n      return HardBreak ? <HardBreak key={key} /> : '\\n'\n    }\n\n    return node.text\n  }\n\n  function renderCustomBlock(node: TypedObject, index: number, key: string, isInline: boolean) {\n    const Node = components.types[node._type]\n\n    const nodeOptions = {\n      value: node,\n      isInline,\n      index,\n      renderNode,\n    }\n\n    if (Node) {\n      return <Node key={key} {...nodeOptions} />\n    }\n\n    handleMissingComponent(unknownTypeWarning(node._type), {nodeType: 'block', type: node._type})\n\n    const UnknownType = components.unknownType\n    return <UnknownType key={key} {...nodeOptions} />\n  }\n  /* eslint-enable react/jsx-no-bind */\n\n  return renderNode\n}\n\nfunction serializeBlock(options: Serializable<PortableTextBlock>): SerializedBlock {\n  const {node, index, isInline, renderNode} = options\n  const tree = buildMarksTree(node)\n  const children = tree.map((child, i) =>\n    renderNode({node: child, isInline: true, index: i, renderNode})\n  )\n\n  return {\n    _key: node._key || `block-${index}`,\n    children,\n    index,\n    isInline,\n    node,\n  }\n}\n\nfunction noop() {\n  // Intentional noop\n}\n", "import React from 'react'\nimport urlBuilder from '@sanity/image-url'\nimport {getImageDimensions} from '@sanity/asset-utils'\nimport type {SanityImageSource} from '@sanity/asset-utils'\nimport type {PortableTextComponentProps} from '@portabletext/react'\nimport {projectDetails} from '~/sanity/projectDetails'\n\ntype SanityImageAssetWithAlt = SanityImageSource & {alt?: string}\n\nexport default function SanityImage(props: PortableTextComponentProps<SanityImageAssetWithAlt>) {\n  const {value, isInline} = props\n  const {width, height} = getImageDimensions(value)\n\n  return (\n    <img\n      className=\"not-prose h-auto w-full\"\n      src={urlBuilder(projectDetails())\n        .image(value)\n        .width(isInline ? 100 : 800)\n        .fit('max')\n        .auto('format')\n        .url()}\n      alt={value.alt || ''}\n      loading=\"lazy\"\n      style={{\n        // Display alongside text if image appears inside a block text span\n        display: isInline ? 'inline-block' : 'block',\n\n        // Avoid jumping around with aspect-ratio CSS property\n        aspectRatio: width / height,\n      }}\n    />\n  )\n}\n", "/* eslint-disable prettier/prettier */\nimport React from 'react';\nimport getYouTubeId from 'get-youtube-id';\nimport LiteYouTubeEmbed from 'react-lite-youtube-embed';\n\nexport default function SanityYoutube(props: { value: any }) {\n  const { value } = props;\n  const youtubeId = getYouTubeId(value.url) || '';\n\n  return <LiteYouTubeEmbed id={youtubeId || ''} title={value.title || ''} />;\n}\n", "/**\n* react-lite-youtube-embed v2.3.52\n*  https://github.com/ibrahimcesar/react-lite-youtube-embed.git\n*\n*  Copyright (c) Ibrahim Cesar < email@ibrahimcesar.com > and project contributors.\n*\n*  This source code is licensed under the MIT license found in the\n*  LICENSE file in the root directory of this source tree.\n*\n*  Author site: https://ibrahimcesar.cloud\n*/\n    import * as React from 'react';\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\n\nfunction LiteYouTubeEmbed(props) {\r\n    var _a = React.useState(false), preconnected = _a[0], setPreconnected = _a[1];\r\n    var _b = React.useState(false), iframe = _b[0], setIframe = _b[1];\r\n    var videoId = encodeURIComponent(props.id);\r\n    var videoPlaylisCovertId = typeof props.playlistCoverId === 'string' ? encodeURIComponent(props.playlistCoverId) : null;\r\n    var videoTitle = props.title;\r\n    var posterImp = props.poster || \"hqdefault\";\r\n    var paramsImp = \"&\" + props.params || \"\";\r\n    var mutedImp = props.muted ? \"&mute=1\" : \"\";\r\n    var announceWatch = props.announce || \"Watch\";\r\n    var format = props.webp ? 'webp' : 'jpg';\r\n    var vi = props.webp ? 'vi_webp' : 'vi';\r\n    var posterUrl = props.thumbnail || (!props.playlist\r\n        ? \"https://i.ytimg.com/\" + vi + \"/\" + videoId + \"/\" + posterImp + \".\" + format\r\n        : \"https://i.ytimg.com/\" + vi + \"/\" + videoPlaylisCovertId + \"/\" + posterImp + \".\" + format);\r\n    var ytUrl = props.noCookie\r\n        ? \"https://www.youtube-nocookie.com\"\r\n        : \"https://www.youtube.com\";\r\n    ytUrl = props.cookie\r\n        ? \"https://www.youtube.com\"\r\n        : \"https://www.youtube-nocookie.com\";\r\n    var iframeSrc = !props.playlist\r\n        ? ytUrl + \"/embed/\" + videoId + \"?autoplay=1&state=1\" + mutedImp + paramsImp\r\n        : ytUrl + \"/embed/videoseries?autoplay=1\" + mutedImp + \"&list=\" + videoId + paramsImp;\r\n    var activatedClassImp = props.activatedClass || \"lyt-activated\";\r\n    var adNetworkImp = props.adNetwork || false;\r\n    var aspectHeight = props.aspectHeight || 9;\r\n    var aspectWidth = props.aspectWidth || 16;\r\n    var iframeClassImp = props.iframeClass || \"\";\r\n    var playerClassImp = props.playerClass || \"lty-playbtn\";\r\n    var wrapperClassImp = props.wrapperClass || \"yt-lite\";\r\n    var onIframeAdded = props.onIframeAdded || function () { };\r\n    var rel = props.rel ? 'prefetch' : 'preload';\r\n    var warmConnections = function () {\r\n        if (preconnected)\r\n            return;\r\n        setPreconnected(true);\r\n    };\r\n    var addIframe = function () {\r\n        if (iframe)\r\n            return;\r\n        setIframe(true);\r\n    };\r\n    React.useEffect(function () {\r\n        if (iframe) {\r\n            onIframeAdded();\r\n        }\r\n    }, [iframe]);\r\n    return (React.createElement(React.Fragment, null,\r\n        React.createElement(\"link\", { rel: rel, href: posterUrl, as: \"image\" }),\r\n        React.createElement(React.Fragment, null, preconnected && (React.createElement(React.Fragment, null,\r\n            React.createElement(\"link\", { rel: \"preconnect\", href: ytUrl }),\r\n            React.createElement(\"link\", { rel: \"preconnect\", href: \"https://www.google.com\" }),\r\n            adNetworkImp && (React.createElement(React.Fragment, null,\r\n                React.createElement(\"link\", { rel: \"preconnect\", href: \"https://static.doubleclick.net\" }),\r\n                React.createElement(\"link\", { rel: \"preconnect\", href: \"https://googleads.g.doubleclick.net\" })))))),\r\n        React.createElement(\"article\", { onPointerOver: warmConnections, onClick: addIframe, className: wrapperClassImp + \" \" + (iframe ? activatedClassImp : \"\"), \"data-title\": videoTitle, style: __assign({ backgroundImage: \"url(\" + posterUrl + \")\" }, {\r\n                '--aspect-ratio': (aspectHeight / aspectWidth) * 100 + \"%\",\r\n            }) },\r\n            React.createElement(\"button\", { type: \"button\", className: playerClassImp, \"aria-label\": announceWatch + \" \" + videoTitle }),\r\n            iframe && (React.createElement(\"iframe\", { className: iframeClassImp, title: videoTitle, width: \"560\", height: \"315\", frameBorder: \"0\", allow: \"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\", allowFullScreen: true, src: iframeSrc })))));\r\n}\n\nexport { LiteYouTubeEmbed as default };\n//# sourceMappingURL=index.es.jsx.map\n", "/* eslint-disable prettier/prettier */\nimport React from 'react';\nimport { PortableText } from '@portabletext/react';\n\nimport SanityImage from '~/components/SanityImage';\nimport SanityYoutube from '~/components/SanityYoutube';\n\ntype ContentProps = {\n  value: any[];\n};\n\nconst components = {\n  types: {\n    image: SanityImage,\n    youtube: SanityYoutube,\n  },\n};\n\nexport default function SanityContent(props: ContentProps) {\n  const { value } = props;\n\n  return (\n    <div className='prose font-serif dark:prose-invert md:prose-2xl prose-headings:font-mono prose-a:text-cyan-600 dark:prose-a:text-cyan-200'>\n      <PortableText value={value} components={components} />\n    </div>\n  );\n}\n"],
  "mappings": "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",
  "names": ["exports", "isPortableTextSpan", "node", "_type", "text", "marks", "Array", "isArray", "every", "mark", "isPortableTextBlock", "markDefs", "def", "_key", "children", "child", "isPortableTextListItemBlock", "block", "listItem", "level", "isPortableTextToolkitList", "isPortableTextToolkitSpan", "span", "isPortableTextToolkitTextNode", "knownDecorators", "sortMarksByOccurences", "index", "blockChildren", "length", "slice", "occurences", "forEach", "siblingIndex", "sibling", "indexOf", "sort", "markA", "markB", "sortMarks", "aOccurences", "bOccurences", "aKnownPos", "bKnownPos", "localeCompare", "buildMarksTree", "_a", "sortedMarks", "map", "rootNode", "markType", "nodeStack", "i", "marksNeeded", "pos", "markKey", "splice", "currentNode", "markDef", "find", "push", "lines", "split", "line", "concat", "nestLists", "blocks", "mode", "tree", "currentList", "listFromBlock", "blockMatchesList", "newList", "lastListItem", "newLastChild", "matchingBranch", "match", "findListMatching", "console", "warn", "list", "matching", "style", "filterOnType", "spanToPlainText", "span", "text", "children", "forEach", "current", "isPortableTextToolkitTextNode", "isPortableTextToolkitSpan", "LIST_NEST_MODE_HTML", "mergeComponents", "parent", "overrides", "block", "list", "listItem", "marks", "types", "rest", "mergeDeeply", "key", "override", "parentVal", "link", "children", "value", "jsx", "href", "underlineStyle", "textDecoration", "defaultMarks", "em", "strong", "code", "underline", "style", "defaultLists", "number", "bullet", "DefaultListItem", "getTemplate", "type", "prop", "unknownTypeWarning", "typeName", "unknownMarkWarning", "markType", "unknownBlockStyleWarning", "blockStyle", "unknownListStyleWarning", "listStyle", "unknownListItemStyleWarning", "printWarning", "message", "console", "warn", "hidden", "display", "DefaultUnknownType", "isInline", "warning", "_type", "DefaultUnknownMark", "className", "DefaultUnknownBlockStyle", "DefaultUnknownList", "DefaultUnknownListItem", "DefaultHardBreak", "defaultBlockStyles", "normal", "blockquote", "h1", "h2", "h3", "h4", "h5", "h6", "defaultComponents", "hardBreak", "unknownType", "unknownMark", "unknownList", "unknownListItem", "unknownBlockStyle", "PortableText", "input", "components", "componentOverrides", "listNestingMode", "onMissingComponent", "missingComponentHandler", "handleMissingComponent", "noop", "blocks", "Array", "isArray", "nested", "nestLists", "LIST_NEST_MODE_HTML", "useMemo", "renderNode", "getNodeRenderer", "rendered", "map", "node", "index", "options", "_key", "isPortableTextToolkitList", "renderList", "isPortableTextListItemBlock", "renderListItem", "isPortableTextToolkitSpan", "renderSpan", "isPortableTextBlock", "renderBlock", "isPortableTextToolkitTextNode", "renderText", "renderCustomBlock", "tree", "serializeBlock", "renderer", "handler", "Li", "nodeType", "blockNode", "child", "childIndex", "component", "List", "_index", "markDef", "markKey", "Span", "text", "spanToPlainText", "props", "Block", "HardBreak", "Node", "nodeOptions", "UnknownType", "buildMarksTree", "i", "urlBuilder", "__assign", "import_jsx_dev_runtime", "getYouTubeId", "import_jsx_dev_runtime"]
}
