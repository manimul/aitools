{
  "version": 3,
  "sources": ["../../../node_modules/mendoza/src/internal-patcher.ts", "../../../node_modules/mendoza/src/utf8.ts", "../../../node_modules/mendoza/src/simple-patcher.ts", "../../../node_modules/mendoza/src/incremental-patcher.ts"],
  "sourcesContent": ["import {ObjectModel} from './object-model'\nimport {RawPatch} from './patch'\n\nconst OPS = [\n  'Value',\n  'Copy',\n  'Blank',\n  'ReturnIntoArray',\n  'ReturnIntoObject',\n  'ReturnIntoObjectSameKey',\n  'PushField',\n  'PushElement',\n  'PushParent',\n  'Pop',\n  'PushFieldCopy',\n  'PushFieldBlank',\n  'PushElementCopy',\n  'PushElementBlank',\n  'ReturnIntoObjectPop',\n  'ReturnIntoObjectSameKeyPop',\n  'ReturnIntoArrayPop',\n  'ObjectSetFieldValue',\n  'ObjectCopyField',\n  'ObjectDeleteField',\n  'ArrayAppendValue',\n  'ArrayAppendSlice',\n  'StringAppendString',\n  'StringAppendSlice'\n]\n\ntype InputEntry<V> = {\n  value: V\n  key?: string\n  keys?: string[]\n}\n\ntype OutputEntry<V, S, O, A> = {\n  value: V | null\n  writeValue?: S | O | A\n}\n\nexport class Patcher<V, S, O, A> {\n  private model: ObjectModel<V, S, O, A>\n  private root: V\n  private patch: RawPatch\n  private i = 0\n  private inputStack: InputEntry<V>[] = []\n  private outputStack: OutputEntry<V, S, O, A>[] = []\n\n  constructor(model: ObjectModel<V, S, O, A>, root: V, patch: RawPatch) {\n    this.model = model\n    this.root = root\n    this.patch = patch\n  }\n\n  read(): unknown {\n    return this.patch[this.i++]\n  }\n\n  process() {\n    this.inputStack.push({value: this.root})\n    this.outputStack.push({value: this.root})\n\n    for (; this.i < this.patch.length; ) {\n      let opcode = this.read() as number\n      let op = OPS[opcode]\n      if (!op) throw new Error(`Unknown opcode: ${opcode}`)\n      let processor = `process${op}`\n      ;(this as any)[processor].apply(this)\n    }\n\n    let entry = this.outputStack.pop()!\n    return this.finalizeOutput(entry)\n  }\n\n  inputEntry(): InputEntry<V> {\n    return this.inputStack[this.inputStack.length - 1]\n  }\n\n  inputKey(entry: InputEntry<V>, idx: number): string {\n    if (!entry.keys) {\n      entry.keys = this.model.objectGetKeys(entry.value).sort()\n    }\n\n    return entry.keys[idx]\n  }\n\n  outputEntry(): OutputEntry<V, S, O, A> {\n    return this.outputStack[this.outputStack.length - 1]\n  }\n\n  outputArray(): A {\n    let entry = this.outputEntry()\n\n    if (!entry.writeValue) {\n      entry.writeValue = this.model.copyArray(entry.value)\n    }\n\n    return entry.writeValue as A\n  }\n\n  outputObject(): O {\n    let entry = this.outputEntry()\n\n    if (!entry.writeValue) {\n      entry.writeValue = this.model.copyObject(entry.value)\n    }\n\n    return entry.writeValue as O\n  }\n\n  outputString(): S {\n    let entry = this.outputEntry()\n\n    if (!entry.writeValue) {\n      entry.writeValue = this.model.copyString(entry.value)\n    }\n\n    return entry.writeValue as S\n  }\n\n  finalizeOutput(entry: OutputEntry<V, S, O, A>): V {\n    if (entry.writeValue) {\n      return this.model.finalize(entry.writeValue)\n    } else {\n      return entry.value!\n    }\n  }\n\n  // Processors:\n\n  processValue() {\n    let value = this.model.wrap(this.read())\n    this.outputStack.push({value})\n  }\n\n  processCopy() {\n    let input = this.inputEntry()\n    this.outputStack.push({value: input.value})\n  }\n\n  processBlank() {\n    this.outputStack.push({value: null})\n  }\n\n  processReturnIntoArray() {\n    let entry = this.outputStack.pop()!\n    let result = this.finalizeOutput(entry)\n    let arr = this.outputArray()\n    this.model.arrayAppendValue(arr, result)\n  }\n\n  processReturnIntoObject() {\n    let key = this.read() as string\n    let entry = this.outputStack.pop()!\n    let result = this.finalizeOutput(entry)\n    result = this.model.markChanged(result)\n    let obj = this.outputObject()\n    this.model.objectSetField(obj, key, result)\n  }\n\n  processReturnIntoObjectSameKey() {\n    let input = this.inputEntry()\n    let entry = this.outputStack.pop()!\n    let result = this.finalizeOutput(entry)\n    let obj = this.outputObject()\n    this.model.objectSetField(obj, input.key!, result)\n  }\n\n  processPushField() {\n    let idx = this.read() as number\n    let entry = this.inputEntry()\n    let key = this.inputKey(entry, idx)\n    let value = this.model.objectGetField(entry.value, key)\n    this.inputStack.push({value, key})\n  }\n\n  processPushElement() {\n    let idx = this.read() as number\n    let entry = this.inputEntry()\n    let value = this.model.arrayGetElement(entry.value, idx)\n    this.inputStack.push({value})\n  }\n\n  processPop() {\n    this.inputStack.pop()\n  }\n\n  processPushFieldCopy() {\n    this.processPushField()\n    this.processCopy()\n  }\n\n  processPushFieldBlank() {\n    this.processPushField()\n    this.processBlank()\n  }\n\n  processPushElementCopy() {\n    this.processPushElement()\n    this.processCopy()\n  }\n\n  processPushElementBlank() {\n    this.processPushElement()\n    this.processBlank()\n  }\n\n  processReturnIntoObjectPop() {\n    this.processReturnIntoObject()\n    this.processPop()\n  }\n\n  processReturnIntoObjectSameKeyPop() {\n    this.processReturnIntoObjectSameKey()\n    this.processPop()\n  }\n\n  processReturnIntoArrayPop() {\n    this.processReturnIntoArray()\n    this.processPop()\n  }\n\n  processObjectSetFieldValue() {\n    this.processValue()\n    this.processReturnIntoObject()\n  }\n\n  processObjectCopyField() {\n    this.processPushField()\n    this.processCopy()\n    this.processReturnIntoObjectSameKey()\n    this.processPop()\n  }\n\n  processObjectDeleteField() {\n    let idx = this.read() as number\n    let entry = this.inputEntry()\n    let key = this.inputKey(entry, idx)\n    let obj = this.outputObject()\n    this.model.objectDeleteField(obj, key)\n  }\n\n  processArrayAppendValue() {\n    let value = this.model.wrap(this.read())\n    let arr = this.outputArray()\n    this.model.arrayAppendValue(arr, value)\n  }\n\n  processArrayAppendSlice() {\n    let left = this.read() as number\n    let right = this.read() as number\n    let str = this.outputArray()\n    let val = this.inputEntry().value\n    this.model.arrayAppendSlice(str, val, left, right)\n  }\n\n  processStringAppendString() {\n    let value = this.model.wrap(this.read())\n    let str = this.outputString()\n    this.model.stringAppendValue(str, value)\n  }\n\n  processStringAppendSlice() {\n    let left = this.read() as number\n    let right = this.read() as number\n    let str = this.outputString()\n    let val = this.inputEntry().value\n    this.model.stringAppendSlice(str, val, left, right)\n  }\n}\n", "export function utf8charSize(code: number): 1 | 2 | 3 | 4 {\n  if (code >> 16) {\n    return 4\n  } else if (code >> 11) {\n    return 3\n  } else if (code >> 7) {\n    return 2\n  } else {\n    return 1\n  }\n}\n\nexport function utf8stringSize(str: string): number {\n  let b = 0\n  for (let i = 0; i < str.length; i++) {\n    let code = str.codePointAt(i)!\n    let size = utf8charSize(code)\n    if (size == 4) i++\n    b += size\n  }\n  return b\n}\n\n/** Converts an UTF-8 byte index into a UCS-2 index. */\nexport function utf8resolveIndex(str: string, idx: number, start = 0) {\n  let byteCount = start\n  let ucsIdx = 0\n\n  for (ucsIdx = start; byteCount < idx; ucsIdx++) {\n    let code = str.codePointAt(ucsIdx)!\n    let size = utf8charSize(code)\n    if (size === 4) ucsIdx++ // Surrogate pair.\n    byteCount += size\n  }\n\n  return ucsIdx\n}\n\nexport function commonPrefix(str: string, str2: string) {\n  let len = Math.min(str.length, str2.length)\n  let b = 0\n  for (let i = 0; i < len; ) {\n    let aPoint = str.codePointAt(i)!\n    let bPoint = str2.codePointAt(i)!\n    if (aPoint !== bPoint) return b\n    let size = utf8charSize(aPoint)\n    b += size\n    i += size === 4 ? 2 : 1\n  }\n  return b\n}\n\nexport function commonSuffix(str: string, str2: string, prefix: number = 0) {\n  let len = Math.min(str.length, str2.length) - prefix\n  let b = 0\n  for (let i = 0; i < len; ) {\n    let aPoint = str.codePointAt(str.length - 1 - i)!\n    let bPoint = str2.codePointAt(str2.length - 1 - i)!\n    if (aPoint !== bPoint) return b\n    let size = utf8charSize(aPoint)\n    b += size\n    i += size === 4 ? 2 : 1\n  }\n  return b\n}\n", "import {ObjectModel} from './object-model'\nimport {Patcher} from './internal-patcher'\nimport {RawPatch} from './patch'\nimport {utf8resolveIndex} from './utf8'\n\ntype StringBuilder = {type: 'string'; data: string}\ntype ObjectBuilder = {type: 'object'; data: {[key: string]: unknown}}\ntype ArrayBuilder = unknown[]\n\nconst Model: ObjectModel<unknown, StringBuilder, ObjectBuilder, ArrayBuilder> = {\n  wrap(data: any): unknown {\n    return data\n  },\n\n  finalize(b: StringBuilder | ObjectBuilder | ArrayBuilder): unknown {\n    if (Array.isArray(b)) {\n      return b\n    } else {\n      return b.data\n    }\n  },\n\n  markChanged(value) {\n    return value\n  },\n\n  objectGetKeys(value: unknown): string[] {\n    return Object.keys(value as any)\n  },\n\n  objectGetField(value: unknown, key: string): unknown {\n    return (value as any)[key]\n  },\n\n  arrayGetElement(value: unknown, idx: number): unknown {\n    return (value as any[])[idx]\n  },\n\n  copyObject(value: unknown | null): ObjectBuilder {\n    let res: ObjectBuilder = {\n      type: 'object',\n      data: {}\n    }\n    if (value !== null) {\n      for (let [key, val] of Object.entries(value as ObjectBuilder)) {\n        res.data[key] = val\n      }\n    }\n    return res\n  },\n\n  copyArray(value: unknown | null): ArrayBuilder {\n    if (value === null) return []\n    return (value as ArrayBuilder).slice()\n  },\n\n  copyString(value: unknown | null): StringBuilder {\n    return {\n      type: 'string',\n      data: value === null ? '' : (value as string)\n    }\n  },\n\n  objectSetField(target: ObjectBuilder, key: string, value: unknown): void {\n    target.data[key] = value\n  },\n\n  objectDeleteField(target: ObjectBuilder, key: string): void {\n    delete target.data[key]\n  },\n\n  arrayAppendValue(target: ArrayBuilder, value: unknown): void {\n    target.push(value)\n  },\n\n  arrayAppendSlice(target: ArrayBuilder, source: unknown, left: number, right: number): void {\n    target.push(...(source as ArrayBuilder).slice(left, right))\n  },\n\n  stringAppendSlice(target: StringBuilder, source: unknown, left: number, right: number): void {\n    const sourceString = source as string\n\n    const leftPos = utf8resolveIndex(sourceString, left)\n    const rightPos = utf8resolveIndex(sourceString, right, leftPos)\n\n    target.data += sourceString.slice(leftPos, rightPos)\n  },\n\n  stringAppendValue(target: StringBuilder, value: unknown): void {\n    target.data += value as string\n  }\n}\n\n// Applies a patch on a JavaScript object.\nexport function applyPatch(left: any, patch: RawPatch): any {\n  let root = left // No need to wrap because the representation is the same.\n  let patcher = new Patcher(Model, root, patch)\n  return patcher.process()\n}\n", "import {ObjectModel} from './object-model'\nimport {RawPatch} from './patch'\nimport {Patcher} from './internal-patcher'\nimport {utf8charSize, utf8stringSize, commonPrefix, commonSuffix} from './utf8'\n\n// The incremental patcher allows you to apply multiple patches and tracks the history of every element.\n// It also allows you to extract a simple diff between the documents.\n\nexport type Value<T> = {\n  data?: unknown\n  content?: Content<T>\n  startMeta: T\n  endMeta: T\n}\n\nexport type Type = 'array' | 'string' | 'object' | 'number' | 'boolean' | 'null'\n\nexport type Content<T> = ObjectContent<T> | ArrayContent<T> | StringContent<T>\n\nexport type ObjectContent<T> = {\n  type: 'object'\n  fields: {[key: string]: Value<T>}\n}\n\nexport type ArrayContent<T> = {\n  type: 'array'\n  elements: Value<T>[]\n  metas: T[]\n}\n\nexport type StringContent<T> = {\n  type: 'string'\n  parts: StringPart<T>[]\n}\n\nexport type StringPart<T> = {\n  value: string\n  utf8size: number\n  uses: StringContent<T>[]\n  startMeta: T\n  endMeta: T\n}\n\nclass Model<T>\n  implements ObjectModel<Value<T>, StringContent<T>, ObjectContent<T>, ArrayContent<T>> {\n  private meta: T\n\n  constructor(meta: T) {\n    this.meta = meta\n  }\n\n  wrap(data: unknown): Value<T> {\n    return this.wrapWithMeta(data, this.meta, this.meta)\n  }\n\n  wrapWithMeta(data: unknown, startMeta: T, endMeta: T = this.meta): Value<T> {\n    return {data, startMeta, endMeta}\n  }\n\n  asObject(value: Value<T>): ObjectContent<T> {\n    if (!value.content) {\n      let fields: ObjectContent<T>['fields'] = {}\n      for (let [key, val] of Object.entries(value.data as any)) {\n        fields[key] = this.wrapWithMeta(val, value.startMeta)\n      }\n      value.content = {type: 'object', fields}\n    }\n\n    return value.content as ObjectContent<T>\n  }\n\n  asArray(value: Value<T>): ArrayContent<T> {\n    if (!value.content) {\n      let elements = (value.data as unknown[]).map(item => this.wrapWithMeta(item, value.startMeta))\n      let metas = elements.map(() => this.meta)\n      value.content = {type: 'array', elements, metas}\n    }\n\n    return value.content as ArrayContent<T>\n  }\n\n  asString(value: Value<T>): StringContent<T> {\n    if (!value.content) {\n      let str = value.data as string\n\n      let part: StringPart<T> = {\n        value: str,\n        utf8size: utf8stringSize(str),\n        uses: [],\n        startMeta: value.startMeta,\n        endMeta: value.endMeta\n      }\n      value.content = this.stringFromParts([part])\n    }\n\n    return value.content as StringContent<T>\n  }\n\n  stringFromParts(parts: StringPart<T>[]): StringContent<T> {\n    let str: StringContent<T> = {\n      type: 'string',\n      parts\n    }\n\n    for (let part of parts) {\n      part.uses.push(str)\n    }\n\n    return str\n  }\n\n  objectGetKeys(value: Value<T>): string[] {\n    if (value.content) {\n      return Object.keys((value.content as ObjectContent<T>).fields)\n    } else {\n      return Object.keys(value.data as any)\n    }\n  }\n\n  objectGetField(value: Value<T>, key: string): Value<T> {\n    let obj = this.asObject(value)\n    return obj.fields[key]\n  }\n\n  arrayGetElement(value: Value<T>, idx: number): Value<T> {\n    let arr = this.asArray(value)\n    return arr.elements[idx]\n  }\n\n  finalize(content: Content<T>): Value<T> {\n    this.updateEndMeta(content)\n    return {content, startMeta: this.meta, endMeta: this.meta}\n  }\n\n  markChanged(value: Value<T>): Value<T> {\n    return this.wrap(unwrap(value))\n  }\n\n  updateEndMeta(content: Content<T>) {\n    if (content.type == 'string') {\n      for (let part of content.parts) {\n        part.endMeta = this.meta\n      }\n    } else {\n      if (content.type === 'array') {\n        for (let val of content.elements) {\n          if (val.content && val.endMeta !== this.meta) {\n            this.updateEndMeta(val.content)\n          }\n          val.endMeta = this.meta\n        }\n      } else {\n        for (let val of Object.values(content.fields)) {\n          if (val.content && val.endMeta !== this.meta) {\n            this.updateEndMeta(val.content)\n          }\n          val.endMeta = this.meta\n        }\n      }\n    }\n  }\n\n  copyString(value: Value<T> | null): StringContent<T> {\n    if (value) {\n      let other = this.asString(value)\n      return this.stringFromParts(other.parts.slice())\n    } else {\n      return {\n        type: 'string',\n        parts: []\n      }\n    }\n  }\n\n  copyObject(value: Value<T> | null): ObjectContent<T> {\n    let obj: ObjectContent<T> = {\n      type: 'object',\n      fields: {}\n    }\n\n    if (value) {\n      let other = this.asObject(value)\n      Object.assign(obj.fields, other.fields)\n    }\n\n    return obj\n  }\n\n  copyArray(value: Value<T> | null): ArrayContent<T> {\n    let arr = value ? this.asArray(value) : null\n    let elements = arr ? arr.elements : []\n    let metas = arr ? arr.metas : []\n\n    return {\n      type: 'array',\n      elements,\n      metas\n    }\n  }\n\n  objectSetField(target: ObjectContent<T>, key: string, value: Value<T>): void {\n    target.fields[key] = value\n  }\n\n  objectDeleteField(target: ObjectContent<T>, key: string): void {\n    delete target.fields[key]\n  }\n\n  arrayAppendValue(target: ArrayContent<T>, value: Value<T>): void {\n    target.elements.push(value)\n    target.metas.push(this.meta)\n  }\n\n  arrayAppendSlice(target: ArrayContent<T>, source: Value<T>, left: number, right: number): void {\n    let arr = this.asArray(source)\n    let samePosition = arr.elements.length === left\n\n    target.elements.push(...arr.elements.slice(left, right))\n\n    if (samePosition) {\n      target.metas.push(...arr.metas.slice(left, right))\n    } else {\n      for (let i = left; i < right; i++) {\n        target.metas.push(this.meta)\n      }\n    }\n  }\n\n  stringAppendValue(target: StringContent<T>, value: Value<T>): void {\n    let str = this.asString(value)\n    for (let part of str.parts) {\n      this.stringAppendPart(target, part)\n    }\n  }\n\n  stringAppendPart(target: StringContent<T>, part: StringPart<T>): void {\n    target.parts.push(part)\n    part.uses.push(target)\n  }\n\n  resolveStringPart(str: StringContent<T>, from: number, len: number): number {\n    if (len === 0) return from\n\n    for (let i = from; i < str.parts.length; i++) {\n      let part = str.parts[i]\n\n      if (len === part.utf8size) {\n        // Matches perfect!\n        return i + 1\n      }\n\n      if (len < part.utf8size) {\n        // It's a part of this chunk. We now need to split it up.\n        this.splitString(part, len)\n        return i + 1\n      }\n\n      len -= part.utf8size\n    }\n\n    throw new Error('splitting string out of bounds')\n  }\n\n  splitString(part: StringPart<T>, idx: number) {\n    let leftValue\n    let rightValue\n    let leftSize = idx\n    let rightSize = part.utf8size - leftSize\n\n    // idx is here in UTF-8 index, not codepoint index.\n    // This means we might to adjust for multi-byte characters.\n    if (part.utf8size !== part.value.length) {\n      let byteCount = 0\n\n      for (idx = 0; byteCount < leftSize; idx++) {\n        let code = part.value.codePointAt(idx)!\n        let size = utf8charSize(code)\n        if (size === 4) idx++ // Surrogate pair.\n        byteCount += size\n      }\n    }\n\n    leftValue = part.value.slice(0, idx)\n    rightValue = part.value.slice(idx)\n\n    let newPart: StringPart<T> = {\n      value: rightValue,\n      utf8size: rightSize,\n      uses: part.uses.slice(),\n      startMeta: part.startMeta,\n      endMeta: part.endMeta\n    }\n\n    part.value = leftValue\n    part.utf8size = leftSize\n\n    for (let use of part.uses) {\n      // Insert the new part.\n      let idx = use.parts.indexOf(part)\n      if (idx === -1) throw new Error('bug: mismatch between string parts and use.')\n      use.parts.splice(idx + 1, 0, newPart)\n    }\n  }\n\n  stringAppendSlice(target: StringContent<T>, source: Value<T>, left: number, right: number): void {\n    let str = this.asString(source)\n    let firstPart = this.resolveStringPart(str, 0, left)\n    let lastPart = this.resolveStringPart(str, firstPart, right - left)\n\n    for (let i = firstPart; i < lastPart; i++) {\n      let part = str.parts[i]\n      this.stringAppendPart(target, part)\n    }\n  }\n}\n\n// Turns a native JavaScript object into a Value with a given origin.\nexport function wrap<T>(data: unknown, meta: T): Value<T> {\n  return {data, startMeta: meta, endMeta: meta}\n}\n\n// Converts a Value into a native JavaScript type.\nexport function unwrap<T>(value: Value<T>): unknown {\n  if (typeof value.data !== 'undefined') return value.data\n\n  let result: any\n  let content = value.content!\n  switch (content.type) {\n    case 'string':\n      result = content.parts.map(part => part.value).join('')\n      break\n    case 'array':\n      result = content.elements.map(val => unwrap(val))\n      break\n    case 'object': {\n      result = {}\n      for (let [key, val] of Object.entries(content.fields)) {\n        result[key] = unwrap(val)\n      }\n    }\n  }\n\n  value.data = result\n  return result\n}\n\n// Returns the type of a Value.\nexport function getType<T>(value: Value<T>): Type {\n  if (value.content) return value.content.type\n  if (Array.isArray(value.data!)) return 'array'\n  if (value.data === null) return 'null'\n\n  return typeof value.data as Type\n}\n\n// Updates the `right` value such that it reuses as much as possible from the `left` value.\nexport function rebaseValue<T>(left: Value<T>, right: Value<T>): Value<T> {\n  let leftType = getType(left)\n  let rightType = getType(right)\n  if (leftType !== rightType) return right\n\n  let leftModel = new Model(left.endMeta)\n  let rightModel = new Model(right.endMeta)\n\n  switch (leftType) {\n    case 'object': {\n      let leftObj = leftModel.asObject(left)\n      let rightObj = rightModel.asObject(right)\n\n      // Number of fields which are identical in left and right.\n      let identicalFieldCount = 0\n      let leftFieldCount = Object.keys(leftObj.fields).length\n      let rightFieldCount = Object.keys(rightObj.fields).length\n\n      for (let [key, rightVal] of Object.entries(rightObj.fields)) {\n        let leftVal = leftObj.fields[key]\n        if (leftVal) {\n          rightObj.fields[key] = rebaseValue(leftVal, rightVal)\n          if (rightObj.fields[key] === leftVal) {\n            identicalFieldCount++\n          }\n        }\n      }\n\n      let isIdentical = leftFieldCount === rightFieldCount && leftFieldCount === identicalFieldCount\n      return isIdentical ? left : right\n    }\n    case 'array': {\n      let leftArr = leftModel.asArray(left)\n      let rightArr = rightModel.asArray(right)\n\n      if (leftArr.elements.length !== rightArr.elements.length) {\n        break\n      }\n\n      let numRebased = 0\n      for (let i = 0; i < rightArr.elements.length; i++) {\n        rightArr.elements[i] = rebaseValue(leftArr.elements[i], rightArr.elements[i])\n        if (rightArr.elements[i] !== leftArr.elements[i]) {\n          numRebased++\n        }\n      }\n\n      return numRebased === 0 ? left : right\n    }\n    case 'null':\n    case 'boolean':\n    case 'number': {\n      if (unwrap(left) === unwrap(right)) return left\n      break\n    }\n    case 'string': {\n      let leftRaw = unwrap(left) as string\n      let rightRaw = unwrap(right) as string\n      if (leftRaw === rightRaw) return left\n\n      let result = rightModel.copyString(null)\n      let prefix = commonPrefix(leftRaw, rightRaw)\n      let suffix = commonSuffix(leftRaw, rightRaw, prefix)\n\n      let rightLen = utf8stringSize(rightRaw)\n      let leftLen = utf8stringSize(leftRaw)\n\n      if (0 < prefix) {\n        rightModel.stringAppendSlice(result, left, 0, prefix)\n      }\n      if (prefix < rightLen - suffix) {\n        rightModel.stringAppendSlice(result, right, prefix, rightLen - suffix)\n      }\n      if (leftLen - suffix < leftLen) {\n        rightModel.stringAppendSlice(result, left, leftLen - suffix, leftLen)\n      }\n      let value = rightModel.finalize(result)\n      if (unwrap(value) !== rightRaw) throw new Error('incorrect string rebase')\n      return value\n    }\n  }\n\n  return right\n}\n\nexport function applyPatch<T>(left: Value<T>, patch: RawPatch, startMeta: T) {\n  let model = new Model(startMeta)\n  let patcher = new Patcher(model, left, patch)\n  return patcher.process()\n}\n"],
  "mappings": "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",
  "names": ["Patcher", "applyPatch", "Model", "val", "applyPatch"]
}
